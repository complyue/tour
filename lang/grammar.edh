{## Syntax, Semantics, and Pragmatics of Ä #}

{## Ä Grammar Details #}
export edh'grammar'details = bookmark()


{## Overview
 # - Why and What is here with Ä

Ä seeks to ease development of embedded DSLs (Domain Specific Langauges) speaking / realizing business needs, i.e. a Business Integration language. How computers work and to be optimized in solving programming problems, are addressed by a large research discipline in its own right, i.e. Computer Science. But CS is too different and often too far from practical needs of realworld business, dedicated languages are of much interest, and Ä attempts to be a comprehensive solution.

**Ä (Edh)** stands for **Event Distributing & Hosting**, an _event_ is a consistent (but not necessarily atomic) piece of data, encapsulating the information of something just happend in one place, and sent to another place for its consequences to be realized there. _Event_ is conceptually coherent to **Algebraic Data Type** in _type theory_ as well as a functional programming language, but it's not practical to be a mechanical utility in a procedural langauge like Ä. So _event_ stays conceptual in Ä the language.

The _event_ abstraction should decouple much of the complexity, and degrade much part of the problem, to be solvable by _Citizen Developers_, especially with the aid of modern software engineering toolings.

You will be using Ä to describe reactions to incoming events from other parts of the system, in forms of local entity attribute updates, and more complex logics with control flows. As well, you can post commands for event delivery, to other parts of the system. Modularized components can be developed for reuse, by your team or by 3rd parties. Realworld systems are inherently effectful, any event upon it is distributed / hosted, usually implies effects it should cause, you will also use Ä to describe what effects are expected to be there, and how those effects should be realized. Note effects are inherently context sensitive, as a fairly sophisticated effect is usually implemented by means of other effects, those maybe simpler but nevertheless sensitive to their own context.

**Monad** is state of the art way for effect tracking, while **Algebraic Effects & Handlers** being actively researched in academic for similiar purpose today, but they both work with functional programming langauges. Then inspired by **Algebraic Effects & Handlers**, Ä implements **Dynamic Scoped Effects** for effect tracking in the imperative / procedural paradigm. It is **Dynamic Scoping** per se. Historically, **Dynamic Scoping** designs are proved failures, but with Ä's dedicated syntax / namespacing to have dynamic artifacts isolated from lexical artifacts, the confusing semantics / behaviors can be avoided, and then finally done right.

 #} {;
  {## Overview #}
  export edh'lang'overview = bookmark()
}


export edh'syntax = bookmark()


{## Syntax & Style
 # - Ä code style is officially opinionated
 #} {;
  {## Syntax & Style #}
  export edh'syntax'style = bookmark()

  {## The Official Ä Code Formatter
   # - Any style you like, so long as it is formatted such

Ä encourages (turns-on-by-default) format-on-save, by the official no-config, uncompromised formatter:

  https://github.com/e-wrks/edh-vscode-formatter
  https://marketplace.visualstudio.com/items?itemName=ComplYue.edh-vscode-formatter

The motivation of such a formatter is quite inspired by Black:

  https://black.readthedocs.io

That's to save you time and mental energy for more important matters.

FYI, the original idea comes from Henry Ford's famous quotes about the Model T:

> Any customer can have a car painted any colour that he wants,
> so long as it is black.

Also opinionated formatters with similar goals:
  https://prettier.io  - Prettier for JavaScript (and HTML, CSS etc.)
  https://github.com/tweag/ormolu  - Ormolu for Haskell

   #} {;
    {## The Official Ä Code Formatter #}
    export edh'code'formatter = bookmark()

    # Home page of the formatter should have described the rules and your rights (freedom) well. After modification, save it, or right-click anywhere, then select [Format Document], the formatter will adjust the file content according to the rules, you'll see what it thinks.

    # %% # try play with this cell:
    # indent or outdent the line, add/remove extranous spaces, break it into multiple lines, add extranous blank lines, ...
    1+ ( 2 - 3 ) *5 /9
    # %#

    # TODO any gotcha to be showcased here?
  }

  {## Indentation and Brackets
   # - Ä interpreter is whitespace insensitive, indentation is enforced by Ä formatter

The programmer is responsible for the brackets (scoping), while the formatter is in charge of proper indentation, it infers indentation level of each line from the nesting of brackets.

   #} {;

    {## Whitespace Sensitivity is Outdated
     # - Indentation can be inferred, no reason to DIY today

> Why Pythonâ€™s whitespace rule is right
  https://unspecified.wordpress.com/2011/10/18/why-pythons-whitespace-rule-is-right

> There is not a single situation in any country, in any programming language, or at any skill level, in which is it acceptable to not indent your code the way Python requires it.

This is much agreeable even at today.

> When you really analyse it, Pythonâ€™s whitespace sensitivity is actually the only logical choice for a programming language, ...

Well, this conclusion holds right in its time, when auto code formatters are still some luxury to have. But today, besides the compiler(s), we are affording way more expensive analyzing tools like linters, test runners, coverage, profilers, and usually comprehensive langauge servers, amongst what code formatters become rather commonplace.

Scopes (either lexical or conceptual) have to be decided and expressed by the programmer (or document writer), but even excluding extreme cases, a code block can consist of up to hundreds of lines, it's ridiculous to manually maintain proper indentation for every line, when the formatter can do it for you straight forward.

Whitespace sensitivity has become outdated today, brackets (curly, square or round) come handy-dandy to express various scopes in your mind, just leave indentation for the formatters to care about.

     #
     #} {;
      {## Ä is Whitespace Insensitive #}
      export edh'sps'insensitivity = bookmark()

      {## Comments are Indented
       # - Both line comment and block comment

As you may have noticed, block comments (started with `{#`) are indented, also a line of comments are indented when it starts with #, whether it is a standalone line comment, or part of a block comment.

       #} {;
        {## Comments are Indented #}
        export edh'cmt'indent = bookmark()

        # This is a standalone comment line, will always be indented by the formatter. Try adjust the indentation level of any line in this section, then save or do [Format Document] to see how the formatter corrects your mistakes.

        {# This is a short block comment #}

        {# This is multi-line block comment

         # This line is part of the outer comment block, but will be indented by the formatter, as it starts with #.

Try remove the leading # of the line above, then adjust its indentation level, you'll see the formatter stops working against you.

         #}

        {## This is a doc comment
         # A doc comment makes sense when placed:
         #  * At the very beginning of an Ä module file
         #    - Serving as the documentation for that whole module
         #  * Immediately before a block
         #    - Serving as the documentation for that nested block
         #  * Immediately before a statement
         #    - Serving as the documentation for whatever defined by that statement, possible being:
         #      * A procedure
         #      * A class
         #      * An attribute
         #}
        edh'documented'attr'example'ð›‘ = 3.14
      }

    }

  }


  {## Semicolons and Commas
   # - They are optional everywhere in Ä, unless for disambiguation
   #} {;
    {## Semicolons and Commas #}
    export edh'semicolons'and'commas = bookmark()

    {## Technically Optional
     # - That is, can be omitted

Semicolons can be really technically omitted in Ä, not the case like in JavaScript that the language does:
  > Automatic Semicolon Insertion
  https://tc39.es/ecma262/#sec-automatic-semicolon-insertion

Which means, leading ones, trailing ones, as well as middle ones, all can be omitted.

     #} {;
      {## Technically Optional #}
      export edh'omit'semicolon'and'commas = bookmark()

      # Let's see some examples with the idiomatic form pointed out.

      # The following 5 cells have identical semantics and equally evaluates a block, gives out the value of last assignment statement in it
      # %%
      { a=5; b=3; c=9; }
      # %%
      {; a=5 b=3 c=9 } # <- idiomatic one
      # %%
      { a=5 b=3; c=9 }
      # %%
      { a=5 b=3 c=9; }
      # %%
      { a=5 b=3 c=9 }
      # %#

      # The following 5 cells too, have identical semantics and equal result value of a dict
      # %%
      { 'a': 5, 'b': 3, 'c': 9, } # <- idiomatic one
      # %%
      {, 'a': 5 'b': 3 'c': 9 }
      # %%
      { 'a': 5 'b': 3, 'c': 9 }
      # %%
      { 'a': 5 'b': 3 'c': 9, }
      # %%
      { 'a': 5 'b': 3 'c': 9 }
      # %#

      # The following 5 cells too, have identical semantics and equal result value of a list
      # %%
      ; [ 5, 3, 9, ] # <- idiomatic one
      # %%
      ; [, 5 3 9 ]
      # %%
      ; [ 5 3, 9 ]
      # %%
      ; [ 5 3 9, ]
      # %%
      ; [ 5 3 9 ]
      # %#

      # The following 5 cells too, have identical semantics and result value of a positional-only ArgsPack
      # %%
      ; ( 5, 3, 9, ) # <- idiomatic one
      # %%
      ; (, 5 3 9 )
      # %%
      ; ( 5 3, 9 )
      # %%
      ; ( 5 3 9, )
      # %%
      ; ( 5 3 9 )
      # %#
    }

    {## Disambiguation Needs
     # - At times, a semicolon / comma is needed for disambiguation
     #} {;
      {## Disambiguation Needs #}
      export edh'disambiguation'needs = bookmark()

      {## Unintended Indexing / Calling
       #} {; export edh'disambig'idx'call = bookmark()
        # There usually need a semicolon before a pair of square/round brackets, when you don't mean to do indexing or calling against artifact before it.
        # %% # A list literal
        ; [ 3, 2, 5, ]
        # %% # An apk literal
        ; ( 3, 2, 5, x= 7, y= 23, )
        # %#
      }

      {## Block instead of Dict
       #} {; export edh'disambig'blk'dict = bookmark()
        # You may have noticed the semicolons everywhere, each following an opening curly brace too. Why are they there?

        # %% # Well, check out this:
        type( {; } )
        # %% # Then this:
        type( {} )
        # %#

        # The answer is: The semicolon inside `{;}` disambiguates it being a block (though empty) instead of an empty dict expressed as `{}`

        # FYI, in Ä, block is a type of expression (instead of statement as in C family languages). A block encloses arbitrary number of statements, and evaluates to the value of the last statement when executed (with the exceptin of branches' early break, though, about that later)
        # %% # And an empty block evals to `nil`, check this to be true
        {; } is nil
        # %#

        # Though you don't need a semicolon when there is at least 1 statement in a block, e.g.
        # %% # This is a block with a single assignment expression statement
        { a=1 }
        # %% # But this is the idiomatic form, which is preferable for foolproof modifications in later code maintenance:
        {; a=1 }
        # %#
      }

      {## ArgsPack instead of Expression-in-Parenthese
       #} {; export edh'disambig'apk'paren = bookmark()
        # A comma is needed to disambiguate ArgsPack (a super type of Python tuple), from parenthese-quoted single expression
        # %% # A single apk
        ; ( 3*7, )
        # %% # A parenthese-quoted expression
        ; ( 3*7 )
        # %%
        ; type( ( 3*7, ) )
        # %%
        ; type( ( 3*7 ) )
        # %#
      }
    }

    {## Idioms
     # - Idiomatic Semicolon / Comma Placements

In Ä code it's considered idiomatic to:

* Avoid semicolons without good reasons
* Place trailing commas where possible

     #} {;
      {## Idioms #}
      export edh'semicolon'comma'idioms = bookmark()

      # The idiomatic style is to put a semicolon right after the opening curly brace/bracket, when a block instead of dict literal intended:
      {;
        # It can still parse as dict literal with comments inside, if without the semicolon
      }

    }

  }


  {## Recommended Line Length
   # - It is under your control, well some advice here

For the record, Ä langauge support extension for VSCode sets the following config options per the language:

* Show rulers at column positions: 80, 100, 120
* Soft-wrap lines at 100, while adapting to narrower window width

You are recommended to hard-wrap source lines around column 80, and that's not for good old line printers set for Fortran punch cards, but to enable a human reader have 2~3 editor columns layed out on wide screens, to cross check code segments from multiple sites, without necessarity of tab switching, which is good for productivity.

For long paragraphs in comments, of mere documentation purpose, it's considered more idiomatic to keep them as long lines per each paragraph, so you don't need to manually maintain hard-wrap points when update documentation, just leave it soft-wrapped at 100 columns by default.

Nevertheless you can change per user settings of your IDE, for a different soft wrap strategy.

   #} {;
    {## Recommended Line Length #}
    export edh'line'len'adivce = bookmark()

    # %%
    '''
                                                                    80 columns â–½
12345678901234567890123456789012345678901234567890123456789012345678901234567890
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                                                                       100 columns â–³
'''
    # %#
  }

}


export edh'semantics = bookmark()


{## Entities, Attributes and Identifiers
 # - Each entity consists of a dynamic set of attribute values identified by distinct identifiers

Entity is the logical unit of information that organized in an Ä world. Entities only exist conceptually, some entities are used to each back a scope (module scope or procedure scope), other entities are used to each back an object (excepting host objects). While some objects (e.g. module objects, namespace objects, class objects) each encapsulate a scope of its own, such an object and the scope it encapsolutes are both backed by a same entity.

Ä is rather dynamic in nature - at runtime, not only each individual attribute value can change arbitrarily, new attributes can be added to an entity, as well as existing attributes can be deleted from it. That is to say, the structure as well as the attribute values of each entity can vary on its own at runtime.

 #} {;
  {## Entities, Attributes and Identifiers #}
  export edh'ent'attr'naming = bookmark()


  {## Mutable Entities
   # - Dynamic means mutability

All program states of an Ä program pertain to certain entities at the run. Be it a scope, or an object, its backing entity can always be mutated, at any time, as within an Ä world. The modifications usually come from the software component managing program states, but it's fairly common for some monitoring UIs, or interactive REPLs over stdio or network (SSH, WebSocket, etc.) to observe/change the program states for diagnostics / troubleshooting purposes.

   #} {;
    {## Mutable Entities #}
    export edh'entities = bookmark()
  }


  {## Attribute Identifiers
   # - About naming attributes

Each attribute of an entity has to be uniquely identified within scope of this entity. In Ä, the usual alphanumeric "variable" identifiers (like in other programming languages) can be used.

In addition, symbolic identifiers are also supported and recommended for cross-component scenarios.

And technically, any string (even the empty string) can serve as an attribute identifier in Ä, with at-notation.

Note that in the Ä language there is no such a concept/term of "variable". The "variable" concept in conventional programming languages is misleading or conflicting when you could possibly have mathematical concepts in the domain model of your business. More properly it should be called "assignable" as suggested in:
  https://existentialtype.wordpress.com/2013/07/22/there-is-such-a-thing-as-a-declarative-language

Although attributes of entities in Ä are inherently meant to be assigned (as well as to be observed), they can not stand alone without a backing entity. Unlike in conventional programming languages, where a "variable" can be assigned individually.

   #} {;
    {## Attribute Identifiers #}
    export edh'attr'ids = bookmark()


    {## A Typical Entity Example
     # - Let's take a namespace object for example
     #} {;
      {## A Typical Entity Example #}
      export edh'entity'example = bookmark()

      # Namespaces are described later in this chapter
      ; () => edh'namespaces # <- follow this bookmark to that section

      # %% # An empty namespace object can be created like this
      namespace ns() pass
      dir$ ns
      # %#

    }


    {## Alphanumeric Names
     # - The usual "variable" identifiers in a programming language

An alphanumeric name must start with a letter (i.e. alphabetic Unicode characters (lower-case, upper-case and title-case letters, plus letters of caseless scripts and modifiers letters) or the underscore character (_); more characters can follow, and they must be alphabetic or numeric Unicode characters, or the underscore character (_) or the single-quote character (').

Note the single-quote character is allowed to mean the prime symbol as in mathematics, following Haskell convention.

     #} {;
      {## Alphanumeric Names #}
      export edh'alphanum'names = bookmark()


      # %% # Some examples:
      namespace alphanum'named'arts (
        a= 3, _b3= 2, a'= 5,
        x= 9, y_5= 1, x''= 6,
        name= 'Compl', city= 'Chongqing', year= 2021,
        ð›‘= 3.141592653589793238462643383279502884197169399375105820974944592307,
        Î©= 0.567143290409783872999968662210,
        Ã= 'A language with great tooling',
      ) {

        method factorial(n) n <= 1 and 1 or n * factorial(n - 1)

        method ð›´(*items) case items of {
          () -> 0
          { item1 :> rest } -> {
            s = item1
            for i from rest do s += i
            return s
          }
        }

      }
      dir$ alphanum'named'arts

      # %% # Method procedures in a namespace can be called via dot-notation
      alphanum'named'arts.factorial(5)
      # %%
      alphanum'named'arts.ð›´( 3, 7, 9, )
      # %# Procedures and dot-notation are described later in this chapter
      ; () => edh'procs # <- follow this bookmark to that section
      ; () => edh'dot'notation # <- follow this bookmark to that section

      # %% # Expressions can be evaluated in scope of a namespace via a scope wrapper
      scope(alphanum'named'arts).eval(expr
        ð›´( 3, 7, 9, )
      )
      # %# Expression values and scope wrappers are described later in this chapter
      ; () => edh'exprs'in'scopes # <- follow this bookmark to that section


      {## The Underscore (_) Attribute Key
       # - A blackhole wrt assignment

Special note about the single character identifier with a mere underscore, it is a valid identifier but acts as a blackhole wrt scope attribute assignment. It is idiomatic to explicitly discard the direct result value this way, when only side-effects are desired from some expression with a meaningful return value.

       #} {;
        {## The Underscore (_) Attribute Key #}
        export edh'underscore'attr = bookmark()

        # %% % Assigning to `_` will not create an attribute named `_` in current scope, though all side-effects by evaluating the right-hand-side expression will apply.
        _ = 3 * 7 # TODO a better example with desirable side-effects
        dir
        # %# See there is no attribute named `_` appeared.

      }

    }


    {## Symbolic Names and At-Notation
     # - To avoid name clashing across indenpendant software components

Symbol is a special type of values solely for identification purpose, they are defined and used via at-notations.

FYI the other mainstream programming language having symbols is JavaScript, though there is no dedicated syntax in JavaScript as in Ä.

     #} {;
      {## Symbolic Names and At-Notation #}
      export edh'symbolic'names = bookmark()
      export edh'at'notation = bookmark()

      # A symbol is a value of special type, can only be created with a special syntax, where an alphanumeric name for the attribute in current scope to receive the symbol value is specified.
      # %% # Define a symbol named `secret`
      symbol @secret
      dir
      # %% # Its alphanumeric name can be used against current scope to obtain the value
      type(secret) is SymbolType
      # %# See above is true.

      # %% # Create a new attribute named after it, in the namespace, by assignment
      ns.@secret = 55632
      ns.@secret
      # %# Note neither `.` nor `@` as in above is an operator, also not that they combined. Instead, "dot" (.) followed by "at" (@) and an alphanumeric name, is intrinsic to the language syntax in this form. Remind that `@` can be part (or whole) of an operator symbol, while `.` can never be.
      # And you can have spaces above around both the "dot" and the "at", up to your style.

      # %% # There is another form of at-notation works as well, through `@` as an infix operator
      show$ (@)
      # %% # Assignments and references work straight forward
      ns @ secret = 33526
      ns @ secret
      # %# Note the spaces around `@` above is optional, Ä formatter honors your stylish to have them or not, but more whitespaces will be collapsed into one.

      # %% # Now create a new attribute named after this symbol, in current scope, by assignment
      ; @secret = 33526
      dir
      # %% # Note the semicolons needed above and below to disambiguate from infix at-notation.
      ; @secret
      # %#

      # The name for the attribute storing a symbol value, and the attribute named after the symbol value, are two different things. A symbol value can be stored under any other name, and used via that alias as well:
      # %% # Create an alias of the `secret` symbol value
      confidential = secret
      ns.@confidential
      # %% # It is ultimately the symbol value that matters for a symbolic attribute, not how that symbol value is named, so:
      console.print$ 'Before changed, @secret is: ' ++ ns.@secret
      ns.@confidential = 12345
      console.print$ 'After changed, @secret is: ' ++ ns.@secret
      # %% # Figured out why `@secret` is changed by assigning to `@confidential` ? Hint:
      confidential is secret
      # %# That's it, the symbol value for the symbolic names are the same, regardless of how these key values are stored and obtained. This mechanism allows you to import symbols from alien modules, but renamed locally to avoid alphanumeric name clashing, while still be able to exchange symbolic attributes seamlessly.

      # %% # Nothing prevents you from creating a new symbol value under an existing name, the old, alphanumericly named attribute for the symbol value, will simply be overwritten:
      symbol @secret
      confidential is secret
      # %% # Now they are different keys, so the symbolic names via them are different attributes, thus can be created/changed independently:
      console.print$ 'Before changed, @confidential is: ' ++ ns.@confidential
      ns.@secret = 54321
      console.print$ 'After changed, @confidential is: ' ++ ns.@confidential
      # %#

      # %% # It can surprise you now:
      dir$ ns
      # %# Confused seeing two "@secret" attributes coexisting?
      # %% # As well as:
      dir
      # %# See "confidential= @secret" in the result? That's because a symbol value has its `repr` reflecting how it is initially defined, and will never change, though the value can be assigned to different names as we have demonstrated here.
    }


    {## Quaint Names
     # - Arbitrary string as identifiers

Another interesting usage of at-notation is, that string values can be used in place of symbols, this enables arbitrary strings as attribute identifiers.

     #} {;
      {## Quaint Names #}
      export edh'quaint'names = bookmark()

      # %% # Using string literals is idiomatic for identifiers otherwise not valid alphanumeric names
      ns.@'we-the-people' = 'proud humans'
      dir$ ns
      # %# Note the minus inside the key, they'll be interpreted as subtraction operators if not be in a string key of the at-notation.

      # A string valued attribute can be used in at-notation for the key value, thus manifesting dynamicly named attributes, but you are advised against this style unless absolutely necessary.
      # %% %
      bad'symbolic'looking'key = 'No, No, No!'
      ns.@bad'symbolic'looking'key = 'Confusing :-/'
      dir$ ns
      # %# Note there are cases it is useful, but rare.
    }

  }


  {## Namespacing and Dot-Notation
   # - Every entity is a namespace (in general sense)

As every attribute is uniquely identified by a name within an entity, it naturally becomes a namespace, where the identifiers form the set of names. Though the set is highly dynamic, in the sense that an attribute value after a new name can be added at any time, as well as existing names deleted thereof.

Dot-notation is the norm with imperative programming languages, the reason probably lies in the better ergonomics when mutable data structures are manipulated, as the syntactic sugar for field read/write, that exactly the same syntax is used for the target.

FYI in functional programming languages (such as Haskell), the dot (.) is already used as the operator for function composition, there are alternative means of namespacing (such as "lenses") are used instead of dot-notation.

   #} {;
    {## Namespacing and Dot-Notation #}
    export edh'ns'dot'notation = bookmark()


    {## The Special Namespace Class
     # - Namespace is also a special class in Ä, with dedicated syntax
     #} {;
      {## The Special Namespace Class #}
      export edh'ns'special = bookmark()

      # Namespaces are further described later in this chapter
      ; () => edh'namespaces # <- follow this bookmark to that section

      # %% # Namespace objects are created with a special syntax, e.g.:
      symbol @ns'secret
      namespace ns(a= 3, b= 2, @ns'secret= 37256, ) {
        c = a - b / 5
        ; @'full-time' = false
      }
      dir$ ns
      # %# Following the `namespace` keyword, first comes name of the namespace, it can be any valid attribute identifier, and will be used as the attribute name for current scope to receive the new namespace object.
      # Then there is an arguments pack, but no positional argument is expected there, just named arguments to come, they'll be the namespace's attributes as you'd intuit.
      # Finally there's the namespace procedure body, all sorts of statements can go there, they'll be evaluated in a scope with the backing entity being exactly the namespace object's backing entity, so as to further initialize attributes in that entity.
    }


    {## Obtaining Attribute Value
     # - Read out an attribute value
     #} {;
      {## Obtaining Attribute Value #}
      export edh'attr'read = bookmark()


      {## From Current Scope

A standalone attribute name as an _attribute expression_, just reads such named attribute from current scope (or the first lexical outer scope having it, in case all inner scopes don't have it).

       #} {;
        {## From Current Scope #}
        export edh'scope'attr'read = bookmark()

        # Scoped attribute reading is subject to lexical scoping rules, which is described later in this chapter
        ; () => edh'lexi'scoping # <- follow this bookmark to that section

        # %% # A `scope` wrapper object can be used to evaluate expressions with the wrapped object's backing entity as their current scope:
        scope(ns).eval(expr
          @ns'secret * 2 - c / b
        )
        # %# Expression values and scope wrappers are described later in this chapter
        ; () => edh'exprs'in'scopes # <- follow this bookmark to that section

        # %% # Using alphanumeric name
        scope(ns).eval(expr
          b
        )
        # %% # Using symbolic name
        scope(ns).eval(expr
          @ns'secret
        )
        # %% # Using quaint name
        scope(ns).eval(expr
          @'full-time'
        )
        # %#
      }

      {## Dot-Notation
       # - To address an attribute off a left-hand-side value

At left-hand-side of the dot (.) is the expression evaluates to some value backed by an entity (usually an object), at right-hand-side of the dot (.) is the attribute name (alphanumeric, symbolic, or quaint, as descibed earlier)

       #} {;
        {## Dot-Notation #}
        export edh'dot'notation = bookmark()

        # %% # Using alphanumeric name
        ns.b
        # %% # Using symbolic name
        ns.@ns'secret
        # %% # Using quaint name
        ns.@'full-time'
        # %#

        {## Tentative Form
         # - Allowing absence of the target attribute

It is runtime error if the target attribute doesn't exist in the usual dot-notation, there is a tentative form using the infix (?) and (?@) operator to avoid such errors, but evaluates to `nil` instead.

Especially note that you don't want to directly assign the result of tentative attribute read to a local attribute for later use, because when absent, the resulted `nil` will actually trigger deletion semantics for your local attribute, thus later read will err out.

         #} {;
          {## Tentative Form #}
          export edh'tentative'attr'read = bookmark()

          # Not so different when the target attribute does exist
          # %% #
          ns?b
          # %% # Tentative at-notation
          ns?@ns'secret
          # %% # (?) operator working with a symbolic attribute name
          ns? @ns'secret
          # %% # Tentative quaint name
          ns?@'full-time'
          # %#

          # `nil` will be given out for non-exiting attributes
          # %% # Using an alphanumeric name
          ns?no'such'thing is nil
          # %% # Tentative at-notation
          symbol @never'assign'me
          ns?@never'assign'me is nil
          # %% # (?) operator working with a symbolic attribute name
          ns? @never'assign'me is nil
          # %% # Tentative quaint name
          ns?@'no-such-key' is nil
          # %#

        }


        {## Virtual Attributes
         # - Syntatic sugar appearing as dot-notation

There is special syntactic sugar for non-object values (usually not backed by entities) to be dot-notation addressable.

Special note that virtual attributes are readonly, i.e. can not be assigned as described in the following section.

         #} {;
          {## Virtual Attributes #}
          export edh'virtual'attrs = bookmark()

          # %% # Let's have dict value, remind its type is `DictType`
          d = { 'name': 'Yue', 'city': 'Chongqing', }
          type(d)
          # %% # Then obtain number of items in it as if there's a `size` attribute on it
          d.size
          # %% # This is possible because Ä does the translation under the hood, to something like:
          __DictType_size__(d)
          # %% # See the result is the same? Then checkout there really is such a method procedure:
          show$ __DictType_size__
          # %% # Also be noted that
          d.push( 'year', 2021, )
          # %% # is translated to
          __DictType_push__(d)( 'year', 2021, )
          # %% # Now you see the dict can be actually updated this way
          d
          # %# How convenient.

        }

      }

    }


    {## Assigning Attribute Value
     # - Creation/Update/Deletion of attributes
     #} {;
      {## Assigning Attribute Value #}
      export edh'attr'assign = bookmark()

      {## Into Current Scope

Using a standalone attribute name as the assignment target, will create or update the so named attribute of current scope.

       #} {;
        {## Into Current Scope #}
        export edh'scoped'attr'assign = bookmark()

        # Note that scoped attribute assignment can never write to outer scopes, as described in the lexical scoping rules later in this chapter
        ; () => edh'lexi'scoping # <- follow this bookmark to that section

        # %% # A `scope` wrapper object can be used to evaluate expressions with the wrapped object's backing entity as their current scope:
        scope(ns).eval(expr
          @ns'secret * 2 - c / b
        )
        # %# Expression values and scope wrappers are described later in this chapter
        ; () => edh'exprs'in'scopes # <- follow this bookmark to that section

        # %% # Using alphanumeric name
        scope(ns).eval(expr{; # use a block to enclose multiple statements
            e = 2.7 # creation
            b = 5
            e = nil # deletion
        })
        # %% # Using symbolic name
        scope(ns).eval(expr
          @ns'secret = 23323
        )
        # %% # Using quaint name
        scope(ns).eval(expr
          @'full-time' = true
        )
        # %#
      }


      {## Via Dot-Notation
       # - Assign to an attribute of some left-hand-side value

The left-hand-side expression of the assignment operator (=) can be of dot-notation, i.e. the assignment target is so specified as to be the designated attribute by the dot-notation. In this sense, such a dot-notation can be called an *Attribute Addressor*, in both cases it is used for atribute read and attribute assignment.

       #} {;
        {## Via Dot-Notation #}
        export edh'dot'notation'assign = bookmark()

        # %% # Using alphanumeric name
        ns.e = 2.7 # creation
        ns.b = 5 # update
        ns.e = nil # deletion
        # %% # Using symbolic name
        ns.@ns'secret = 23323
        # %% # Using quaint name
        ns.@'full-time' = true
        # %#
      }


      {## Tentative Form
       # - Do assign only when absent

Sometimes you just want to make sure a certain attribute is in scope, and would rather not overwrite what's already there.

Also at times you know an attribute is certain to be there, but the Ä source code around can not tell the IDE (or linter etc.) about its existence (or type for intellisense completion etc.), then you can write a pseudo assignment in the tentative form, just for informative purpose.

Note that tentative assignment doesn't work via dot-notation.

       #} {;
        {## Tentative Form #}
        export edh'tentative'assign = bookmark()

        # %% # It evaluates to the existing value if the target attribute already exists
        scope(ns).eval(expr
          b ?= 37
        )
        # %% # See it's not changed
        ns.b
        # %% # Will be created as a new attribute of current scope if does not exist already
        scope(ns).eval(expr
          e ?= 2.7
        )
        # %% # See it's not changed
        ns.e
        # %#

        # %% # Note that in cases a possibly absent attribute is read just occasionally, you may really want to write the code in this pattern:
        ns.e = nil # delete it for sure absence
        v = 9.8 * (ns?e or 2.7)
        # %#
      }


      {## Syntactic Sugar in Assignment
       # - Shorthands for updating assignments
       #} {;
        {## Syntactic Sugar in Assignment #}
        export edh'assign'sugar = bookmark()

        # %% # This expression:
        ns.b += 1
        # %% # is translated to
        ns.b = ns.b+1
        # %% # This expression:
        ns.b /= 3
        # %% # is translated to
        ns.b = ns.b/3
        # %# and et cetera
      }

    }

  }

}


{## Expressions and Statements
 # - A piece of Ä code is just a sequence of statements

Expression is a special (yet very important) type of statement, an expression yields a meaningful result when evaluated. Note that an expression may or may not have side-effects when evaluated.

Expressions can be combined together (e.g. by an infix, binary operator, among other forms), to form a new expression, so a complex expression can consist of many sub-expressions organized in a deeply nested hierarchy.

For a statement of some type other than _expression_, when evaluated, it doesn't yield a meaningful result, instead it produces desriable side-effects.

Ä is _strict_ in evaluation of statements, an Ä interpreter program evaluates a statement immediately upon one is encountered. The contrary is _lazy_ evaluation, in which sense the actually evaluation can be postponed until absolutely necessary.

 #} {; import * './refs'
  {## Expressions and Statements #}
  export edh'exprs'stmts = bookmark()

  {## Typical Examples
   # - Commonplace expressions and statements
   #} {;
    {## Typical Examples #}
    export edh'expr'stmt'examples = bookmark()

    # %% # `let` is a typical statement, its side-effects are assignments to various attributes of the current scope
    let (a, b, c,) = (3, 2, 7,)
    # %# See that there's NO result by running this cell?

    # %% # Arithmetic expressions are very typical, usually having literal expressions and attribute expressions joined with binary operators, e.g.:
    a + b * c - 5
    # %# See the result?
    # Note `*` is the multiplication operator (while in everywhere else other than a programming language, it is `Ã—`)
  }


  {## Arguments Packing & Unpacking
   # - Positional & named formal arguments to be packed and unpacked

Ä has a unique immutable data structure - ArgsPack, usually abbreviated as apk. An apk is created by a pair of parenthese quoting a list of positonal or named argument expressions.

Arguments are packed into an apk in the following cases:
 * In execution of a `let` statement, for right-hand-side to the `=` operator
 * In evaluation of a call expression, i.e. an expression of callee followed by the postfix `()` operator
 * In evaluation of an indexing expression, i.e. an expression of container followed by the postfix `[]` operator
 * In evaluation of a standalone apk literal

   #} {;
    {## Arguments Packing & Unpacking #}
    export edh'args'un'packing = bookmark()

    # %% # Positional-only apk is roughly equivalent to what's called "tuple" in other programming languages having it (e.g. Python), both semantically and syntatically.
    type( (1,2,3,) )
    # %% # A single argument pack needs to be disambiguated with one or more extra commas (leading, trailing or unusually - both)
    type( (,1,) )
    # %% # While only trailing commas are idiomatic in Ä
    ; (1,)
    # %% # Or it'll be parsed as parenthese-quoted expression for precedence override purpose
    type( (1) )
    # %#

    # %% # Named arguments can be put anywhere in the list, but an apk value will be canonicalized to have all positional arguments separated from named arguments, with their respective order of appearance reserved:
    apk = ( name= 'Compl', 1, 2, year= 2021, )
    # %#

    # %% # Asterisks can be used to unpack apk/list/dict into current target apk
    l = [ 3, 5, ]
    d = { 'name': 'Yue', 'city': 'Chongqing', }
    ; ( 7, ***apk, **d, *l, year= 2030, city= 'Shanghai', *apk, )
    # %# As you can see:
    #
    #   Unpacking and direct argument specifications can be arbitrarily mixed
    #
    #   *** triple asterisks unpack both positional & named arguments
    #    ** double asterisks unpack only named arguments
    #     * single asterisks unpack only positional arguments
    #
    #   The order of appearance are always reserved
    #
    #   A repeated named argument replaces the value, but doesn't change where it sppears

  }


  {## Arguments Receiving
   # - Receive arguments from an apk into current scope

Arguments are received from an ArgsPack in the following cases:
 * In execution of a `let` statement, according to specification at left-hand-side of the `=` operator
 * In execution of a for-loop expression, according to the loop argument specification
 * When a procedure is called, according to the argument specification in the definition of the procedure

   #} {;
    {## Arguments Receiving #}
    export edh'args'receiving = bookmark()

    # %% #
    apk = ( name= 'Compl', 1, 2, 3, year= 2021, city= 'Choingqing' )
    # Note a standalone apk is used at right-hand-side of the `=` operator in the let statement, it of course can be a literal apk instead
    let ( name as nnn, x, *xs, optional'x= None, **kws, ) = apk
    # %%
    nnn
    # %%
    x
    # %%
    xs
    # %%
    optional'x
    # %%
    kws
    # %#

    # As you can see in above, single asterisks can be used to receive rest positional arguments as a specified attribute, while double asterisks can be used to receive rest keyword arguments

    # %% # Triple asterisks can be used to receive rest positional + keyword arguments as a new apk attribute with the specified name
    let ( x, ***apk', ) = apk
    # %%
    apk'
    # %%
    x
    # %#

  }


  {## Operators
   # - Fully customizable infix operators with a few intrinsic prefix and postfix operators

There are a few prefix and postfix operators intrinsic to the Ä language, while all infix operators are customizable operator procedures. A set of infix operator procedures come with the default batteries bundled with the bare interpreter package, more Ä packages would possibly add their own operator implementations and/or overrides, along with other artifacts such as classes, methods, symbols etc.

   #} {;
    {## Operators #}
    export edh'operators = bookmark()


    {## Intrinsic Prefix Operators
     # - All unary

All prefix operators are intrinsic to the language, they can only be right-associative, but their precedences decide how nested operators parse, thus the semantics.

Especially note that a semicolon (or comma according to the context) may be usually needed immediately before a prefix operator which can also be an infix operator (namely `+`, `-`, and `|`), for disambiguation purpose.

     #} {;
      {## Intrinsic Prefix Operators #}
      export edh'prefix'ops = bookmark()


      {## The prefix plus (+) operator
       # - With precedence 9

It is technically no-op, but is idiomatic to be written out explicitly in certain cases, e.g. as in `+inf` when contrasted with negative infinity `-inf`.

       #} {; export edh'prefix'plus'op = bookmark()
        # %% # It's technically no difference with or without a prefix +
        ; +inf is inf
        # %# See above is true.
      }


      {## The prefix minus (-) operator
       # - With precedence 9

It is used to negate a decimal value, and will err out for other type of values at runtime.

       #} {; export edh'prefix'minus'op = bookmark()
        # %%
        ; -3.5
        # %%
        ; - ( 5 / -11 )
        # %%
        ; -inf
        # %#
      }


      {## The prefix (not) operator
       # - With precedence 4

It is used to negate a boolean value, and will err out for other type of values at runtime.

       #} {; export edh'prefix'not'op = bookmark()
        # %%
        not true
        # %%
        not 3 > 2
        # %%
        not 3*7 == 22
        # %#
      }


      {## The prefix guard (|) operator
       # - With precedence 1

It is used to explicitly mandate a conditional match for a branch, regardless of the contextual matching target value.

       #} {; export edh'prefix'guard'op = bookmark()
        # %% #
        ; | 3*7 is 21 -> "That's so true."
        # %% #
        ; | 3 < 2 -> "No way this get shown!"
        # %# Branches are described later in this chapter
        ; () => edh'branching # <- follow this bookmark to that section
      }


      {## The prefix (void) operator
       # - With precedence -10

It is used to technically cease the result (to be always replaced with `nil`) of its operand expression, as well as to formally declare the no-result semantics as an expression.

       #} {; export edh'prefix'void'op = bookmark()
        # %% # It is idiomatic for a procedure to have a `void` body, when no meaningful result is meant to be returned. Compare this (deprecated) implementation:
        method do'sth() {
          that.some'method'with'meaningful'result()
          return nil
        }
        # %% # to the idiomatic implementation:
        method do'sth() void {
          that.some'method'with'meaningful'result()
        }
        # %# See the later is both more concise and more pragmatic.
      }


      {## The prefix (ai) operator
       # - With precedence -10

It is used to perform its operand expression (usually consists of multiple steps) to be evaluated in a single STM transaction.

Note an STM transaction will retry automatically, and prone to no-progressing under heavy concurrent contention. And IO actions are not permitted during an STM transaction. Carefully reasoning is reqired to use this operator properly.

       #} {; export edh'prefix'ai'op = bookmark()
        # %% # A correct (but not performant) implementation of simple concurrent counter can be:
        data ConcCounter(cnt= 0) {
          method inc() ai this.cnt += 1
          method dec() ai this.cnt -= 1
        }
        # %# Data classes are described later in this chapter
        ; () => edh'data'classes # <- follow this bookmark to that section
      }


      {## The prefix (default) operator
       # - With precedence -10

It is used to create a default expression with its operand expression.

       #} {; export edh'prefix'default'op = bookmark()
        # Defaulting semantics is an advanced topic explained in another chapter:
        ; () => import (
          edh'defaulting, # <- follow this bookmark to the relevant section there
          **_
        ) '../advanced/dflt'
      }


      {## The prefix (new) operator
       # - With precedence -10

It is technically no-op, and used for source-level compatibility with other scripting languages like JavaScript, where scripting based RPC (Remote Procedure Call) would take place.

       #} {; export edh'prefix'new'op = bookmark()
        # Ä can be used to validate / syntax-highlight foreign code snippets those compliant to a common subset of scripting syntax, among JavaScript / Python etc.
        false and that.jsRPC(js!expr{
            console.log( 'The time now is ' + new Date());
        })
        # %# Note that expression values are described later in this chapter
        ; () => edh'expr'expr # <- follow this bookmark to that section
      }

    }


    {## Intrinsic Postfix Operators
     # - Currently just indexing and calling

All postfix operators are intrinsic to the language, they can only be left-associative.

There are currently only two postfix operators, namely indexing `[]` and calling `()`. They both have the highest possible precedence.

     #} {;
      {## Intrinsic Postfix Operators #}
      export edh'postfix'ops = bookmark


      {## Indexing
       # - For element extraction & assignment

       #} {;
        {## Indexing #}
        export edh'indexing = bookmark()

        # %% # You can obtain positional arguments from an ArgsPack with positive integer index
        apk = (3, 2, 5,)
        apk[ 1 ] # Ä index is zero based (i.e. offset semantics as in C family languages)
        # %% # You can obtain values from a dict with the key as index
        d = {
          'name': 'Compl',
          'year': 2021,
        }
        d[ 'name']
        # %% # A dict can be modified via indexed assignment
        d[ 'year' ] = 2030
        d
        # %#
      }


      {## Calling
       # - Making procedure calls

       #} {;
        {## Calling #}
        export edh'calling = bookmark()

        # %% # You've just seen plenty usage of it
        console.print(
          'Calling a procedure is actually the application of the postfix () operator.'
        )
        # %#
      }

    }


    {## Customizable Infix Operators
     # - In spirit of Haskell / C++

All infix operators are defined as operator procedures, many of them are intrinsic (host) procedures, while others being Ä procedures. They all have a custom precedence & associativity/fixity respectively, and can be overridden by attribute shadowing at particular scopes.

Custom operators must be named with one or more valid operator characters, which is one of "=~!@#$%^&|:<>?*+-/" plus various Unicode characters in the following general categories:

  * MathSymbol
  * CurrencySymbol
  * ModifierSymbol
  * OtherSymbol
  * DashPunctuation
  * OtherPunctuation

Especially note that dot (.) and square brackets ([]) are not valid operator characters, they work with magic methods instead.

However, there are a few hard-coded exceptions, namely the following operators:

  * is
  * is not
  * and
  * or

     #} {;
      {## Customizable Infix Operators #}
      export edh'infix'ops = bookmark()


      # %%
      namespace custom'infix'ops () {

        {## Declare Fresh-New Operators
         # - With precedence & fixity

You must specify the precedence as well as the desired fixity (use one of the keywords: `infixl` / `infixr` / `infix`) when defining fresh new operators

         #} {;

          # Implement the operator with argument list and procedure body
          infixl 7 (Ã—) (lhv, rhv) lhv * rhv

          # Use an existing operator as the operator implementation
          infixl 7 (Ã·) () (/)

        }

        # With a conformant argument list, this method procedure can be re-declared as an operator
        method stylish'and'concat(lhv, rhv) lhv ++ ' & ' ++ rhv

        {## Override Existing Operators
         # - With a new implementation, shadowing ones from outer scopes

You can use just the `operator` keyword to override an existing operator

         #} {;

          # Use an existing procedure as the operator implementation
          operator (and) () stylish'and'concat

        }

      }

      dir$ custom'infix'ops
      # %#

      # %% # Expressions can be evaluated in scope of a namespace via a scope wrapper
      scope(custom'infix'ops).eval(expr
        3 Ã— 7 Ã· -56
      )
      # %%
      scope(custom'infix'ops).eval(expr
        'You' and 'me'
      )
      # %# Expression values and scope wrappers are described later in this chapter
      ; () => edh'exprs'in'scopes # <- follow this bookmark to that section


      # %% # Operator procedures can be referenced with its symbol quoted in a pair of parenthese
      show$ (*)
      # %%
      show$ (is not)
      # %%
      show$ (or)
      # %% #
      scope(custom'infix'ops).eval(expr
        show$ (Ã—)
      )
      # Especially note that, dot-notation won't work for operators, it is designed to work with magic methods instead. The crucial fact to know is: the parenthese is part of the name used to identify a magic method, but never so for names identifying operators.
      # %% # This is an error:
      custom'infix'ops.(Ã—)
      # %# Magic methods are described later in this chapter
      ; () => edh'magic'mths # <- follow this bookmark to that section

      # Checkout the meta definition for operators come with default batteries
      import * 'batteries/meta/ops' into Nothing
    }

  }


  {## More Expressions and Statements
   # - There are more types of expressions and statements in Ä

For example:
 * Dict Expresssion
 * List Expression
 * Namespace Expression
 * Class Expression
 * Block Expression
 * Yield Expression
 * Index Expression
 * Call Expression
 * Default Expression
 * Go Statement
 * Defer Statement
 * Perceive Statement
 * Break Statement
 * Continue Statement
 * Fallthrough Statement
 * Throw Statement
 * Rethrow Statement
 * Return Statement

   #} {;
    {## More Expressions and Statements #}
    export more'exprs'stmts = bookmark()

    edh'lang'refs'details # <- follow this to Ä langauge reference for a detailed list of statements (including expressions) Ä code can have
  }

}


{## Values, and Really Special Ones
 # - Everything is a value in Ä

Some values are both syntatically and semantically special, with respect to topics of Terminology, Equality, and Nothingness.

 #} {; import * '../advanced/vals' # <- details of Ä Value System
  {## Values, and Really Special Ones #}
  export edh'values'with'speciality = bookmark()

  # How and why everything is a value
  everything'is'a'value # <- follow this bookmark to that section in Ä Value System


  {## Named Values / Term Definitions
   # - The named is the mother of ten thousand things

A value in Ä can have an alphanumeric name assigned to it, forming a named value, or so called term definition.

Note the named version of a value may or may not "equal" to the original version of the value, with respect to which definition of "equality" is used. Multiple criteria of "equality" are described in later sections of this chapter.

   #} {;

    # %% # In Ä code, a named value is defined by evaluation of the (:=) operator
    ð›‘ := 3.14
    # %# The (:=) operator has a side-effect to define an attribute into current scope, using the term name as attribute name, with the named version of the value.
    # Note this side-effect is ceased in a pure context, which is described later in this chapter
    ; () => edh'pure'ctx # <- follow this bookmark to that section

    # %% # A term's name is its usual representation
    repr$ ð›‘

    # %% # After some manipulation (e.g. arithmetics), it may no longer be a term, even the ultimate value are identical to the original value
    repr$ ð›‘ * 1 # Now just an immutable value of DecimalType

    # %% # Type of a term comes from its original value
    type( ð›‘ )

    # %% # Ä knows it being a term, and can show that accordingly
    show( ð›‘ )

    # %% # Otherwise it's can be used just like the original value
    r = 1.58
    C = 2 * ð›‘ * r
    # %#
  }


  {## Equalities
   # - Some values can be more "equal" than others
   #} {;
    {## Equalities #}
    export edh'equalities = bookmark()


    {## Identity Equality
     # - All values are assumed to have identities

Ä assumes the uniqueness of all values to some degree that every value can be tested for a certain conclusion of whether it poses the same identity of another value, thus identity equality can always be tested for any two given values.

     #} {;
      {## Identity Equality #}
      export edh'id'eq = bookmark()

      # %% # Identity equality is tested with the (is) operator:
      true is true
      # %% # The negated (is not) operator gives proper English feeling:
      true is not false
      # %% # while being equivalent to:
      not ( true is false )
      # %#


      # Immutable values can be uniquely identified by its unchangable value, regardless of its original source.
      # %% # E.g.
      3 * 7 is 21
      # %% # The complex ArgsPackType is immutable after all, though the order of arguments is siganificant in identity test. Especially note named arguments are ordered by original occurrence, not by sort order of the names or any otherwise.
      ; ( a= 2, 3, 5, b= 7, ) is ( 3, a= 2, b= 7, 5, )
      # %% # Difference in arg order, either that of positional args or named args, change an apk's identity
      ; ( a= 2, 3, 5, b= 7, ) is ( 3, b= 7, 5, a= 2, )
      # %#


      # Mutable values need other means of identity, that usually can be the (imagined) location of the block in memory, to where overwriting goes when the value is to be changed. The reference semantics is a useful intuition for this, that two reference values are identical when they point to the same memory location, thus changes through one of the reference will be visible to the other reference.
      # %% % Two separate lists can never be identical
      ; [ 3, 2, ] is [ 3, 2, ]
      # %% # Only references copied from existing ones can
      l = [ 3, 2, ]
      l' = l
      l is l'
      # %#

      # Dicts, objects etc. are in similar cases wrt identity equality.


      # A value serving as an immutable container, such as an apk or a pair, may contain mutable values as its items, the identity equality cascades into those items intuitively.
    }


    {## Instant Equality
     # - The common sense of "equality"

The common sense of "equality" assumes snapshot semantics when comparing two mutable values, i.e. the equality test would happen as if time has stopped flowing, so the stored data of such values can be compared at the instant of time when the comparison is requested.

     #} {;
      {## Instant Equality #}
      export edh'instant'eq = bookmark()

      # %% # Instant equality is tested with the (==) operator:
      [ 3, 2, ] == [ 3, 2, ]
      # %# See they are considered equal now?

      # %% # Objects can override instant equality test via its `__eq__()` magic method implementation
      class D {
        method __init__(x as this.x, y as this.y) pass
        method __eq__(other) case other of {
          { D(x= otherX, y= otherY) } -> { # this uses a match pattern doing instance check with field extraction at the same time
            this.x == otherX and this.y == otherY
          }
          _ -> false
        }
      }
      # %% # So these two distint objects can be considered instantly equal
      D(3, 2) == D(3, 2)
      # %% # While they by no means can be identically equal
      D(3, 2) is D(3, 2)
      # %% # The data class syntax is sorta syntactic sugar with such purpose in mind:
      data D'(x, y) pass
      # %% # The `D'` class defined this way automatically implements a `__eq__()` method, so:
      D'(3, 2) == D'(3, 2)
      # %# Actually there're more with a data class, e.g. a automatic `__repr__()` implementation.

      # Note that identity equality always implies instant equality, but not vice versa.
    }


    {## Namewise Equality
     # - Equality wrt how values are named

Some instantly equal values can be differently named, in the sense of original value, they are considered instantly equal too.

     #} {;
      {## Namewise Equality #}
      export edh'namely'eq = bookmark()

      # %% # Take this example:
      PhoneNo := 35925
      AccountNo := 35925
      # %% # They are not identical because named differently:
      AccountNo is PhoneNo
      # %% # But surprisingly:
      AccountNo == PhoneNo
      # %# See they are considered instantly equal? That's a pitty rendering the (==) operator less meaningful in certain cases.

      # %% # Fortunatelly for value matching branches, the name of values would make differences, so they are said to be namely equal, iif they have the same name, and share an instantly equal original value.
      case AccountNo of {
        35925 -> "No way, original version of a value won't match any named version!"
        PhoneNo -> "No way, the value names don't match!"
        ; (AccountNo := 35925) -> "Yeah, this should work!"
      }
      # %# Branches are described later in this chapter
      ; () => edh'branching # <- follow this bookmark to that section

      # TODO add named mutable values as example, to demonstrate the necessarity of namely equal semantics.

    }

  }


  {## Null Test
   # - The observable nothingness

All values are assumed to be able to tell if it is truthful, or on the contrary, falsy, that eternally for immutable values, and instantly for mutable values. There are a few control flow mechanisms relying on this ability to carry out conditional executions, e.g.:

 * if <conditional> then <consequence> else <alternative>
 * while <conditional> <keep-doing>
 * <prefered-result> or <alternative-replacement>
 * <prerequisite> and <proceeds>

`null()` is used to explicitly perform _null_ tests and give out true/false accordingly, while the control flows above would perform _null_ tests implicitly.

   #} {;
    {## Null Test #}
    export edh'null'test = bookmark()

    # %% #
    null$ 3
    # %%
    null$ 0
    # %%
    null$ 'Hello'
    # %%
    null$ ''
    # %%
    null$ true
    # %%
    null$ false
    # %#

    # %% #
    data Blocker(letgo= false) {
      method __null__() not this.letgo
    }
    blocker = Blocker(true)
    # %# Data classes are described later in this chapter
    ; () => edh'data'classes # <- follow this bookmark to that section

    # %% # Repeat this cell after toggled blocker's status
    if blocker
    then "You've been blocked!"
    else "Proceed!"

    # %% # Toggle the blocked state
    blocker.letgo = not blocker.letgo
    # %#

  }


  {## Special Values
   # - Some special values
   #} {;
    {## Special Values #}
    export edh'special'values = bookmark()

    # %% # `nil` is the ultimate nothingness
    nil
    # %% # It deletes attributes when assigned as the value
    a = nil # to delete attribute named `a` from current scope

    # %% # `None` is just `nil` named "None"
    show$ None
    # %% # `Nothing` is just `nil` named "Nothing"
    show$ Nothing

    # %% # `true` is the boolean value indicating truthful result
    show$ true
    # %% # `false` is the boolean value indicating falsy result
    show$ false

    # %% # `nan` means Not-A-Number, but of DecimalType, which is a numeric type
    show$ nan
    # %% # `nan` is technically the result of 0 divided by 0
    0/0 is nan
    # %% # Except for identity equality, a nan value never equals to any value, including itself
    nan == nan
    # %# See nan is unequal to itself?

    # %% # `inf` is infinity
    show$ inf
    # %% # Negate it by the prefix minus (-) operator to get negative infinity
    show$ -inf
    # %% # Divided by 0, a finite number will produce infinitity
    ; -5 / 0
    # %#

    # %% # `NA` means Not/Applicable, indicating a result defaulting to `nil`, which technically can't be defaulted, so will be propagated until caught as an error condition.
    show$ NA
    # %# Applicability & defaulting semantics are described in another chapter
    ; () => {; import * '../advanced/appl' # <- navigate to there for elaboration
      edh'na'semantics # <- follow this bookmark to the specific section there
    }

    # %% # `LT` means less-than, indicating the result of comparision
    show$ LT
    # %% # `GT` means greater-than, indicating the result of comparision
    show$ GT
    # %% # `EQ` means equal, indicating the result of comparision
    show$ EQ
    # %#

    # %% # An event sink is a broadcasting channel, a new one will be created each time the `sink` literal is evaluated
    assassinate'signal = sink
    show$ assassinate'signal
    # %% # Arbitrary values (each as an event) can be sent into an event sink, i.e. to publish one event at a time, using the (<-) operator:
    assassinate'signal <- 'stab'
    # %% # But the events will be just discarded (having no effect) by default, though anyone can iterate events published into it at anytime, we spawn a new thread to do the iteration:
    go for act from assassinate'signal do console.warn<| "I'm going to " ++ act ++ " you!"
    # %# See the warning from background? An event sink is by default lingering, meaning the last event into it will be saved and kept being observed until the next event replaces it.
    # %% # Let's publish another event there:
    assassinate'signal <- 'shoot'
    # %# Remind that the publishing can be repeated, try run the "stab" cell again.

    # Events can be *perceive*d by any thread, the perceiver body is executed with the published event as matching target
    # %% #
    perceive assassinate'signal { act } -> {
      console.info<| "I'm assassinated via " ++ act
    }
    # %# Then run the publishing cells above again, to see more messages logged.
    # Branches with pattern/value matching are described later in this chapter
    ; () => edh'branching # <- follow this bookmark to that section

    # If the perceiver evaluates to value of a `break` statement, that thread will be terminated.

    # %{ # Upon termination of a thread, some actions can be *defer*ed to execute:
    defer {
      # %%
      console.print$ "Here's my last words ..."
      secRemains = 10
      for _ from console.everySeconds(1) do {
        case secRemains -= 1 of {
          7 -> console.print( "\rPlease let me die a good death." )
          5 -> console.print( "\rThat's all I want." )
          4 -> console.print( "\rFarewell!" )
          0 -> {
            console.print( "\27[A")
            break
          }
          _ -> console.print( '\r...' ++ secRemains, eol= '\r', )
        }
      }
      # %#
    }
    # %}

    # Be prepared to loss your Ä terminal session, for the main thread will be terminated, thus the program will halt.
    # %% # The perceiver performs pattern/value matching, here we implement it so only shooting can make the kill, you know what to do next.
    perceive assassinate'signal.subseq 'shoot' -> {
      console.fatal<| "I'm hit!"
      break # this being the final result, would terminate the thread installed this perceiver
    }
    # %# Notice the `.subseq` used above, it obtains a non-lingering version of the event sink, so the perceiver against it will only respond to subsequent events, and so you have to run one of the publishing cells above to trigger the assassination. Good luck!

  }

}


{## Control Flows
 # - Handling varity of input

A computer makes no sense if every distinct input has to be processed by another unique program. To be actually useful, a computer (at times, even a single program on a computer), needs to accept input data of sufficient varity. So some level of abstraction has to be there, this calls for polymorphism.

That means a program would need to go different execution branches wrt the input data, and in practices, such conditional branchings can be seen allover the source code of computer programs. In this section, you'll see what mechanisms for this purpose are supported by Ä.

 #} {;
  {## Control Flows #}
  export edh'ctrl'flows = bookmark()


  {## if-then-else Boolean Branching
   # - Conditionally branching

"if <conditional> then <consequence> else <alternative>" as a whole is an expression, meaning it's supposed to give out some meaningful result value when evaluated. The `else` part can be omitted, then the whole expression evaluates to `nil` if the condition doesn't hold.

   #} {;
    {## if-then-else Boolean Branching #}
    export edh'if'then'else = bookmark()

    # %% # Idiomatic short forms
    if 3 < 2
    then "No way this get shown!"
    else "Of course!"
    # %#

    # %% # Idiomatic long forms
    if 3*7 is 21 then {
      console.print$ "That's so true!"
    } else {
      console.print$ "No way arithmetics fail!"
    }
    # %#

    # %% # Without an `else` part:
    nil is (
      if 3*7 > 22 then "You'd never see this!"
    )
    # %#

  }


  {## Blocks, Matching Branches, Fallthrough
   # - Forming a hierarchy of control elements

A block is any number of statements enclosed by a pair of curly braces, it is an expression, and evaluates to the result value of last statement executed in it, in case that statement is an expression statement, or just `nil` will be the execution result.

Branch expressions defined by the arrow (->) operator can appear in a block, to jump out of the block without evaluation of subsequent statements following it, iif the left-hand-side expression of the branch is concluded as a match, in which case the right-hand-side expression of the branch becomes the last statement of the block execution, thus giving out the block's evaluation result value as it is evaluated. There is a special case though, if such a right-hand-side expression evaluates to the value of `fallthrough` statement, subsequent statements following the branch will continue to be executed as if the branch has not been a match. While non-match branches won't have their right-hand-side expression evaluated/executed at all.

The left-hand-side expression is concluded to be a match or not in 3 different ways, with different syntax to manifest the desired handling:

 * A valid pattern matching the contextual matching target value
 * A guard condition with truethful or falsy result
 * A value as evaluated, whether it namely-equals to the contextual matching target value

Blocks can be nested, as well as for blocks to be body parts of other control flow constructs, arbitrary hierarchy of control flow structures can be composited.

   #} {;
    {## Blocks, Matching Branches, Fallthrough #}
    export edh'branching = bookmark()

    {## case-of Targeting
     # - Setting the target to match

The case-of expression computes a value from the specified target expression, then with the result value being the contextual matching target, evaluate the specified block of expressions (or a single expression in rare cases), as to become the result of the whole case-of expression. Note that after the case-of expression is evaluated, the contextual matching target is restored, for evaluation of subsequent statements following the case-of expression.

     #} {;
      {## case-of Targeting #}
      export edh'case'of = bookmark()

      # %% #
      case 3*7 of {
        21 -> "Pretty that!"
        _ -> "Is arithmetics dead?"
      }
      # %#

      {## `case true of { }`
       # - Freeform conditional branches

Matching against `true` has a desirable property that logical conditional expressions can be used right away at left-hand-side of the branches.

Technically, `true` is the initial matching target, unless overridden by an outer case-of. But it is idiomatic to explicitly quote around freeform branches, with a `case true of { }` block, because that's foolproof to later copy/cut & paste the code segment to somewhere within some other case-of block.

       #} {;
        {## `case true of { }` #}
        export edh'freeform'cond'branches = bookmark()

        # %% #
        case true of {
          3 < 2 -> 'No way!'
          console.logLevel <= console.debug -> 'We are debugging!'
          _ -> "Nop, all good."
        }
        # %#

      }

    }


    {## Pattern Matching
     # - With a pattern expression at left-hand-side of a branch

Pattern expressions all have an outer-most pair of curly braces, though some may have more inner layers of curly braces.

     #} {;
      {## Pattern Matching #}
      export edh'pattern'matching = bookmark()

      # There is an advanced topic describing various matching patterns in another chapter
      ; () => {; import * '../advanced/patterns'
        edh'matching'patterns # <- follow this bookmark to the section there
      }

      # Let's briefly show some useful examples here

      {## Wild Match Pattern
       # - Always match
       #} {;
        {## Wild Match Pattern #}
        export edh'wild'pattern = bookmark()

        # %% #
        case 3*7 of {
          { n } | n > inf -> 'No way! Bigger than infinity??'
          _ -> 'This branch always match!'
        }
        # %% # Technically there is no need of such a pattern:
        case 3*7 of {
          { n } | n > inf -> 'No way! Bigger than infinity??'
          "It doesn't have to be a branch anyway!"
        }
        # %# But it is just idiomatic to write a last branch like that.
        # It feels familiar to Haskell btw.
      }

      {## Wild Capture Pattern
       # - Capture a non-nil matching target as attribute
       #} {;
        {## Wild Capture Pattern #}
        export edh'wild'cap'pattern = bookmark()

        # %% # Suppose there's this procedure possibly returning nil result
        method evil'amp(n) case true of {
          n < 5 -> nil
          n * 10
        }
        # %# Note it is really bad to have nil as a possible result among other return values, don't do this in realworld!

        # %% # Prepare a input that would result in nil
        n = 3
        # %% # Or for non-nil result
        n = 7
        # %#

        # %% # It is idiomatic to work with such a computation like this:
        case evil'amp(n) of { result }
        -> 'Amplified result is: ' ++ result
        # %% # Instead of this safe but less optimal algorithm:
        if evil'amp(n) is not nil
        then 'Amplified result is: ' ++ evil'amp(n)
        # %# The major problem with above cell is the computation will be performed twice when not nil, besides a bit more imperative (contrasting to declarative) feeling.

        # %% # And this is a plain wrong solution:
        result = evil'amp(n)
        'Amplified result is: ' ++ result
        # %# Can you figure out why? Set `n = 3` and try it, you'll see.

        # Godforbid it for any procedure implemented like the `evil'amp()` above, but there are way more complex expressions to have nil mixed into normal non-nil results, so the wild capture pattern is your best friend at all times.
      }


      {## Any-Of Pattern
       # - Namely equal to any of the listed value
       #} {;
        {## Any-Of Pattern #}
        export edh'any'of'pattern = bookmark()

        # %% #
        c = 'b'
        # %% #
        c = 'f'

        # %% #
        case c of {
          { [ 'a', 'b', 'c', ] } -> 'Early coming.'
          _ -> 'Late coming.'
        }
        # %#
      }


      {## Tuple Pattern
       # - Expect a fixed number of positional arguments
       #} {;
        {## Tuple Pattern #}
        export edh'tuple'pattern = bookmark()

        # %% #
        p = ( 3, 2, 5, )
        # %% #
        p = ( 3, 7, )

        # %% #
        case p of {
          { (x,y,z,) } -> "3D coordiante: x= " ++ x ++ " y= " ++ y ++ " z= " ++ z
          { (x,y,) } -> "2D coordinate: x= " ++ x ++ " y= " ++ y
        }
        # %#
      }


      {## Data Object Pattern
       # - Extract fields from data objects
       #} {;
        {## Data Object Pattern #}
        export edh'data'obj'pattern = bookmark()

        # %% #
        data Point(x, y) pass
        data Circle( r, c= Point(0,0), ) pass
        data Rectangle(w, h, o= Point(0,0), ) pass
        # %% #
        shape = Circle(5)
        # %% #
        shape = Rectangle( 7, 2, Point(3, 1), )
        # %#

        # %% #
        case shape of {
          { Circle( r, c = center, )}
          -> "Circle at " ++ center ++ " w/ radius " ++ r

          { Rectangle( w= width, h= height, ) = rect }
          -> "Rectangle covering area " ++ width*height ++ " - " ++ rect
        }
        # %#
      }


      {## String Cut Pattern
       # - Extract prefix and/or suffix from string with matched counter part
       #} {;
        {## String Cut Pattern #}
        export edh'str'cut'pattern = bookmark()

        # %% #
        url = "https://www.haskell.org/platform/mac.html"
        # %% #
        case url of { scheme @< '://' >@ host'and'path }
        -> "The page is over " ++ scheme
        # %% #
        case host'and'path of { authority @< '/' >@ path }
        -> "The host is " ++ authority ++ ", the path is " ++ path
        # %% #
        case path of { 'platform/' >@ page'name }
        -> case page'name of { platform @< '.html' }
        -> "The platform is " ++ platform
        # %#

        # Actually, there is a URI class comes with the default batteries
        # %%#
        case url of { URI(scheme, authority, path,) }
        -> "Over " ++ scheme ++ ", the site " ++ authority ++ " provides " ++ path
        # %#

        URI.__match__ # <- goto its definition for a comprehensive example
      }

    }


    {## Guard Condition Matching
     # - With a guarded expression at left-hand-side of a branch

Guard condition is defined with the prefix guard (|) operator.

Note it is idiomatic to always place a semiclone before the (|), to disambiguate it from an infix (|) operator, even it has no preceeding statement, it may be moved or copied to after some statement in the future.

     #} {;
      {## Guard Condition Matching #}
      export edh'guard'cond'matching = bookmark()

      # %% #
      n = 6
      # %% #
      n = 7
      # %% #
      n = 8

      # %% #
      case n - 5 of {
        3 -> "It's the right number!"
        ; | n % 2 is 1 -> "Got a wrong odd number!"
        _ -> "Got a wrong even number!"
      }
      # %#
    }


    {## Value Matching
     # - With a vanilla expression at left-hand-side of a branch

Other forms of expression at left-hand-side of a branch are all considered a value expression, the result value evaluated from such a LHS expression is compared to the contextual matching target value with namewise equality semantics.

     #} {;
      {## Value Matching #}
      export edh'value'matching = bookmark()

      # %% #
      case 3*7 of 15+6 -> "Coincidence? No."
      # %#

      # %% #
      PhoneNo := 35925
      AccountNo := 35925

      # %% #
      the'no = AccountNo
      # %% #
      the'no = PhoneNo
      # %#

      # %% #
      case the'no of {
        35925 -> "No, this is unnamed."
        PhoneNo -> "Dial phone " ++ the'no
        AccountNo -> "Ban account " ++ the'no
      }
      # %#
    }


    {## Falling Through
     # - Cancel the conclusion of match

Put a `fallthrough` as the last statement of a branch, this branch will be assumed un-matched, though its right-hand-side expression has been executed.

     #} {;
      {## Falling Through #}
      export edh'fallthrough = bookmark()

      # %% %
      case 3*7 of {
        21 -> {
          console.print$ 'We know that it is, but more can be done with it.'
          fallthrough
        }
        _ -> {
          "This can match."
        }
      }
      # %#
    }


    {## Scoped Blocks
     # - Creating nested block scopes

A usual block doesn't create a new scope, that means, statements inside it will put artifacts into the "current scope" shared with statements outside of the block, as side-effects they'd produce. This behavior is not desirable at times, when some intermediate result need to be stored as attributes during some computation, but better discarded afterwards, or they'd be felt as polution to the shared scope.

A scoped block can help in such situations, it is just a drop-in replacement for a usual block, except with a dedicated scope created, to be used as the "current scope" for the statements inside it to be executed.

     #} {;
      {## Scoped Blocks #}
      export edh'scoped'blocks = bookmark()

      # %% # A scoped block is statements enclosed in a pair of `@` augmented curly braces, i.e. `{@` and `@}`
      x = 'outer-value'
      {@
        # Within a scoped block, attributes are defined locally, since the "current scope" becomes a separate one (backed by a separate entity) than the outer scope. And an attribute present in an inner scope shadows all ones with the same name from outer scopes.
        x = 'inner-value'
        console.print$ 'Inside, x is: ' ++ x
      @}
      console.print$ 'Outside, x is: ' ++ x
      # %# Out of a scoped block, all artifacts ever defined inside are discarded

      # Note the shadowing of samely named attributes from outer scopes is an anti-pattern, the code above is for demonstration purpose only and not idiomatic. Scoped blocks should be just used to discard its scope attributes upon leaving, it's discouraged to override attributes available from outer scopes like that.
    }

  }


  {## for-from-do Loop
   # - Looping against some nondeterministic source
   #} {;
    {## for-from-do Loop #}
    export edh'for'loop = bookmark()

    {## Calling a Generator
     # - For loop is the only way to call a generator procedure
     #} {;
      {## Calling a Generator #}
      export edh'call'generator = bookmark()

      # Generator procedure is further described later in this chapter
      ; () => edh'generator'procs # <- follow this bookmark to that section


      # Here is a simple example, you're supposed to observe:
      #  * The generator procedure can take arbitrary arguments
      #  * `yield` is used from within the generator procedure to give out one item at a time, the item can go as a freeform ArgsPack. Note that the apk is packed with arguments packing semantics, which is described at:
      ; () => edh'args'un'packing # <- follow this bookmark to that section
      #  * Loop arguments go as attributes of the current scope of the loop expression, and get overwritten on every loop iteration. Note that they are updated with arguments receiving semantics, which is described at:
      ; () => edh'args'receiving # <- follow this bookmark to that section
      #  * The return value of the generator procedure will become the result value of the for-loop expression, as the loop is evaluated
      #  * The do-block of the loop, a.k.a. the loop body, can reference the loop arguments. Note that they are simply read as lexical attributes in scope. Lexical scoping rules are described at:
      ; () => edh'lexi'scoping # <- follow this bookmark to that section

      # %% # Define a generator procedure
      generator g( base, hint7= None, ) {
        yield ( 1, 3 * base, memo= '3 as the factor', )
        yield ( 2, 7 * base, memo= hint7 or nil, )
        return 5 * base
      }
      # %% # Call the generator procedure with a for-loop
      "Loop result= " ++
      for ( i, n, memo= 'no comments', ) from g( 11, )
      do console.print( 'Item #' ++ i ++ ': ' ++ n ++ ' with ' ++ memo )
      # %# #

      # Also note that:
      #  * `continue` can be used in the do-block (loop body) to skip subsequent statements in the block, thus jump to next iteration
      #  * `break` can be used in the do-block (loop body) to early stop the for-loop, making it evaluates to `nil`
      #  * `return xxx` can be used in the do-block (loop body) to early stop the for-loop, and further early return from the outer procedure. That's done technically by having the `yield` expression in the generator evaluates to a double-return structure like `return { return xxx }`, the generator in turn propagates the inner `return xxx` as its return value, thus becomes the result value of the for-loop expression, which gets interpreted as early returning `xxx` from the outer procedure body


      # Synchronous Narration is an advanced topic described in the tour at:
      #  https://github.com/e-wrks/tour/advanced/iter.edh
      # which is more convenient to be browsed by Gitpod via:
      #  https://gitpod.io/#https://github.com/e-wrks/tour/advanced/iter.edh

    }


    {## Observing Event Streams
     # - Iterate over the event stream through an event sink
     #} {;
      {## Observing Event Streams #}
      export edh'iter'events = bookmark()


    }


    {## Scanning Items in Containers
     # - Iterate over all items of a container

     #} {;
      {## Scanning Items in Containers #}
      export edh'iter'items = bookmark()


    }

  }


  {## while Loop
   # - Checked iterations

   #} {;
    {## while Loop #}
    export edh'while'loop = bookmark()


  }


  {## go Routines with Defered Cleanups
   # - Spawning many concurrent threads


   #} {;
    {## go Routines with Defered Cleanups #}
    export edh'go'routines = bookmark()


  }


  {## Exception Handling
   # - Using the catch ($=>) and finally (@=>) operator

The catch ($=>) operator ...

The finally (@=>) operator ...

   #} {;
    {## Exception Handling #}
    export edh'exception'handling = bookmark()


  }


  {## perceive Events
   # - Preemptive event handling


   #} {;
    {## perceive Events #}
    export edh'perceive'events = bookmark()


  }


  {## Structured Concurrency
   # - Taming the concurrent "goto"
   #} {; () => {
      # There is an advanced topic describing why & how to implement structured concurrency with the mechanisms described above
      import * '../advanced/concur'
      edh'structured'concurrency # <- follow this bookmark to the section there
    }
  }

}


export edh'pragmatics = bookmark()


{## Classes & Objects
 # - Compositional Multiple-Inheritance with Multiple-Prototype Chains
 #} {; import * '../advanced/objs'
  {## Classes & Objects #}
  export edh'classes'objs = bookmark()


  {## Data Classes
   # - Python PEP-557 (Data Classes) got dedicated syntax in Ä

Beyond PEP-557 features in a dedicated syntax, Ä data classes especially shines in pattern matching use cases, closely mimics ADT, predating PEP-634 (which is upcoming in Python 3.10).

   #} {;
    {## Data Classes #}
    export edh'data'classes = bookmark()


  }


  {## Usual Classes
   # - A data class is still a usual class under the hood

The `class` keyword defines a usual class.

   #} {;
    {## Usual Classes #}
    export edh'usual'classes = bookmark()


    # %%
    class B pass
    class C extends B
    class D extends C
    class E extends (D,B)
    # %%
    E.mro
    # %%
    o = C()
    o.a = 5
    # %%
    dir$ o

    # %#
  }


  {## Magic Methods
   # - Customize object behaviors in cooperation with infix operators


   #} {;
    {## Magic Methods #}
    export edh'magic'mths = bookmark()


  }

}


{## Modules
 # - Each module object is loaded from a particular `.edh` file


 #} {;
  {## Modules #}
  export edh'modules = bookmark()


}


{## Namespaces
 # - A namespace is a special object


 #} {;
  {## Namespaces #}
  export edh'namespaces = bookmark()


}


{## Procedures
 # - Ä is functional to such an extent

There are several types of procedure, including the lambda forms (arrow procedures), and expression being 1st class as well.

 #} {;
  {## Procedures #}
  export edh'procs = bookmark()


  {## Vanilla Procedures
   # - Defined with the `method` keyword
   #} {;
    {## Vanilla Procedures #}
    export edh'vanilla'procs = bookmark()


  }


  {## Interpreter Procedures
   # - Defined with the `interpreter` keyword
   #} {;
    {## Interpreter Procedures #}
    export edh'interpreter'procs = bookmark()


  }


  {## Generator Procedures
   # - Defined with the `generator` keyword
   #} {;
    {## Generator Procedures #}
    export edh'generator'procs = bookmark()


  }


  {## Producer Procedures
   # - Defined with the `producer` keyword
   #} {;
    {## Producer Procedures #}
    export edh'producer'procs = bookmark()


  }


  {## Arrow Procedures
   # - Defined with the (=>) operator

It'll be a generator procedure if the body contains at least 1 `yield` expression, otherwise it'll be a vanilla procedure.

   #} {;
    {## Arrow Procedures #}
    export edh'arrow'procs = bookmark()


  }


  {## Producer Arrow Procedures
   # - Defined with the (=>*) operator

No `yield` can appear in the procedure body.

   #} {;
    {## Producer Arrow Procedures #}
    export edh'arrow'procs = bookmark()


  }


  {## Operator Procedures
   # - The implementation of infix operators
   #} {;
    {## Operator Procedures #}
    export edh'op'procs = bookmark()


  }


  {## Definition Procedures
   # - To initialize a module, a namespace, or a class

   #} {;
    {## Definition Procedures #}
    export edh'defi'procs = bookmark()


  }


  {## Methods, Bound and Unbound
   # - Responsibility for objects

Procedures are always called with responsibility for some object(s), in this sense they are said to be "methods" of those objects.

A procedure will be bound when obtained via dot-notation before called.

When calling an unbound procedure, the owning objects are infered from the context.

   #} {;
    {## Methods, Bound and Unbound #}
    export edh'mths'bound'unbound = bookmark()


    {## This/That/Super Reference
     # - Compositional object structure

     #} {;
      {## This/That/Super Reference #}
      export edh'this'that'super'ref = bookmark()


    }


  }

}


{## Lexical Scoping
 # - Static scoping is used for usual artifact resolution (i.e. other than effect resolution)

 #} {;
  {## Lexical Scoping #}
  export edh'lexi'scoping = bookmark()


  {## Closure
   # - A procedure always captures the full lexical context it is defined in

Ä closure is rather coarse grained.

   #} {;
    {## Closure #}
    export edh'closure = bookmark()


  }

}


{## Expression Values and Scope Wrapprs
 # - Here is why Ä is even More dynamic than Python
 #} {;
  {## Expression Values and Scope Wrappers #}
  export edh'exprs'in'scopes = bookmark()

  {## Scope Wrappers
   # - A scope can be wrapped as an object to do reflection in Ä

`scope` is a builtin class.

   #} {;
    {## Scope Wrappers #}
    export edh'scope'wrappers = bookmark()


    # %% # without argument, it creates an object wrapping the scope where it's called from
    method f() {
      method g() {
        let ( a, b, ) = ( 7, 3, )
        scope()
      }
      let ( c, d, ) = ( 2, 8, )
      return g() @=> g = nil # dispose g after one-time used
    }
    s = f()
    'inner has ' ++ s.attrs() ++ ', outer has ' ++ s.outer.attrs()
    # %#


    # %% # if an object is passed as ctor argument, it creates an object wrapping that object's scope
    class C pass
    o = C()
    s = scope(o)
    s.put( a= 3, c= 2, b= 5, )
    s.attrs()
    # %#

  }


  {## The `expr` Expression
   # - Original source preserved

A procedure is always called against some object, it also has a formal declaration of its arguments, what if we strip off these properties? The result is: we get expressions.

Expression is 1st class in Ä, you can create expression values with literal form

   #} {;
    {## The `expr` Expression #}
    export edh'expr'expr = bookmark()

    # %%
    x = expr a + b * c

    # %#

  }


  {## Expression Arguments to Procedures
   # - Arguments are passed in expr form, to interpreter procedures and 3af operator procedures

For an interpreter procedure or an infix operator procedure with 3 positional arguments, the first argument will be wrapped scope object of its caller, and rest arguments are all expression values.

   #} {;
    {## Expression Arguments to Procedures #}
    export edh'expr'args = bookmark()

    # %%
    x' = makeExpr( a + b * c )
    # %%
    s.eval( x' )
    # %#

  }


  {## Code as Data
   # - A runnable piece of Ä code is just data from the perspective of the host language/runtime

Ä host procedures (written in Haskell) see Ä AST directly.

   #} {;
    {## Code as Data #}
    export edh'host'proc'exprs = bookmark()


  }

}


{## Pure Context
 # - For attribute defining side-effect to be suppressed

There are cases it's desirable to cease the side-effect of attribute creation into current scope, for some artifact-defining statements/expressions. E.g. an ad-hoc named value as an argument passed to some API. Some contextes are considered "pure" in Ä code, for this to happen automatically.

 #} {;
  {## Pure Context #}
  export edh'pure'ctx = bookmark()

  # %% # First make sure `x` is not in scope
  x = nil
  # %% # A parenthese quoted expression (no matter how complex it is), is evaluated in a pure context
  ; ( x := 5 )
  # %% # A standalone arguments packer expression is evaluated in a pure context
  ; ( x := 5, )
  # %% # Expressions for arguments within a call expression are evaluated in a pure context, you can intuit that there is just an arguments packer expression there
  show( x := 5, )
  # %% # The ($) and (|) operator, they all make calls, would pack the arguments likely, i.e. in a pure context
  show$ x := 5
  # %% # Finally assert no `x` is ever defined
  this?x is nil
  # %#

  # %% # Likely method definition expressions work the same way
  f = nil
  ; ( method f(x) x+1 )
  ; ( method f(x) x+1, )
  show( method f(x) x+1 )
  show$ method f(x) x+1
  this?f is nil
  # %#

}


{## Effect Tracking
 # - Vending & consuming effects with dynamic scoping

 #} {;
  {## Effect Tracking #}
  export edh'eff'tracking = bookmark()


}
