{## Syntax, Semantics, and Pragmatics of ƒê #}

{## ƒê Grammar Details #}
export edh'grammar'details = bookmark()


{## Overview
 # - Why and What is here with ƒê

ƒê seeks to ease development of embedded DSLs (Domain Specific Langauges) speaking / realizing business needs, i.e. a Business Integration language. How computers work and to be optimized in solving programming problems, are addressed by a large research discipline in its own right, i.e. Computer Science. But CS is too different and often too far from practical needs of realworld business, dedicated languages are of much interest, and ƒê attempts to be a comprehensive solution.

**ƒê (Edh)** stands for **Event Distributing & Hosting**, an _event_ is a consistent (but not necessarily atomic) piece of data, encapsulating the information of something just happend in one place, and sent to another place for its consequences to be realized there. _Event_ is conceptually coherent to **Algebraic Data Type** in _type theory_ as well as a functional programming language, but it's not practical to be a mechanical utility in a procedural langauge like ƒê. So _event_ stays conceptual in ƒê the language.

The _event_ abstraction should decouple much of the complexity, and degrade much part of the problem, to be solvable by _Citizen Developers_, especially with the aid of modern software engineering toolings.

You will be using ƒê to describe reactions to incoming events from other parts of the system, in forms of local entity attribute updates, and more complex logics with control flows. As well, you can post commands for event publishing/delivery, to other parts of the system. So modularized components can be developed for reuse, by your team or by 3rd parties, they'll be composed together to form the final live system.

Realworld systems are inherently effectful, any event upon it is realized (hosted), usually implies more effects it should cause, as part of the reactions mentioned above, further consequences can be described in terms of more effects generated, but how those new effects should be realized, is subject to other components composed as with the live system, that's to say, the concerns should be decoupled. Traditionally, it is solved by some IoC (Inversion of Control) container to dynamically inject manifested reactions at runtime. But with ƒê's **Dynamic Scoped Effects** system, no such container or framework is needed anymore, it can be done directly in the langauge, natural and elegant ƒê code just suffice.

**Monad** is state of the art way for effect tracking, while **Algebraic Effects & Handlers** being actively researched in academic for similiar purpose today, but they both work with functional programming langauges. Then inspired by **Algebraic Effects & Handlers**, ƒê implements **Dynamic Scoped Effects** for dynamic effect tracking in the procedural paradigm. It is **Dynamic Scoping** per se while historically, **Dynamic Scoping** designs are proved failures, but with ƒê's dedicated syntax / namespacing to have dynamic artifacts isolated from lexical artifacts, the confusing semantics / behaviors can be avoided, and then finally done right.

 #} {;
  {## Overview #}
  export edh'lang'overview = bookmark()
}


export edh'syntax = bookmark()


{## Code Styling
 # - ƒê code style is officially opinionated
 #} {;
  {## Code Styling #}
  export edh'syntax'style = bookmark()

  {## The Official ƒê Code Formatter
   # - Any style you like, so long as it is formatted such

ƒê encourages (turns-on-by-default) format-on-save, by the official no-config, uncompromised formatter:

  https://github.com/e-wrks/edh-vscode-formatter
  https://marketplace.visualstudio.com/items?itemName=ComplYue.edh-vscode-formatter

The motivation of such a formatter is quite inspired by Black:

  https://black.readthedocs.io

That's to save you time and mental energy for more important matters.

FYI, the original idea comes from Henry Ford's famous quotes about the Model T:

> Any customer can have a car painted any colour that he wants,
> so long as it is black.

Also opinionated formatters with similar goals:
  https://prettier.io  - Prettier for JavaScript (and HTML, CSS etc.)
  https://github.com/tweag/ormolu  - Ormolu for Haskell

   #} {;
    {## The Official ƒê Code Formatter #}
    export edh'code'formatter = bookmark()

    # Home page of the formatter should have described the rules and your rights (freedom) well. After modification, save it, or right-click anywhere, then select [Format Document], the formatter will adjust the file content according to the rules, you'll see what it thinks.

    # %% # try play with this cell:
    # indent or outdent the line, add/remove extranous spaces, break it into multiple lines, add extranous blank lines, ...
    1+ ( 2 - 3 ) *5 /9
    # %#

    # TODO any gotcha to be showcased here?
  }

  {## Indentation and Brackets
   # - ƒê interpreter is whitespace insensitive, indentation is enforced by ƒê formatter

The programmer is responsible for the brackets (lexical / static scoping), while the formatter is in charge of proper indentation, it infers indentation level of each line from the nesting of brackets.

   #} {;

    {## Whitespace Sensitivity is Outdated
     # - Indentation can be inferred, no reason to DIY today

> Why Python‚Äôs whitespace rule is right
  https://unspecified.wordpress.com/2011/10/18/why-pythons-whitespace-rule-is-right

> There is not a single situation in any country, in any programming language, or at any skill level, in which is it acceptable to not indent your code the way Python requires it.

This is much agreeable even at today.

> When you really analyse it, Python‚Äôs whitespace sensitivity is actually the only logical choice for a programming language, ...

Well, this conclusion holds right in its time, when auto code formatters are still some luxury to have. But today, besides the compiler(s), we are affording way more expensive analyzing tools like linters, test runners, coverage, profilers, and usually comprehensive langauge servers, amongst what code formatters become rather commonplace.

Scopes (either lexical or conceptual) have to be decided and expressed by the programmer (or document writer), but even excluding extreme cases, a code block can consist of up to hundreds of lines, it's ridiculous to manually maintain proper indentation for every line, when the formatter can do it for you straight forward.

Whitespace sensitivity has become outdated today, brackets (curly, square or round) come handy-dandy to express various scopes in your mind, just leave indentation for the formatters to care about.

     #
     #} {;
      {## ƒê is Whitespace Insensitive #}
      export edh'sps'insensitivity = bookmark()

      {## Comments are Indented
       # - Both line comment and block comment

As you may have noticed, block comments (started with `{#`) are indented, also a line of comments are indented when it starts with #, whether it is a standalone line comment, or part of a block comment.

       #} {;
        {## Comments are Indented #}
        export edh'cmt'indent = bookmark()

        # This is a standalone comment line, will always be indented by the formatter. Try adjust the indentation level of any line in this section, then save or do [Format Document] to see how the formatter corrects your mistakes.

        {# This is a short block comment #}

        {# This is multi-line block comment

         # This line is part of the outer comment block, but will be indented by the formatter, as it starts with #.

Try remove the leading # of the line above, then adjust its indentation level, you'll see the formatter stops working against you.

         #}

        {## This is a doc comment
         # A doc comment makes sense when placed:
         #  * At the very beginning of an ƒê module file
         #    - Serving as the documentation for that whole module
         #  * Immediately before a block
         #    - Serving as the documentation for that nested block
         #  * Immediately before a statement
         #    - Serving as the documentation for whatever defined by that statement, possible being:
         #      * A procedure
         #      * A class
         #      * An attribute
         #}
        edh'documented'attr'example'ùõë = 3.14
      }

    }

  }


  {## Semicolons and Commas
   # - They are optional everywhere in ƒê, unless for disambiguation
   #} {;
    {## Semicolons and Commas #}
    export edh'semicolons'and'commas = bookmark()

    {## Technically Optional
     # - That is, can be omitted

Semicolons can be really technically omitted in ƒê, not the case like in JavaScript that the language does:
  > Automatic Semicolon Insertion
  https://tc39.es/ecma262/#sec-automatic-semicolon-insertion

Which means, leading ones, trailing ones, as well as middle ones, all can be omitted.

     #} {;
      {## Technically Optional #}
      export edh'omit'semicolon'and'commas = bookmark()

      # Let's see some examples with the idiomatic form pointed out.

      # The following 5 cells have identical semantics and equally evaluates a block, gives out the value of last assignment statement in it
      # %%
      { a=5; b=3; c=9; }
      # %%
      {; a=5 b=3 c=9 } # <- idiomatic one
      # %%
      { a=5 b=3; c=9 }
      # %%
      { a=5 b=3 c=9; }
      # %%
      { a=5 b=3 c=9 }
      # %#

      # The following 5 cells too, have identical semantics and equal result value of a dict
      # %%
      { 'a': 5, 'b': 3, 'c': 9, } # <- idiomatic one
      # %%
      {, 'a': 5 'b': 3 'c': 9 }
      # %%
      { 'a': 5 'b': 3, 'c': 9 }
      # %%
      { 'a': 5 'b': 3 'c': 9, }
      # %%
      { 'a': 5 'b': 3 'c': 9 }
      # %#

      # The following 5 cells too, have identical semantics and equal result value of a list
      # %%
      ; [ 5, 3, 9, ] # <- idiomatic one
      # %%
      ; [, 5 3 9 ]
      # %%
      ; [ 5 3, 9 ]
      # %%
      ; [ 5 3 9, ]
      # %%
      ; [ 5 3 9 ]
      # %#

      # The following 5 cells too, have identical semantics and result value of a positional-only ArgsPack
      # %%
      ; ( 5, 3, 9, ) # <- idiomatic one
      # %%
      ; (, 5 3 9 )
      # %%
      ; ( 5 3, 9 )
      # %%
      ; ( 5 3 9, )
      # %%
      ; ( 5 3 9 )
      # %#
    }

    {## Disambiguation Needs
     # - At times, a semicolon / comma is needed for disambiguation
     #} {;
      {## Disambiguation Needs #}
      export edh'disambiguation'needs = bookmark()

      {## Unintended Indexing / Calling
       #} {; export edh'disambig'idx'call = bookmark()
        # There usually need a semicolon before a pair of square/round brackets, when you don't mean to do indexing or calling against artifact before it.
        # %% # A list literal
        ; [ 3, 2, 5, ]
        # %% # An apk literal
        ; ( 3, 2, 5, x= 7, y= 23, )
        # %#
      }

      {## Block instead of Dict
       #} {; export edh'disambig'blk'dict = bookmark()
        # You may have noticed the semicolons everywhere, each following an opening curly brace too. Why are they there?

        # %% # Well, check out this:
        type( {; } )
        # %% # Then this:
        type( {} )
        # %#

        # The answer is: The semicolon inside `{;}` disambiguates it being a block (though empty) instead of an empty dict expressed as `{}`

        # FYI, in ƒê, block is a type of expression (instead of statement as in C family languages). A block encloses arbitrary number of statements, and evaluates to the value of the last statement when executed (with the exceptin of branches' early break, though, about that later)
        # %% # And an empty block evals to `nil`, check this to be true
        {; } is nil
        # %#

        # Though you don't need a semicolon when there is at least 1 statement in a block, e.g.
        # %% # This is a block with a single assignment expression statement
        { a=1 }
        # %% # But this is the idiomatic form, which is preferable for foolproof modifications in later code maintenance:
        {; a=1 }
        # %#
      }

      {## ArgsPack instead of Expression-in-Parenthese
       #} {; export edh'disambig'apk'paren = bookmark()
        # A comma is needed to disambiguate ArgsPack (a super type of Python tuple), from parenthese-quoted single expression
        # %% # A single apk
        ; ( 3*7, )
        # %% # A parenthese-quoted expression
        ; ( 3*7 )
        # %%
        ; type( ( 3*7, ) )
        # %%
        ; type( ( 3*7 ) )
        # %#
      }
    }

    {## Idioms
     # - Idiomatic Semicolon / Comma Placements

In ƒê code it's considered idiomatic to:

* Avoid semicolons without good reasons
* Place trailing commas where possible

     #} {;
      {## Idioms #}
      export edh'semicolon'comma'idioms = bookmark()

      # The idiomatic style is to put a semicolon right after the opening curly brace/bracket, when a block instead of dict literal intended:
      {;
        # It can still parse as dict literal with comments inside, if without the semicolon
      }

    }

  }


  {## Recommended Line Length
   # - It is under your control, well some advice here

For the record, ƒê langauge support extension for VSCode sets the following config options per the language:

* Show rulers at column positions: 80, 100, 120
* Soft-wrap lines at 100, while adapting to narrower window width

You are recommended to hard-wrap source lines around column 80, and that's not for good old line printers set for Fortran punch cards, but to enable a human reader have 2~3 editor columns layed out on wide screens, to cross check code segments from multiple sites, without necessarity of tab switching, which is good for productivity.

For long paragraphs in comments, of mere documentation purpose, it's considered more idiomatic to keep them as long lines per each paragraph, so you don't need to manually maintain hard-wrap points when update documentation, just leave it soft-wrapped at 100 columns by default.

Nevertheless you can change per user settings of your IDE, for a different soft wrap strategy.

   #} {;
    {## Recommended Line Length #}
    export edh'line'len'adivce = bookmark()

    # %%
    '''
                                                                    80 columns ‚ñΩ
12345678901234567890123456789012345678901234567890123456789012345678901234567890
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                                                                       100 columns ‚ñ≥
'''
    # %#
  }

}


{## Code Syntax
 # - Expressions and statements

Expression is a special (yet very important) type of statement, an expression yields a meaningful result when evaluated. Note that an expression may or may not have side-effects when evaluated.

Expressions can be combined together (e.g. by an infix, binary operator, among other forms), to form a new expression, so a complex expression can consist of many sub-expressions organized in a deeply nested hierarchy.

For a statement of some type other than _expression_, when evaluated, it doesn't yield a meaningful result, instead it produces desriable side-effects.

ƒê is _strict_ in evaluation of statements, an ƒê interpreter program evaluates a statement immediately upon one is encountered. The contrary is _lazy_ evaluation, in which sense the actually evaluation can be postponed until absolutely necessary.

 #} {; import * './refs'
  {## Code Syntax #}
  export edh'exprs'stmts = bookmark()

  {## Typical Examples
   # - Commonplace expressions and statements
   #} {;
    {## Typical Examples #}
    export edh'expr'stmt'examples = bookmark()

    # %% # `let` is a typical statement, its side-effects are assignments to various attributes of the current scope
    let (a, b, c,) = (3, 2, 7,)
    # %# See that there's NO result by running this cell?

    # %% # Arithmetic expressions are very typical, usually having literal expressions and attribute expressions joined with binary operators, e.g.:
    a + b * c - 5
    # %# See the result?
    # Note `*` is the multiplication operator (while in everywhere else other than a programming language, it is `√ó`)
  }


  {## Arguments Packing & Unpacking
   # - Positional & named formal arguments to be packed and unpacked

ƒê has a unique immutable data structure - ArgsPack, usually abbreviated as apk. An apk is created by a pair of parenthese quoting a list of positonal or named argument expressions.

Arguments are packed into an apk in the following cases:
 * In execution of a `let` statement, for rhs to the `=` operator
 * In evaluation of a call expression, i.e. an expression of callee followed by the postfix `()` operator
 * In evaluation of an indexing expression, i.e. an expression of container followed by the postfix `[]` operator
 * In evaluation of a standalone apk literal

   #} {;
    {## Arguments Packing & Unpacking #}
    export edh'args'un'packing = bookmark()

    # %% # Positional-only apk is roughly equivalent to what's called "tuple" in other programming languages having it (e.g. Python), both semantically and syntatically.
    type( (1,2,3,) )
    # %% # A single argument pack needs to be disambiguated with one or more extra commas (leading, trailing or unusually - both)
    type( (,1,) )
    # %% # While only trailing commas are idiomatic in ƒê
    ; (1,)
    # %% # Or it'll be parsed as parenthese-quoted expression for precedence override purpose
    type( (1) )
    # %#

    # %% # Named arguments can be put anywhere in the list, but an apk value will be canonicalized to have all positional arguments separated from named arguments, with their respective order of appearance reserved:
    apk = ( name= 'Compl', 1, 2, year= 2021, )
    # %#

    # %% # Asterisks can be used to unpack apk/list/dict into current target apk
    l = [ 3, 5, ]
    d = { 'name': 'Yue', 'city': 'Chongqing', }
    ; ( 7, ***apk, **d, *l, year= 2030, city= 'Shanghai', *apk, )
    # %# As you can see:
    #
    #   Unpacking and direct argument specifications can be arbitrarily mixed
    #
    #   *** triple asterisks unpack both positional & named arguments
    #    ** double asterisks unpack only named arguments
    #     * single asterisks unpack only positional arguments
    #
    #   The order of appearance are always reserved
    #
    #   A repeated named argument replaces the value, but doesn't change where it sppears

  }


  {## Arguments Receiving, Repacking
   # - Receive arguments from an apk into current scope

Arguments are received from an `ArgsPack` in the following cases:
 * In execution of a `let` statement, according to specification at lhs of the `=` operator
 * In execution of a for-loop expression, according to the loop argument specification
 * When a procedure is called, according to the argument specification in the definition of the procedure

Upon receiving, rest arguments can be repacked into new `ArgsPack`s, when varidic arguments are expected.

   #} {;
    {## Arguments Receiving, Repacking #}
    export edh'args'receiving = bookmark()

    # %% #
    apk = ( name= 'Compl', 1, 2, 3, year= 2021, city= 'Choingqing' )
    # Note a standalone apk is used at rhs of the `=` operator in the let statement, it of course can be a literal apk instead
    let ( name as nnn, x, *xs, optional'x= None, **kws, ) = apk
    # %%
    nnn
    # %%
    x
    # %%
    xs
    # %%
    optional'x
    # %%
    kws
    # %#

    # As you can see in above, single asterisks can be used to receive rest positional arguments as a specified attribute, while double asterisks can be used to receive rest keyword arguments

    # %% # Triple asterisks can be used to receive rest positional + keyword arguments as a new apk attribute with the specified name
    let ( x, ***apk', ) = apk
    # %%
    apk'
    # %%
    x
    # %#

  }


  {## Operators
   # - Fully customizable infix operators with a few intrinsic prefix and postfix operators

There are a few prefix and postfix operators intrinsic to the ƒê language, while all infix operators are customizable operator procedures. A set of infix operator procedures come with the default batteries bundled with the bare interpreter package, more ƒê packages would possibly add their own operator implementations and/or overrides, along with other artifacts such as classes, methods, symbols etc.

   #} {;
    {## Operators #}
    export edh'operators = bookmark()


    {## Intrinsic Prefix Operators
     # - All unary

All prefix operators are intrinsic to the language, they can only be right-associative, but their precedences decide how nested operators parse, thus the semantics.

Especially note that a semicolon (or comma according to the context) may be usually needed immediately before a prefix operator which can also be an infix operator (namely `+`, `-`, and `|`), for disambiguation purpose.

     #} {;
      {## Intrinsic Prefix Operators #}
      export edh'prefix'ops = bookmark()


      {## The prefix plus (+) operator
       # - With precedence 9

It is technically no-op, but is idiomatic to be written out explicitly in certain cases, e.g. as in `+inf` when contrasted with negative infinity `-inf`.

       #} {; export edh'prefix'plus'op = bookmark()
        # %% # It's technically no difference with or without a prefix +
        ; +inf is inf
        # %# See above is true.
      }


      {## The prefix minus (-) operator
       # - With precedence 9

It is used to negate a decimal value, and will err out for other type of values at runtime.

       #} {; export edh'prefix'minus'op = bookmark()
        # %%
        ; -3.5
        # %%
        ; - ( 5 / -11 )
        # %%
        ; -inf
        # %#
      }


      {## The prefix (not) operator
       # - With precedence 4

It is used to negate a boolean value, and will err out for other type of values at runtime.

       #} {; export edh'prefix'not'op = bookmark()
        # %%
        not true
        # %%
        not 3 > 2
        # %%
        not 3*7 == 22
        # %#
      }


      {## The prefix guard (|) operator
       # - With precedence 1

It is used to explicitly mandate a conditional match for a branch, regardless of the contextual matching target value.

       #} {; export edh'prefix'guard'op = bookmark()
        # %% #
        ; | 3*7 is 21 -> "That's so true."
        # %% #
        ; | 3 < 2 -> "No way this get shown!"
        # %# Branches are described later in this chapter
        ; () => edh'branching # <- follow this bookmark to that section
      }


      {## The prefix (void) operator
       # - With precedence -10

It is used to technically cease the result (to be always replaced with `nil`) of its operand expression, as well as to formally declare the no-result semantics as an expression.

       #} {; export edh'prefix'void'op = bookmark()
        # %% # It is idiomatic for a procedure to have a `void` body, when no meaningful result is meant to be returned. Compare this (deprecated) implementation:
        method do'sth() {
          that.some'method'with'meaningful'result()
          return nil
        }
        # %% # to the idiomatic implementation:
        method do'sth() void {
          that.some'method'with'meaningful'result()
        }
        # %# See the later is both more concise and more pragmatic.
      }


      {## The prefix (ai) operator
       # - With precedence -10

It is used to perform its operand expression (usually consists of multiple steps) to be evaluated in a single STM transaction.

Note an STM transaction will retry automatically, and prone to no-progressing under heavy concurrent contention. And IO actions are not permitted during an STM transaction. Carefully reasoning is reqired to use this operator properly.

       #} {; export edh'prefix'ai'op = bookmark()
        # %% # A correct (but not performant) implementation of simple concurrent counter can be:
        data ConcCounter(cnt= 0) {
          method inc() ai this.cnt += 1
          method dec() ai this.cnt -= 1
        }
        # %# Data classes are described later in this chapter
        ; () => edh'data'classes # <- follow this bookmark to that section
      }


      {## The prefix (default) operator
       # - With precedence -10

It is used to create a default expression with its operand expression.

       #} {; export edh'prefix'default'op = bookmark()
        # Defaulting semantics is an advanced topic explained in another chapter:
        ; () => import (
          edh'defaulting, # <- follow this bookmark to the relevant section there
          **
        ) './advanced/appl'
      }


      {## The prefix (new) operator
       # - With precedence -10

It is technically no-op, and used for source-level compatibility with other scripting languages like JavaScript, where scripting based RPC (Remote Procedure Call) would take place.

       #} {; export edh'prefix'new'op = bookmark()
        # ƒê can be used to validate / syntax-highlight foreign code snippets those compliant to a common subset of scripting syntax, among JavaScript / Python etc.
        false and that.jsRPC(js!expr{
            console.log( 'The time now is ' + new Date());
        })
        # %# Note that expression values are described later in this chapter
        ; () => edh'expr'expr # <- follow this bookmark to that section
      }

    }


    {## Intrinsic Postfix Operators
     # - Currently just indexing and calling

All postfix operators are intrinsic to the language, they can only be left-associative.

There are currently only two postfix operators, namely indexing `[]` and calling `()`. They both have the highest possible precedence.

     #} {;
      {## Intrinsic Postfix Operators #}
      export edh'postfix'ops = bookmark


      {## Indexing
       # - For element extraction & assignment

       #} {;
        {## Indexing #}
        export edh'indexing = bookmark()

        # %% # You can obtain positional arguments from an ArgsPack with positive integer index
        apk = (3, 2, 5,)
        apk[ 1 ] # ƒê index is zero based (i.e. offset semantics as in C family languages)
        # %% # You can obtain values from a dict with the key as index
        d = {
          'name': 'Compl',
          'year': 2021,
        }
        d[ 'name']
        # %% # A dict can be modified via indexed assignment
        d[ 'year' ] = 2030
        d
        # %#
      }


      {## Calling
       # - Making procedure calls

       #} {;
        {## Calling #}
        export edh'calling = bookmark()

        # %% # You've just seen plenty usage of it
        console.print(
          'Calling a procedure is actually the application of the postfix () operator.'
        )
        # %#
      }

    }


    {## Customizable Infix Operators
     # - In spirit of Haskell

All infix operators are defined as operator procedures, many of them are intrinsic (host) procedures, while others being ƒê procedures. They all have a custom precedence & associativity/fixity respectively, and can be overridden by attribute shadowing at particular scopes.

Custom infix operators are usually named after one or more valid operator characters, which is one of "~=!@#$%^&|:<>?*+-/" plus various Unicode characters in the following general categories:

  * MathSymbol
  * CurrencySymbol
  * ModifierSymbol
  * OtherSymbol
  * DashPunctuation
  * OtherPunctuation

Especially note that dot (.) and square brackets ([]) are not valid operator characters, they work with magic methods instead.

However, there are a few hard-coded exceptions, namely the following operators:

  * is
  * is not
  * and
  * or

Custom infix operators can also be named after tilde (~) denoted alphanumeric symbols, such a symbol must starts with the tilde (~) character, followed by one or more alphanumeric characters, or other operator characters other than the tilde (~). The second tilde (~) character if appeared in such a symbol, will effectively denote end-of-operator-symbol, for anything following it to be treated as separate lexeme.

     #} {;
      {## Customizable Infix Operators #}
      export edh'infix'ops = bookmark()


      # %%
      namespace custom'infix'ops () {

        {## Custom Operator Declaration
         # - With precedence & fixity

You must specify the precedence as well as the desired fixity (use one of the keywords: `infixl` / `infixr` / `infix`) when defining fresh new operators

         #} {;

          # Implement the operator with argument list and procedure body
          infixl 7 (√ó) (lhv, rhv) lhv * rhv

          # Use an existing operator as the operator implementation
          infixl 7 (√∑) () (/)

        }

        # With a conformant argument list, this method procedure can be re-declared as an operator
        method stylish'and'concat(lhv, rhv) lhv ++ ' & ' ++ rhv

        {## Operator Override
         # - With a new implementation, shadowing ones from outer scopes

You can use just the `operator` keyword to override an existing operator

         #} {;

          # Use an existing procedure as the operator implementation
          operator (and) () stylish'and'concat

        }

      }

      dir$ custom'infix'ops
      # %#

      # %% # Expressions can be evaluated in scope of a namespace via a scope wrapper
      scope(custom'infix'ops).eval(expr
        3 √ó 7 √∑ -56
      )
      # %%
      scope(custom'infix'ops).eval(expr
        'You' and 'me'
      )
      # %# Expression values and scope wrappers are described later in this chapter
      ; () => edh'exprs'in'scopes # <- follow this bookmark to that section


      # %% # Operator procedures can be referenced with its symbol quoted in a pair of parenthese
      show$ (*)
      # %%
      show$ (is not)
      # %%
      show$ (or)
      # %% #
      scope(custom'infix'ops).eval(expr
        show$ (√ó)
      )
      # %#

      # Especially note that, dot-notation won't work for operators, it is designed to work with magic methods instead. The crucial fact to know is: the parenthese is part of the name used to identify a magic method, but never so for names identifying operators.
      # %% # This is an error:
      custom'infix'ops.(√ó)
      # %# Magic methods are described later in this chapter
      ; () => edh'magic'mths # <- follow this bookmark to that section

      # Checkout the meta definition for operators come with default batteries
      import * 'batteries/meta/ops' into Nothing
    }


    {## Notable Infix Operators
     # - Some important operators come with the default batteries
     #} {;
      {## Notable Infix Operators #}
      export edh'notable'infix'ops = bookmark()

      {## Logical Operators
       # - Strict and short-circuiting, nullish versions


       #} {;
        {## Logical Operators #}
        export edh'logical'opa = bookmark()

        {## Strict Version
         # - (&&) / (||)

Both operands will be evaluated anyway, and it'll be runtime error if either left or right hand side expression evaluates to a value of type other than `BoolType`.

         #} {;
          {## Strict Version #}
          export edh'strict'and'or'ops = bookmark()

          # %% # Log a message to know it's called
          method greater(x, y) {
            console.info<| 'Comparing ' ++ x ++ ' vs ' ++ y ++ ' ...'
            x > y
          }

          # %% # See no short-circuiting would happen
          greater(3, 5) && greater(9, 2)
          # %% #
          greater(5, 3) || greater(2, 9)
          # %#

          # %% # This will be runtime error
          5 > 3 && 'yes'
          # %% # Contrusting to this correct implementation:
          5 > 3 and 'yes'
          # %#

        }


        {## Short-circuiting Nullish Version
         # - (and) / (or)
         #} {;
          {## Short-circuiting Nullish Version #}
          export edh'nullish'and'or'ops = bookmark()

          # %% # The rhs expression is evaluated conditionally
          debug and console.print( "We're debugging." )

          debug or console.print( "We're in production." )
          # %# Only one of the above 2 prints could have been executed


          # %% # Provide some default value in stead of a nullish one
          d = {} # Let it be an empty dict per se
          # %% # An empty container is considered falsy
          null(d) is true
          # %% # Replace `d` with some default, only when it's empty
          d or { 'name': 'Anonymous', 'from': 'Internet', }
          # %% # Let it be non-empty, then run above cell again
          d = { 'name': 'Compl', 'from': 'Chongqing', }
          # %#


          # %% # Simulation of the tenary operator
          let abs' = n => n < 0 and -n or n
          # %%
          abs'(5)
          # %%
          abs'(-5)
          # %#
        }

      }


      {## Comparison Operatorrs
       # - Doing equality and ordering comparisons
       #} {;
        {## Comparison Operatorrs #}
        export edh'cmp'ops = bookmark()

        # %% # Identity Equal
        3*7 is 28
        # %% # Identity Not Equal
        3*7 is not 28

        # %% # Instant Equal
        3*7 == 28
        # %% # Instant Not Equal
        3*7 != 28

        # %% # Greater Than
        3*7 > 28
        # %% # Greater or Equal
        3*7 >= 28
        # %% # Less Than
        3*7 < 28
        # %% # Less or Equal
        3*7 <= 28
        # %#


        {## Chaining
         # - Chain a group of equality or ordering comparison operations together
         #} {;
          {## Chaining #}
          export edh'chain'cmp'ops = bookmark()

          # %% # Let's take these values for example
          let (x, y, z,) = (1, 2, 3,)

          # %% # You can chain ordering comparisons together, for brevity and Math feeling
          ; ( x < y <= z ) is true

          # %% # `x < y <= z` is desugared to:
          {@
            _x'eval'ed = x
            _y'eval'ed = y
            _x'eval'ed < _y'eval'ed and _y'eval'ed <= z
          @}
          # %# Please recognize the short-circuit implications and evaluation of `y` just once

          # %% # You can also chain equality comparisons together
          ; ( x != y == z ) is false
          # %%
          ; ( x != y == 2 ) is true

          # %% # But when mixed, they follow their `infixr 4` semantics, so this works:
          true == x < y <= z

          # %% # But this will err out:
          x < y <= z == true

          # %#
        }
      }
    }

  }


  {## More Expressions and Statements
   # - There are more types of expressions and statements in ƒê

For example:
 * Dict Expresssion
 * List Expression
 * Namespace Expression
 * Class Expression
 * Block Expression
 * Yield Expression
 * Index Expression
 * Call Expression
 * Default Expression
 * Go Statement
 * Defer Statement
 * Perceive Statement
 * Break Statement
 * Continue Statement
 * Fallthrough Statement
 * Throw Statement
 * Rethrow Statement
 * Return Statement

   #} {;
    {## More Expressions and Statements #}
    export more'exprs'stmts = bookmark()

    edh'lang'refs'details # <- follow this to ƒê langauge reference for a detailed list of statements (including expressions) ƒê code can have
  }

}


export edh'semantics = bookmark()


{## Special Namespace Objects
 # - `namespace` is a special class of objects in ƒê

The general syntax to define a namespace object is:

  namespace <ns-name> ( **<kwarg-senders> ) <ns-body>

Following the `namespace` keyword, first comes name of the namespace, it can be any valid attribute identifier, and will be used as the attribute name for current scope to receive the new namespace object.

Then there is a pack of argument senders, but no positional argument is expected in it, just named (keyword) arguments, they'll be the namespace's attributes as you'd intuit.

Finally there's the namespace initialization procedure body, all sorts of statements can go there, they'll be evaluated in a scope with the backing entity being also the namespace object's backing entity as well, so as to further initialize attributes in that entity.

 #} {;
  {## Special Namespace Objects #}
  export edh'namespaces = bookmark()

  # %% # A simple example to define a namespace object
  symbol @ns'secret

  namespace ns( a= 3, b= 2, @ns'secret= 37256, ) {
    c = a - b / 5
    ; @'full-time' = false
  }

  dir$ ns
  # %#

  # Note that attributes, symbols, at-notations etc. will be described in later sections of this chapter
}


{## General Namespace, Entities backing Scopes & Objects
 # - Each entity is conceptually a general namespace

Entity is the logical unit of information to be organized in an ƒê world. An entity consists of a dynamic set of attribute values identified by distinct identifiers. Entities only exist conceptually, some entities are used to each back a procedure scope, other entities are used to each back an object (excepting host objects), together with its object scope.

ƒê is rather dynamic in nature - at runtime, not only each individual attribute value can change arbitrarily, new attributes can be added to an entity, as well as existing attributes can be deleted from it. That is to say, the structure as well as the attribute values of each entity can vary on its own at runtime.

We'll use namespace objects as examples in following sections.

 #} {;
  {## General Namespace, Entities backing Scopes & Objects #}
  export edh'namespacing = bookmark()


  {## Mutable Entities
   # - All objects and scopes are mutable

All program states of an ƒê program pertain to certain entities at the run. Be it a scope, or an object, its backing entity can always be mutated, at any time, as within an ƒê world. The modifications usually come from the software component managing program states, but it's fairly common for some monitoring UIs, or interactive REPLs over stdio or network (SSH, WebSocket, etc.) to observe/change the program states for diagnostics / troubleshooting purposes.

   #} {;
    {## Mutable Entities #}
    export edh'entities = bookmark()
  }


  {## Attribute Identifiers
   # - About naming attributes

Each attribute of an entity has to be uniquely identified within scope of this entity. In ƒê, the usual alphanumeric "variable" identifiers (like in other programming languages) can be used.

In addition, symbolic identifiers are also supported and recommended for cross-component scenarios.

And technically, any string (even the empty string) can serve as an attribute identifier in ƒê, with at-notation.

Note that in the ƒê language there is no such a concept/term of "variable". The "variable" concept in conventional programming languages is misleading or conflicting when you could possibly have mathematical concepts in the domain model of your business. More properly it should be called "assignable" as suggested in:
  https://existentialtype.wordpress.com/2013/07/22/there-is-such-a-thing-as-a-declarative-language

Although attributes of entities in ƒê are inherently meant to be assigned (as well as to be observed), they can not stand alone without a backing entity. Unlike in conventional programming languages, where a "variable" can be assigned individually.

   #} {;
    {## Attribute Identifiers #}
    export edh'attr'ids = bookmark()

    {## Alphanumeric Names
     # - The usual "variable" identifiers in a programming language

An alphanumeric name must start with a letter (i.e. alphabetic Unicode characters (lower-case, upper-case and title-case letters, plus letters of caseless scripts and modifiers letters) or the underscore character (_); more characters can follow, and they must be alphabetic or numeric Unicode characters, or the underscore character (_) or the single-quote character (').

Note the single-quote character is allowed to mean the prime symbol as in mathematics, following Haskell convention.

     #} {;
      {## Alphanumeric Names #}
      export edh'alphanum'names = bookmark()


      # %% # Some examples:
      namespace alphanum'named'arts (
        a= 3, _b3= 2, a'= 5,
        x= 9, y_5= 1, x''= 6,
        name= 'Compl', city= 'Chongqing', year= 2021,
        ùõë= 3.141592653589793238462643383279502884197169399375105820974944592307,
        Œ©= 0.567143290409783872999968662210,
        √ê= 'A language with great tooling',
      ) {

        method factorial(n) n <= 1 and 1 or n * factorial(n - 1)

        method ùõ¥(*items) case items of {
          () -> 0
          { item1 :> rest } -> {
            s = item1
            for i from rest do s += i
            return s
          }
        }

      }
      dir$ alphanum'named'arts

      # %% # Method procedures in a namespace can be called via dot-notation
      alphanum'named'arts.factorial(5)
      # %%
      alphanum'named'arts.ùõ¥( 3, 7, 9, )
      # %# Procedures and dot-notation are described later in this chapter
      ; () => edh'procs # <- follow this bookmark to that section
      ; () => edh'dot'notation # <- follow this bookmark to that section

      # %% # Expressions can be evaluated in scope of a namespace via a scope wrapper
      scope(alphanum'named'arts).eval(expr
        ùõ¥( 3, 7, 9, )
      )
      # %# Expression values and scope wrappers are described later in this chapter
      ; () => edh'exprs'in'scopes # <- follow this bookmark to that section


      {## The Underscore (_) Attribute Key
       # - A blackhole w.r.t. assignment

Special note about the single character identifier with a mere underscore, it is a valid identifier but acts as a blackhole w.r.t. scope attribute assignment. It is idiomatic to explicitly discard the direct result value this way, when only side-effects are desired from some expression with a meaningful return value.

       #} {;
        {## The Underscore (_) Attribute Key #}
        export edh'underscore'attr = bookmark()

        # %% % Assigning to `_` will not create an attribute named `_` in current scope, though all side-effects by evaluating the rhs expression will apply.
        _ = 3 * 7 # TODO a better example with desirable side-effects
        dir
        # %# See there is no attribute named `_` appeared.

      }

    }


    {## Symbolic Names and At-Notation
     # - To avoid name clashing across indenpendant software components

Symbol is a special type of values solely for identification purpose, they are defined and used via at-notations.

The other mainstream programming language having symbols is JavaScript, though there is no dedicated syntax in JavaScript as in ƒê.

Note that Julia's symbol is still alphanumeric based, and is for AST manipulation purpose, which is not the same as in ƒê.

     #} {;
      {## Symbolic Names and At-Notation #}
      export edh'symbolic'names = bookmark()
      export edh'at'notation = bookmark()

      {## Usual At-Notation
       # - The simple way to define and use symbols locally
       #} {;
        {## Usual At-Notation #}
        export edh'usual'at'notation = bookmark()

        # A symbol is a value of special type, can only be created with a special syntax, where an alphanumeric name for the attribute in current scope to receive the symbol value is specified.
        # %% # Define a symbol named `secret`
        symbol @secret
        dir
        # %% # Its alphanumeric name can be used against current scope to obtain the value
        type(secret) is SymbolType
        # %# See above is true.

        # %% # Create a new attribute named after it, in the namespace, by assignment
        ns.@secret = 55632
        ns.@secret
        # %# Note neither `.` nor `@` as in above is an operator, also not that they combined. Instead, "dot" (.) followed by "at" (@) and an alphanumeric name, is intrinsic to the language syntax in this form. Remind that `@` can be part (or whole) of an operator symbol, while `.` can never be.
        # And you can have spaces above around both the "dot" and the "at", up to your style.

        # %% # There is another form of at-notation works as well, through `@` as an infix operator
        show$ (@)
        # %% # Assignments and references work straight forward
        ns @ secret = 33526
        ns @ secret
        # %# Note the spaces around `@` above is optional, ƒê formatter honors your stylish to have them or not, but more whitespaces will be collapsed into one.

        # %% # Now create a new attribute named after this symbol, in current scope, by assignment
        ; @secret = 33526
        dir
        # %% # Note the semicolons needed above and below to disambiguate from infix at-notation.
        ; @secret
        # %#

        # The name for the attribute storing a symbol value, and the attribute named after the symbol value, are two different things. A symbol value can be stored under any other name, and used via that alias as well:
        # %% # Create an alias of the `secret` symbol value
        confidential = secret
        ns.@confidential
        # %% # It is ultimately the symbol value that matters for a symbolic attribute, not how that symbol value is named, so:
        console.print$ 'Before changed, @secret is: ' ++ ns.@secret
        ns.@confidential = 12345
        console.print$ 'After changed, @secret is: ' ++ ns.@secret
        # %% # Figured out why `@secret` is changed by assigning to `@confidential` ? Hint:
        confidential is secret
        # %# That's it, the symbol value for the symbolic names are the same, regardless of how these key values are stored and obtained. This mechanism allows you to import symbols from alien modules, but renamed locally to avoid alphanumeric name clashing, while still be able to exchange symbolic attributes seamlessly.

        # %% # Nothing prevents you from creating a new symbol value under an existing name, the old, alphanumericly named attribute for the symbol value, will simply be overwritten:
        symbol @secret
        confidential is secret
        # %% # Now they are different keys, so the symbolic names via them are different attributes, thus can be created/changed independently:
        console.print$ 'Before changed, @confidential is: ' ++ ns.@confidential
        ns.@secret = 54321
        console.print$ 'After changed, @confidential is: ' ++ ns.@confidential
        # %#

        # %% # It can surprise you now:
        dir$ ns
        # %# Confused seeing two "@secret" attributes coexisting?
        # %% # As well as:
        dir
        # %# See "confidential= @secret" in the result? That's because a symbol value has its `repr` reflecting how it is initially defined, and will never change, though the value can be assigned to different names as we have demonstrated here.
      }


      {## Interpolated At-Notation
       # - The idiomatic integration usage of private symbols from independent components

Some symbol values are not pleasing for others to import into their own scopes with a direct attribute name, so there is a syntax for an interpolated symbol value to serve as the attribute key, the general syntax is:

  @( <expr-evals-to-symbol-value> )

       #} {;
        {## Interpolated At-Notation #}
        export edh'sym'intpl = bookmark()

        # %% #
        namespace private'force () {
          symbol @passphrase

          method launch'missiles() {
            if 'for~good~profit' != perform @passphrase
            then error( "We don't serve voluntarily!")
            console.info<| "Destroying enemies!!!"
          }

        }

        # %% # This is gonna to fail:
        {@
          private'force.launch'missiles()
        @}

        # %% # This will make it:
        {@
          effect @( private'force.passphrase ) = 'for~good~profit'

          private'force.launch'missiles()
        @}

        # %% # This will work, but not idiomatic:
        {@
          passphrase = private'force.passphrase
          effect @passphrase = 'for~good~profit'

          private'force.launch'missiles()
        @}

        # %% # Why? The same alphanumeric name can usually be used by multiple, independent 3rd party components for some of their symbols, as the software integrator, you'd better think such symbols being their private symbols. Let's add a 2nd component who uses a symbol named `passphrase` too:
        namespace un'peacekeepers () {
          symbol @passphrase

          method auth'attack'by( army'force ) {
            if 'for~world~peace' != perform @passphrase
            then error( "We don't serve evil!")
            army'force.launch'missiles()
          }

        }

        # %% # When all expected effects have to be mixed into your calling scope, the following scription is ugly at best, it can easily confuse future maintainers to introduce bugs:
        {@
          passphrase = private'force.passphrase
          effect @passphrase = 'for~good~profit'
          passphrase = un'peacekeepers.passphrase
          effect @passphrase = 'for~world~peace'

          un'peacekeepers.auth'attack'by( private'force )
        @}

        # %% # While this is the idiomatic way:
        {@
          effect @( private'force.passphrase ) = 'for~good~profit'
          effect @( un'peacekeepers.passphrase ) = 'for~world~peace'

          un'peacekeepers.auth'attack'by( private'force )
        @}
        # %# Ever wondered why symbols are used in such cases? Imagine all the 3rd party components use alphanumerically named effects, then you'll see it's unsolvable mess.

        # Ever wondered why effects are used in such cases? Dynamic Scoped Effects in ƒê is a mechanism for implicit argument passing, which implements effect tracking in the dynamic imperative paradigm (rival to what [Algegraic Effects & Handlers] or [Monads] does in the functional paradigm). Imagine without effects resolution, and the call hierarchy goes rather deeply nested, you'll have to pass the artifacts required by the inner most callee as arguments through every layer of the call, all the way from the outer most call site into the inner most effecting site. Then you'll see how implicit arguments can save the day.

        # Dynamic Effect Tracking is further described later in this chapter
        ; () => edh'eff'tracking # <- follow this bookmark to that section
      }

    }


    {## Quaint Names
     # - Arbitrary string as identifiers

Another interesting usage of at-notation is, that string values can be used in place of symbols, this enables arbitrary strings as attribute identifiers.

     #} {;
      {## Quaint Names #}
      export edh'quaint'names = bookmark()

      # %% # Using string literals is idiomatic for identifiers otherwise not valid alphanumeric names
      ns.@'we-the-people' = 'proud humans'
      dir$ ns
      # %# Note the minus inside the key, they'll be interpreted as subtraction operators if not be in a string key of the at-notation.

      # A string valued attribute can be used in at-notation for the key value, thus manifesting dynamicly named attributes, but you are advised against this style unless absolutely necessary.
      # %% %
      bad'symbolic'looking'key = 'No, No, No!'
      ns.@bad'symbolic'looking'key = 'Confusing :-/'
      dir$ ns
      # %# Note there are cases it is useful, but rare.
    }

  }


  {## Namespace Access
   # - Every entity is a namespace (in general sense)

As every attribute is uniquely identified by a name within an entity, it naturally becomes a namespace, where the identifiers form the set of names. Though the set is highly dynamic, in the sense that an attribute value after a new name can be added at any time, as well as existing names deleted thereof.

Dot-notation is the norm with imperative programming languages, the reason probably lies in the better ergonomics when mutable data structures are manipulated, as the syntactic sugar for field read/write, that exactly the same syntax is used for the target.

FYI in functional programming languages (such as Haskell), the dot (.) is already used as the operator for function composition, there are alternative means of namespacing (such as "lenses") are used instead of dot-notation.

   #} {;
    {## Namespace Access #}
    export edh'ns'access = bookmark()

    {## Obtaining Attribute Value
     # - Read out an attribute value
     #} {;
      {## Obtaining Attribute Value #}
      export edh'attr'read = bookmark()


      {## From Current Scope

A standalone attribute name as an _attribute expression_, just reads such named attribute from current scope (or the first lexical outer scope having it, in case all inner scopes don't have it).

       #} {;
        {## From Current Scope #}
        export edh'scope'attr'read = bookmark()

        # Scoped attribute reading is subject to lexical scoping rules, which is described later in this chapter
        ; () => edh'lexi'scoping # <- follow this bookmark to that section

        # %% # A `scope` wrapper object can be used to evaluate expressions with the wrapped object's backing entity as their current scope:
        scope(ns).eval(expr
          @ns'secret * 2 - c / b
        )
        # %# Expression values and scope wrappers are described later in this chapter
        ; () => edh'exprs'in'scopes # <- follow this bookmark to that section

        # %% # Using alphanumeric name
        scope(ns).eval(expr
          b
        )
        # %% # Using symbolic name
        scope(ns).eval(expr
          @ns'secret
        )
        # %% # Using quaint name
        scope(ns).eval(expr
          @'full-time'
        )
        # %#
      }

      {## Dot-Notation
       # - To address an attribute off a lhs value

At lhs of the dot (.) is the expression evaluates to some value backed by an entity (usually an object), at rhs of the dot (.) is the attribute name (alphanumeric, symbolic, or quaint, as descibed earlier)

       #} {;
        {## Dot-Notation #}
        export edh'dot'notation = bookmark()

        # %% # Using alphanumeric name
        ns.b
        # %% # Using symbolic name
        ns.@ns'secret
        # %% # Using quaint name
        ns.@'full-time'
        # %#

        {## Tentative Form
         # - Allowing absence of the target attribute

It is runtime error if the target attribute doesn't exist in the usual dot-notation, there is a tentative form using the infix (?) and (?@) operator to avoid such errors, but evaluates to `nil` instead.

Especially note that you don't want to directly assign the result of tentative attribute read to a local attribute for later use, because when absent, the resulted `nil` will actually trigger deletion semantics for your local attribute, thus later read will err out.

         #} {;
          {## Tentative Form #}
          export edh'tentative'attr'read = bookmark()

          # Not so different when the target attribute does exist
          # %% #
          ns?b
          # %% # Tentative at-notation
          ns?@ns'secret
          # %% # (?) operator working with a symbolic attribute name
          ns? @ns'secret
          # %% # Tentative quaint name
          ns?@'full-time'
          # %#

          # `nil` will be given out for non-exiting attributes
          # %% # Using an alphanumeric name
          ns?no'such'thing is nil
          # %% # Tentative at-notation
          symbol @never'assign'me
          ns?@never'assign'me is nil
          # %% # (?) operator working with a symbolic attribute name
          ns? @never'assign'me is nil
          # %% # Tentative quaint name
          ns?@'no-such-key' is nil
          # %#

        }


        {## Virtual Attributes
         # - Syntatic sugar appearing as dot-notation

There is special syntactic sugar for non-object values (usually not backed by entities) to be dot-notation addressable.

Special note that virtual attributes are readonly, i.e. can not be assigned as described in the following section.

         #} {;
          {## Virtual Attributes #}
          export edh'virtual'attrs = bookmark()

          # %% # Let's have a dict value, remind its type is `DictType`
          d = { 'name': 'Yue', 'city': 'Chongqing', }
          type(d)
          # %% # Then obtain number of items in it as if there's a `size` attribute on it
          d.size
          # %% # This is possible because ƒê does the translation under the hood, to something like:
          __DictType_size__(d)
          # %% # See the result is the same? Then checkout there really is such a method procedure:
          show$ __DictType_size__
          # %% # Also be noted that
          d.push( 'year', 2021, )
          # %% # is translated to
          __DictType_push__(d)( 'year', 2021, )
          # %% # Now you see the dict can be actually updated this way
          d
          # %# How convenient.

        }

      }

    }


    {## Assigning Attribute Value
     # - Creation/Update/Deletion of attributes
     #} {;
      {## Assigning Attribute Value #}
      export edh'attr'assign = bookmark()

      {## Into Current Scope

Using a standalone attribute name as the assignment target, will create or update the so named attribute of current scope.

       #} {;
        {## Into Current Scope #}
        export edh'scoped'attr'assign = bookmark()

        # Note that scoped attribute assignment can never write to outer scopes, as described in the lexical scoping rules later in this chapter
        ; () => edh'lexi'scoping # <- follow this bookmark to that section

        # %% # A `scope` wrapper object can be used to evaluate expressions with the wrapped object's backing entity as their current scope:
        scope(ns).eval(expr
          @ns'secret * 2 - c / b
        )
        # %# Expression values and scope wrappers are described later in this chapter
        ; () => edh'exprs'in'scopes # <- follow this bookmark to that section

        # %% # Using alphanumeric name
        scope(ns).eval(expr{; # use a block to enclose multiple statements
            e = 2.7 # creation
            b = 5
            e = nil # deletion
        })
        # %% # Using symbolic name
        scope(ns).eval(expr
          @ns'secret = 23323
        )
        # %% # Using quaint name
        scope(ns).eval(expr
          @'full-time' = true
        )
        # %#
      }


      {## Via Dot-Notation
       # - Assign to an attribute of some lhs value

The lhs expression of the assignment operator (=) can be of dot-notation, i.e. the assignment target is so specified as to be the designated attribute by the dot-notation. In this sense, such a dot-notation can be called an *Attribute Addressor*, in both cases it is used for atribute read and attribute assignment.

       #} {;
        {## Via Dot-Notation #}
        export edh'dot'notation'assign = bookmark()

        # %% # Using alphanumeric name
        ns.e = 2.7 # creation
        ns.b = 5 # update
        ns.e = nil # deletion
        # %% # Using symbolic name
        ns.@ns'secret = 23323
        # %% # Using quaint name
        ns.@'full-time' = true
        # %#
      }


      {## Tentative Form
       # - Do assign only when absent

Sometimes you just want to make sure a certain attribute is in scope, and would rather not overwrite what's already there.

Also at times you know an attribute is certain to be there, but the ƒê source code around can not tell the IDE (or linter etc.) about its existence (or type for intellisense completion etc.), then you can write a pseudo assignment in the tentative form, just for informative purpose.

Note that tentative assignment doesn't work via dot-notation.

       #} {;
        {## Tentative Form #}
        export edh'tentative'assign = bookmark()

        # %% # It evaluates to the existing value if the target attribute already exists
        scope(ns).eval(expr
          b ?= 37
        )
        # %% # See it's not changed
        ns.b
        # %% # Will be created as a new attribute of current scope if does not exist already
        scope(ns).eval(expr
          e ?= 2.7
        )
        # %% # See it's not changed
        ns.e
        # %#

        # %% # Note that in cases a possibly absent attribute is read just occasionally, you may really want to write the code in this pattern:
        ns.e = nil # delete it for sure absence
        v = 9.8 * (ns?e or 2.7)
        # %#
      }


      {## Syntactic Sugar in Assignment
       # - Shorthands for updating assignments
       #} {;
        {## Syntactic Sugar in Assignment #}
        export edh'assign'sugar = bookmark()

        # %% # This expression:
        ns.b += 1
        # %% # is translated to
        ns.b = ns.b+1
        # %% # This expression:
        ns.b /= 3
        # %% # is translated to
        ns.b = ns.b/3
        # %# and et cetera
      }

    }

  }

}


{## Values, and Really Special Ones
 # - Everything is a value in ƒê

Some values are both syntatically and semantically special, with respect to topics of Terminology, Equality, and Nothingness.

 #} {; import * './advanced/vals' # <- details of ƒê Value System
  {## Values, and Really Special Ones #}
  export edh'values'with'speciality = bookmark()

  # How and why everything is a value
  everything'is'a'value # <- follow this bookmark to that section in ƒê Value System


  {## Named Values / Term Definitions
   # - The named is the mother of ten thousand things

A value in ƒê can have an alphanumeric name assigned to it, forming a named value, or so called term definition.

Note the named version of a value may or may not "equal" to the original version of the value, with respect to which definition of "equality" is used. Multiple criteria of "equality" are described in later sections of this chapter.

   #} {;

    # %% # In ƒê code, a named value is defined by evaluation of the (:=) operator
    ùõë := 3.14
    # %# The (:=) operator has a side-effect to define an attribute into current scope, using the term name as attribute name, with the named version of the value.
    # Note this side-effect is ceased in a pure context, which is described later in this chapter
    ; () => edh'pure'ctx # <- follow this bookmark to that section

    # %% # A term's name is its usual representation
    repr$ ùõë

    # %% # After some manipulation (e.g. arithmetics), it may no longer be a term, even the ultimate value are identical to the original value
    repr$ ùõë * 1 # Now just an immutable value of DecimalType

    # %% # Type of a term comes from its original value
    type( ùõë )

    # %% # ƒê knows it being a term, and can show that accordingly
    show( ùõë )

    # %% # Otherwise it's can be used just like the original value
    r = 1.58
    C = 2 * ùõë * r
    # %#
  }


  {## Equalities
   # - Some values can be more "equal" than others
   #} {;
    {## Equalities #}
    export edh'equalities = bookmark()


    {## Identity Equality
     # - All values are assumed to have identities

ƒê assumes the uniqueness of all values to some degree that every value can be tested for a certain conclusion of whether it poses the same identity of another value, thus identity equality can always be tested for any two given values.

     #} {;
      {## Identity Equality #}
      export edh'id'eq = bookmark()

      # %% # Identity equality is tested with the (is) operator:
      true is true
      # %% # The negated (is not) operator gives proper English feeling:
      true is not false
      # %% # while being equivalent to:
      not ( true is false )
      # %#


      # Immutable values can be uniquely identified by its unchangable value, regardless of its original source.
      # %% # E.g.
      3 * 7 is 21
      # %% # The complex ArgsPackType is immutable after all, though the order of arguments is siganificant in identity test. Especially note named arguments are ordered by original occurrence, not by sort order of the names or any otherwise.
      ; ( a= 2, 3, 5, b= 7, ) is ( 3, a= 2, b= 7, 5, )
      # %% # Difference in arg order, either that of positional args or named args, change an apk's identity
      ; ( a= 2, 3, 5, b= 7, ) is ( 3, b= 7, 5, a= 2, )
      # %#


      # Mutable values need other means of identity, that usually can be the (imagined) location of the block in memory, to where overwriting goes when the value is to be changed. The reference semantics is a useful intuition for this, that two reference values are identical when they point to the same memory location, thus changes through one of the reference will be visible to the other reference.
      # %% % Two separate lists can never be identical
      ; [ 3, 2, ] is [ 3, 2, ]
      # %% # Only references copied from existing ones can
      l = [ 3, 2, ]
      l' = l
      l is l'
      # %# Dicts are in similar cases w.r.t. identity equality.


      # A value serving as an immutable container, such as an apk or a pair, may contain mutable values as its items, the identity equality cascades into those items intuitively.


      {## Object Identity
       # - The magic `__id__` attribute

Each object carries a unique identifier per constructed, but an object can state an alternative identity by providing a magic `__id__` attribute. Especially note that given objects are mutable per se, there is no technical limitation for the `__id__` attribute of an object to change over lifetime of the object, but such changes will induce undefined behavior, e.g. when the object is used as a dict key.

       #} {;
        {## Object Identity #}
        export edh'obj'identity = bookmark()

        # The `data` class will automatically install a magic `__id__` attribute for each instance, so iif constructed for the same class, and with identical data fields, multiple such instances will be considered identical, despite they carry different intrinsic unique object identifiers per constructed.

        # %% # For a simple example
        data P(x, y) pass

        # %% #
        p = P(3, 2)

        # %% # The alternative identity of a data class instance is an apk of the data class object and all the named data fields
        p.__id__

        # %% # You can see what the identifier is finally reduced to
        id(p)

        # %% # So these objects will appear identical
        p is P(3, 2)
        # %#

      }
    }


    {## Instant Equality
     # - The common sense of "equality"

The common sense of "equality" assumes snapshot semantics when comparing two mutable values, i.e. the equality test would happen as if time has stopped flowing, so the stored data of such values can be compared at the instant of time when the comparison is requested.

     #} {;
      {## Instant Equality #}
      export edh'instant'eq = bookmark()

      # %% # Instant equality is tested with the (==) operator:
      [ 3, 2, ] == [ 3, 2, ]
      # %# See they are considered equal now?


      {## Object Equality
       # - The magic `__eq__()` method

Objects can implement the magic `__eq__()` method to override instant equality test semantics in cases it is involved.

       #} {;
        {## Object Equality #}
        export edh'obj'equality = bookmark()

        # %% # For a simple example
        class D {
          method __init__(x as this.x, y as this.y) pass
          method __eq__(other) case other of {
            # A match pattern is used here,
            # it does instance check with field extraction at the same time
            { D(x= otherX, y= otherY) } -> {
              this.x == otherX and this.y == otherY
            }
            _ -> false
          }
        }

        # %% # So these two distint objects can be considered instantly equal
        D(3, 2) == D(3, 2)

        # %% # While they are not identically equal
        D(3, 2) is not D(3, 2)

        # %# Note that an object can state an alternative identity with its magic `__id__` attribute, we didn't implement that in above.
      }

      # Note that identity equality always implies instant equality, but not vice versa.
    }


    {## Namewise Equality
     # - Equality w.r.t. how values are named

Some instantly equal values can be differently named, in the sense of original value, they are considered instantly equal too.

     #} {;
      {## Namewise Equality #}
      export edh'namely'eq = bookmark()

      # %% # Take this example:
      PhoneNo := 35925
      AccountNo := 35925
      # %% # They are not identical because named differently:
      AccountNo is PhoneNo
      # %% # But surprisingly:
      AccountNo == PhoneNo
      # %# See they are considered instantly equal? That's a pitty rendering the (==) operator less meaningful in certain cases.

      # %% # Fortunatelly for value matching branches, the name of values would make differences, so they are said to be namely equal, iif they have the same name, and share an instantly equal original value.
      case AccountNo of {
        35925 -> "No way, original version of a value won't match any named version!"
        PhoneNo -> "No way, the value names don't match!"
        ; (AccountNo := 35925) -> "Yeah, this should work!"
      }
      # %# Branches are described later in this chapter
      ; () => edh'branching # <- follow this bookmark to that section

      # TODO add named mutable values as example, to demonstrate the necessarity of namely equal semantics.

    }

  }


  {## Null Test
   # - The observable nothingness

All values are assumed to be able to tell if it is truthful, or on the contrary, falsy, that eternally for immutable values, and instantly for mutable values. There are a few control flow mechanisms relying on this ability to carry out conditional executions, e.g.:

 * if <conditional> then <consequence> else <alternative>
 * while <conditional> <keep-doing>
 * <prefered-result> or <alternative-replacement>
 * <prerequisite> and <proceeds>

`null()` is used to explicitly perform _null_ tests and give out true/false accordingly, while the control flows above would perform _null_ tests implicitly.

   #} {;
    {## Null Test #}
    export edh'null'test = bookmark()

    # %% #
    null$ 3
    # %%
    null$ 0
    # %%
    null$ 'Hello'
    # %%
    null$ ''
    # %%
    null$ true
    # %%
    null$ false
    # %#

    # %% #
    data Blocker(letgo= false) {
      method __null__() not this.letgo
    }
    blocker = Blocker(true)
    # %# Data classes are described later in this chapter
    ; () => edh'data'classes # <- follow this bookmark to that section

    # %% # Repeat this cell after toggled blocker's status
    if blocker
    then "You've been blocked!"
    else "Proceed!"

    # %% # Toggle the blocked state
    blocker.letgo = not blocker.letgo
    # %#

  }


  {## Notable Immutable Values
   # - Some special values those immutable
   #} {;
    {## Notable Immutable Values #}
    export edh'notable'values = bookmark()

    {## Nothingness
     # - Special nullabilities
     #} {;
      {## Nothingness #}
      export edh'nullable'values = bookmark()

      # %% # `nil` is the ultimate nothingness
      nil
      # %% # It deletes attributes when assigned as the value
      a = nil # to delete attribute named `a` from current scope

      # %% # `None` is just `nil` named "None"
      show$ None
      # %% # `Nothing` is just `nil` named "Nothing"
      show$ Nothing
      # %#
    }


    {## Boolean Values
     # - To be or not to be
     #} {;
      {## Boolean Values #}
      export edh'bool'values = bookmark()

      # %% # `true` is the boolean value indicating truthful result
      show$ true
      # %% # `false` is the boolean value indicating falsy result
      show$ false
      # %#
    }


    {## Numeric Values
     # - Some special numbers
     #} {;
      {## Numeric Values #}
      export edh'numeric'values = bookmark()

      # %% # `nan` means Not-A-Number, but of DecimalType, which is a numeric type
      show$ nan
      # %% # `nan` is technically the result of 0 divided by 0
      0/0 is nan
      # %% # Except for identity equality, a nan value never equals to any value, including itself
      nan == nan
      # %# See nan is unequal to itself?

      # %% # `inf` is infinity
      show$ inf
      # %% # Negate it by the prefix minus (-) operator to get negative infinity
      show$ -inf
      # %% # Divided by 0, a finite number will produce infinitity
      ; -5 / 0
      # %#
    }


    {## String Values
     # - Immutable text
     #} {;
      {## String Values #}
      export edh'strings = bookmark()

      # %% # Take this simple example
      s = 'abcdef'

      # %% # Both the (++) and (+) operator will concatenate string operands
      # Note the syntactic sugar ` x ++= y ` expands to ` x = x ++ y `
      s0 = s
      s ++= '#defabc'
      s

      # %% # Let's cut a part (a substring) from it
      # More about pattern matching and string cut patterns later
      ; () => edh'str'cut'pattern # <- follow this bookmark to that section

      case s of { s1 @< '#' >@ _ } -> s1

      # %% # The result hapens to be equal to the original value before we concatenated it with more text
      s1 == s0

      # %% # Actually they are identically equal, as strings are immutable, the identity of a string value is solely determined by its value
      s1 is s0

      # %#
    }


    {## Defaulting Values
     # - Not/Applicable is 1st class value
     #} {;
      {## Defaulting Values #}
      export edh'defaulting'values = bookmark()

      # %% # `NA` means Not/Applicable, indicating a result defaulting to `nil`, which technically can't be defaulted, so will be propagated until caught as an error condition.
      show$ NA

      # Artitrary defaulting values can be created dynamically, with an expression providing the value used for default. Such values are usually returned from operator procedures, so objects can override their behavior with magic methods, when operated by the operator, while a default implementation is provided by the operator procedure, which is effective when no magic methods present.
      # %%
      operator 0 (+*+) (lhv, rhv) {
        return default lhv ++ ' *** ' ++ rhv
      }
      # %%
      3*7 +*+ 'is a lucky number'

      # %%
      class N {
        method __init__( val as this.__repr__ ) pass
      }

      class M { extends N
        method (+*+) (other) {
          return this ++ ' --- ' ++ other
        }
      }
      # %%
      n = N(3*7)
      m = M(3*7)
      # %%
      n +*+ 'is a lucky number'
      # %%
      m +*+ 'is a lucky number'
      # %#

      # %# Applicability & defaulting semantics are advanced topics described in another chapter
      ; () => {; import * './advanced/appl' # <- navigate to there for elaboration
        edh'na'semantics # <- follow this bookmark to the specific section there
      }
    }


    {## Ordering Values
     # - Result of comparison
     #} {;
      {## Ordering Values #}
      export edh'ord'values = bookmark()

      # %% # `LT` means less-than, indicating the result of comparision
      show$ LT
      # %% # `GT` means greater-than, indicating the result of comparision
      show$ GT
      # %% # `EQ` means equal, indicating the result of comparision
      show$ EQ
      # %#
    }


    {## Notable Value Types
     # - Some types of values worth special mention
     #} {;
      {## Notable Value Types #}
      export edh'notable'types = bookmark()

      {## Rational Decimal Number
       # - Native numbers are rational decimals as familiar in real life
       #} {;
        {## Rational Decimal Number #}
        export edh'rat'decimal = bookmark()

        # %% # Numbers can contain arbitrary number of decimal digits, more digits just take more memory to store them, the precision will never by truncated
        x = 1234567890.123456789012345678901234567890123456789012345678901234567890123456789

        # %% # even after arithmetic calculations
        x * 3

        # %% # Noticed it? When displayed, scientific notation will be used, but numeric values remains identical regardless of different representations
        123.45 is 1.2345e2

        # %% # Non-canonical scientific notations work too
        12.345e1 is 0.12345e3

        # %% # But scientific notation won't be used when the exponent is less than 5 (and > -5)
        12345.6789 ++ ' vs ' ++ 123456.789

        # %% # Integral numbers are no different
        12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789

        # %% # Fractional numbers are reduced but never approximated
        12 / 14

        # %% # Unless you explicitly truncate it
        ; ( 12 / 14 ).trunc
        # %# Note negative numbers will be truncated toward zero (instead of negative infinity)

        # %% # Or round it
        ; ( 12 / 14 ).round
        # %# Note negative numbers will be rounded toward zero (instead of negative infinity)

        # %% # Half rounds to even
        1.5.round
        # %% #
        2.5.round
        # %# see: https://en.wikipedia.org/wiki/Rounding#Round_half_to_even

        # %% # Improper fractions will be kept as is (not turned into mixed fraction) after reduced
        235 / 85

        # %% # Integral division can be done with the (//) operator
        235 // 85

        # %% # A trick to approximate with 5 digits after the decimal point
        ; ( 1e5 * 235 / 85 ).round / 1e5

        # %% # There's a builtin method using this trick
        ; (235/85).toFixed(5)

        # %#

      }


      {## ArgsPack (apk) - the Super Tuple
       # - The super type of tuple with named elements

We already described ArgsPack in the section for syntax of arguments packing, actually the apk type is a super type of the "tuple" type, which is well known in many programming languages.

An apk with only positional arguments carries exactly the same semantics of a "tuple".

An apk with only named arguments is comparable to the "namedtuple" in Python, but it is structurally typed in ƒê, while "namedtuple" is nomially typed in Python per se.

Then in ƒê positional arguments and named arguments can be combined together in a single apk.

       #} {;
        {## ArgsPack (apk) #}
        export edh'apk = bookmark()

        # %% # ArgsPack values are immutable, two apks are identically equal only if all arguments are identically equal, regarding the order of appearance
        ; ( 3, 2, 5, x= 9, y= 7, ) is ( 3 :> ( 2, 5, x= 9, y= 7, ) )

        # %% # Especially note that the order of appearance for named arguments matters in equality test, observing the following two apks are not equal
        ; ( 3, x= 9, y= 7, ) is ( 3, y= 7, x= 9, )

        # %% # The insertion order of a named argument is determined by its first appearance
        ; ( x= 9, y= 7, x= 11, ) is ( x= 11, y= 7, )
        # %% #
        ; ( x= 9, y= 7, x= 11, ) is not ( y= 7, x= 11, )

        # %% # Note about nil's deletion semantics in apk construction
        ; ( x= 9, y= 7, x= nil, ) is ( y= 7, )

        # %% # It is useful when unpacking some unknown apk, with some names undesirable
        apk'from'elsewhere = ( x= 9, y= 7, )
        ; ( ***apk'from'elsewhere, x= nil, )

        # %#

        # Idiomatic usage has already been covered in a previous section about arguments packing
        edh'args'un'packing # <- follow this bookmark to that section
      }


      {## Vector
       # - Mutable array with preliminary vectorization

Vector is a mutable type, optimized for index based random access, and supports preliminary vectorization with several operations get broadcasted element-wise.

       #} {;
        {## Vector #}
        export edh'vector = bookmark()

        # %% # Vector constructor takes all positional arguments, so arg unpacking and apk comphrehension can be used to initialize a Vector
        v = Vector( *()=< for i from range(10) do i )

        # %% # A Vector can be sliced with a <start>:<stop> pair
        # Note that <start> is inclusive and <stop> is exclusive, which is the same syntax and semantics as in Python
        v[3:8]

        # %% # Reversed slicing works too, but notice the inclusive/exclusive semantics
        v[7:2]

        # %% # Custom step can be specified
        # Note this is still the same syntax and semantics as in Python
        v[3:8:2]

        # %% # But you'd make sure the stepping is monotonic, this will fail e.g.
        v[7:2:2]

        # %% # This is the correct spec
        # Note a subtle difference from Python here, minus (:) has to be separated from colon (:), or edh
        v[7:2: -2]

        # %% # Constructing a simple vector
        v = Vector( 3, 2, 5, )

        # %% # Broadcasted (+) operation
        v + 100

        # %% # The same when at rhs
        100 + v

        # %% # Broadcasted (++) operation
        v ++ 5

        # %% # The same when at rhs
        5 ++ v

        # %% # Broadcasted comparison
        v >= 3

        # %% # Masking with comparison result
        v[ v >= 3 ]

        # %% # Conditional update masked with comparison result
        v[ v >= 3 ] += 100
        v

        # %% # Another conditonal update example with string operation
        v[ v > 10 ] ++= ", which is too large"
        v

        # %% # TODO impl. and demo. `.map()` `.update()` etc.

        # %% # List out all its methods
        dir$ Vector
        # %# Note many methods in it are magic methods
        ;() => edh'magic'mths # <- follow this bookmark to the section describing what's magic methods and how it works
      }


      {## List
       # - Singly linked prepend cons list

List is a mutable type, optimized for prepend and sequential scan.

       #} {;
        {## List #}
        export edh'list = bookmark()

        # %% # Take this simple example
        l = [ 3, 2, 5, ]

        # %% # `push()` and `pop()` can be use with a list for "stack" semantics
        h = l.pop()
        'After ' ++ h ++ ' popped, l now is: ' ++ l
        # %% #
        l.push(7)
        l

        # %% # The prepand (:>) operator does the same thing to a list as `push()`
        9 :> l

        # %% # List is ploymorph, values of different types can be stored in the same list
        'Some text' :> l

        # %#
      }


      {## Dict
       # - Hash map with keys of identity equality

Dict is a mutable type, optimized for O(1) key lookup as well as sequential scan.

Especially note that the scan order of dict entries is insertion order, not key sorting order.

Also note that identity equality is used for keys of a dict, that means a dict can contain multiple instantly equal keys those not identical. Especially note that as a result, even if you implement the `__eq__()` magic for objects (responding to instant equality tests), those objects with instant equal semantics won't overwrite eachothers, when serving as keys in a dict. You may want to provide the magic `__id__` attribute (should be immutable though) for each object with alternative identity, for them to serve as proper dict keys.

       #} {;
        {## Dict #}
        export edh'dict = bookmark()

        # %% # Take this example
        d = { 'c': 3, 'a': 2, 'b': 5, }

        # %% # Arguments packing syntax can be used with the `dict()` constructor
        # When all keys are strings or symbols, it's more convenient to create a dict like this
        d' = dict( c= 3, a= 2, b= 5, )

        # %% # Each dict is distinct when separately constructed
        d' is not d

        # %% # Two dicts can be instantly equal if all entries are instantly equal, regardless of the order of appearance of the entry keys
        d'' = dict( c= 3, b= 5, a= 2, )
        d'' == d
        # %% # Though their reprs are different
        repr(d'') != repr(d)

        # %% # Note about nil's deletion semantics in dict construction
        { 'c': 3, 'a': 2, 'b': 5, 'a': nil, } == { "c": 3, "b": 5, }

        # %% # Both the key and the value can be computed dynamically, make use of that and take care
        { 'c': 3, ( 'a' ++ 'bc' ): 2, 'b': 5, ( 'ab' ++ 'c' ): ( void 3*7 ), }

        # %% # `push()` and `pop()` can also be use with a dict
        d = dict( c= 3, a= 2, b= 5, )
        v = d.pop( 'a')
        'After a=' ++ v ++ ' popped, d now is: ' ++ d

        # %% #
        d.push( 'a', 9 )
        d

        # %% # The prepand (:>) operator does the same thing to a dict as `push()`
        # But note in this case the semantics is actually append instead of prepend
        ; ( 'd', 'More data' ) :> d

        # %% # 2 pair values can also be used to specify a dict entry, in addition to 2 "tuple" (apk with 2 positional arguments)
        e = 'e': 'Extensive data'
        e :> d

        # %#
      }


      {## Pair
       # - Singly linked append cons list

Pair is an immutable type, meant to be used as range or dict entry specifiers.

Pair values are constructed with the infix (:) operator.

       #} {;
        {## Pair #}
        export edh'pair = bookmark()

        # %% # Pair values are immutable, two pairs are identical if all elements are identical, regardless of whether separately constructed
        let (a,b,c,) = (3,2,5)
        ; ( 3:2:5 ) is ( a:b:c )

        # %% # Note the (:) operator has a precedence of 2, which is rather low, so parenthese quoting is required as in above
        show( (:) ) ++ ' vs ' ++ show( (is) )

        # %% # Also note about its left-associativity
        ; ( 3:(2:5) ) != ( (3:2):5 )

        # %% # Though they have identical repr
        repr( 3:(2:5) ) == repr( (3:2):5 )
        # TODO maybe the repr should be fixed to avoid confusions

        # %#
      }


      {## Event Sink
       # - Rendezvous point of events
       #} {;
        {## Event Sink #}
        export edh'event'sink'values = bookmark()

        # %% # An event sink is a broadcasting channel, a new one will be created each time the `sink` literal is evaluated
        assassinate'signal = sink
        show$ assassinate'signal

        # %% # Arbitrary values (each as an event) can be sent into an event sink, i.e. to publish one event at a time, using the (<-) operator:
        assassinate'signal <- 'stab'

        # %% # But the events will be just discarded (having no effect) by default, though anyone can iterate events published into it at anytime, we spawn a new thread to do the iteration:
        go for act from assassinate'signal do console.warn<| "I'm going to " ++ act ++ " you!"
        # %# See the warning from background? An event sink is by default lingering, meaning the last event into it will be saved and kept being observed until the next event replaces it.

        # %% # Let's publish another event there:
        assassinate'signal <- 'shoot'
        # %# Remind that the publishing can be repeated, try run the "stab" cell again.

        # Events can be *perceive*d by any thread, the perceiver body is executed with the published event as matching target
        # %% #
        perceive assassinate'signal { act } -> {
          console.info<| "I'm assassinated via " ++ act
        }
        # %# Then run the publishing cells above again, to see more messages logged.
        # Branches with pattern/value matching are described later in this chapter
        ; () => edh'branching # <- follow this bookmark to that section

        # If the perceiver evaluates to value of a `break` statement, that thread will be terminated.

        # %{ # Upon termination of a thread, some actions can be *defer*ed to execute:
        defer {
          # %%
          console.print$ "Here's my last words ..."
          secRemains = 10
          for _ from console.everySeconds(1) do {
            case secRemains -= 1 of {
              7 -> console.print( "\rPlease let me die a good death." )
              5 -> console.print( "\rThat's all I want." )
              4 -> console.print( "\rFarewell!" )
              0 -> {
                console.print( "\27[A")
                break
              }
              _ -> console.print( '\r...' ++ secRemains, eol= '\r', )
            }
          }
          # %#
        }
        # %}

        # Be prepared to loss your ƒê terminal session, for the main thread will be terminated, thus the program will halt.
        # %% # The perceiver performs pattern/value matching, here we implement it so only shooting can make the kill, you know what to do next.
        perceive assassinate'signal.subseq 'shoot' -> {
          console.fatal<| "I'm hit!"
          break # this being the final result, would terminate the thread installed this perceiver
        }
        # %# Notice the `.subseq` used above, it obtains a non-lingering version of the event sink, so the perceiver against it will only respond to subsequent events, and so you have to run one of the publishing cells above to trigger the assassination. Good luck!

      }

    }


    {## Index Values
     # - 0-based numeric index, with special range slicers

Note that usual numeric index in ƒê is 0-based, carrying _offset_ semantics as in many popular programming languages such as C, Java, Python, Go etc. While there are other languages like Fortran, R, Julia, MATLAB, Smalltalk, Wolfram etc. use 1-based index carrying _counting_ semantics.

     #} {;
      {## Index Values #}
      export edh'index'vals = bookmark()

      # %% # Let's take a `Vector` which is indexable, e.g.
      v = Vector( * ()=< for i from range(5) do i )
      # %#

      # %% # Individual elements can be obtained via a numeric index
      v[2]

      # %% # Elements also assignable by index
      v[2] = 555
      v

      # %% # `All` is `true` named `All`
      show$ All

      # %% # `All` can be used to denote every elements as a whole
      v[All] = (5,4,3,2,1,)
      v

      # %% # Actually, when the index is totally omitted, `All` is implied
      v[] = (1,2,3,4,5,)
      v[]

      # %% # `Any` is `true` named `Any`
      show$ Any

      # %% # `Any` can be used to denote every elements in its own right
      v[Any] = 5
      v

      # %% # This will fail as every elements as a whole doesn't match a single element semantically
      v[All] = 5

      # %% # This is okay and as many elements will be overwritten
      v[All] = (3,2,1,)
      v

      # %% # This is totally different semantics, see if the result surprises you
      v[Any] = (3,2,1,)
      v

      {## Slicers
       # - Pairs used as range specifiers

2~3 pairs carry range slicer semantics, the effective syntax is:

  <start>:<stop>[:<step>]

Especially note that <stop> in an ƒê slicer is exclusive, so in case <start> and <stop> is equal, it'll slice nothing out of a container.

Otherwise, <step> defaults to 1 when <stop> is greater than <start>; or -1 when <stop> is less than <start>.

       #} {;
        {## Slicers #}
        export edh'slicers = bookmark()

        # %% # Taking this Vector e.g.
        v = Vector( * ()=< for i from range(10) do i )

        # %% # Slice it since 2, and up to 8, stepping 2
        v[ 2:8:2 ]

        # %% # Or the reversed direction
        # Note the `:` and the `-` as the negating sign must be separated by some space, or it'll be parsed as application of the (:-) infix operator
        v[ 6:1: -2]

        # %% # Negative <start> and <stop> can be used to denote counting from the end toward the beginning
        v[ -5 : -2 ]

        # %% # When used in slicers, `Any` and `All` are interchangable, e.g.
        v[ 2:Any ]

        # %% #
        v[ -2:All ]

        # %% #
        v[ All: -3 ]

        # %% #
        v[ Any:3 ]

        # %#
      }

    }

  }

}


{## Control Flows
 # - Handling variety of input

A computer makes no sense if every distinct input has to be processed by an associated unique program. To be actually useful, a computer (at times, even a single program on a computer), needs to accept input data of sufficient variety. So some level of abstraction has to be there, this calls for polymorphism.

That means a program would need to go different execution branches w.r.t. the input data, and in practices, such conditional branchings can be seen allover the source code of computer programs. In this section, you'll see what mechanisms for this purpose are supported by ƒê.

 #} {;
  {## Control Flows #}
  export edh'ctrl'flows = bookmark()


  {## if-then-else Binary Branching
   # - Two choices per one condition test

The general syntax is:

  if <conditional> then <consequence> else <alternative>

Being an expression as a whole, it's supposed to give out a single result value when evaluated. The `else` part can be omitted, then the whole expression evaluates to `nil` if the condition doesn't hold.

Side effects are very well expected in many cases, while in other cases only a pure result is expected.

   #} {;
    {## if-then-else Binary Branching #}
    export edh'if'then'else = bookmark()

    # %% # Idiomatic short forms
    if 3 < 2
    then "No way this get shown!"
    else "Of course!"
    # %#

    # %% # Idiomatic long forms
    if 3*7 is 21 then {
      console.print$ "That's so true!"
    } else {
      console.print$ "No way arithmetics fail!"
    }
    # %#

    # %% # Without an `else` part:
    nil is (
      if 3*7 > 22 then "You'd never see this!"
    )
    # %#

  }


  {## Blocks, Matching Branches, Fallthrough
   # - Forming a hierarchy of control elements

A block is any number of statements enclosed by a pair of curly braces, it is an expression, and evaluates to the result value of last statement executed in it, in case that statement is an expression statement, or just `nil` will be the execution result.

Branch expressions defined by the arrow (->) operator can appear in a block, to jump out of the block without evaluation of subsequent statements following it, iif the lhs expression of the branch is concluded as a match, in which case the rhs expression of the branch becomes the last statement of the block execution, thus giving out the block's evaluation result value as it is evaluated. There is a special case though, if such a rhs expression evaluates to the value of `fallthrough` statement, subsequent statements following the branch will continue to be executed as if the branch has not been a match. While non-match branches won't have their rhs expression evaluated/executed at all.

The lhs expression is concluded to be a match or not in 3 different ways, with different syntax to manifest the desired handling:

 * A valid pattern matching the contextual matching target value
 * A guard condition with truethful or falsy result
 * A value as evaluated, whether it namely-equals to the contextual matching target value

Blocks can be nested, as well as for blocks to be body parts of other control flow constructs, arbitrary hierarchy of control flow structures can be composited.

   #} {;
    {## Blocks, Matching Branches, Fallthrough #}
    export edh'branching = bookmark()

    {## case-of Targeting
     # - Setting the target to match

The case-of expression computes a value from the specified target expression, then with the result value being the contextual matching target, evaluate the specified block of expressions (or a single expression in rare cases), as to become the result of the whole case-of expression. Note that after the case-of expression is evaluated, the contextual matching target is restored, for evaluation of subsequent statements following the case-of expression.

     #} {;
      {## case-of Targeting #}
      export edh'case'of = bookmark()

      # %% #
      case 3*7 of {
        21 -> "Pretty that!"
        _ -> "Is arithmetics dead?"
      }
      # %#

      {## `case true of { }`
       # - Freeform conditional branches

Matching against `true` has a desirable property that logical conditional expressions can be used right away at lhs of the branches.

Technically, `true` is the initial matching target, unless overridden by an outer case-of. But it is idiomatic to explicitly quote around freeform branches, with a `case true of { }` block, because that's foolproof to later copy/cut & paste the code segment to somewhere within some other case-of block.

       #} {;
        {## `case true of { }` #}
        export edh'freeform'cond'branches = bookmark()

        # %% #
        case true of {
          3 < 2 -> 'No way!'
          console.logLevel <= console.debug -> 'We are debugging!'
          _ -> "Nop, all good."
        }
        # %#

      }

    }


    {## Pattern Matching
     # - With a pattern expression at lhs of a branch

Except the very special "wild match" pattern, all existing pattern expressions are enclosed in a pair of curly braces, this is a design guideline for even future pattern syntaxes to be extended, such an intuition should sustain, so cognitive overhead in this regard is kept low.

     #} {;
      {## Pattern Matching #}
      export edh'pattern'matching = bookmark()

      # There is an advanced topic describing various matching patterns in another chapter
      ; () => {; import * './advanced/patterns'
        edh'matching'patterns # <- follow this bookmark to the section there
      }

      # Let's briefly show the most useful patterns by example here

      {## Wild Match Pattern
       # - Always match
       #} {;
        {## Wild Match Pattern #}
        export edh'wild'pattern = bookmark()

        # %% #
        case 3*7 of {
          { n } | n > inf -> 'No way! Bigger than infinity??'
          _ -> 'This branch always match!'
        }
        # %% # Technically there is no need of such a pattern:
        case 3*7 of {
          { n } | n > inf -> 'No way! Bigger than infinity??'
          "It doesn't have to be a branch anyway!"
        }
        # %# But it is just idiomatic to write a last branch like that.
        # It feels familiar to Haskell btw.
      }

      {## Wild Capture Pattern
       # - Capture a non-nil matching target as local attribute
       #} {;
        {## Wild Capture Pattern #}
        export edh'wild'cap'pattern = bookmark()

        # %% # Suppose there's this procedure possibly returning nil result
        method evil'amp(n) case true of {
          n < 5 -> nil
          n * 10
        }
        # %# Note it is really bad to have nil as a possible result among other return values, don't do this in realworld!

        # %% # Prepare a input that would result in nil
        n = 3
        # %% # Or for non-nil result
        n = 7
        # %#

        # %% # It is idiomatic to work with such a computation like this:
        case evil'amp(n) of { result }
        -> 'Amplified result is: ' ++ result
        # %% # Instead of this safe but less optimal algorithm:
        if evil'amp(n) is not nil
        then 'Amplified result is: ' ++ evil'amp(n)
        # %# The major problem with above cell is the computation will be performed twice when not nil, besides a bit more imperative (contrasting to declarative) feeling.

        # %% # And this is a plain wrong solution:
        result = evil'amp(n)
        'Amplified result is: ' ++ result
        # %# Can you figure out why? Set `n = 3` and try it, you'll see.

        # Godforbid it for any procedure implemented like the `evil'amp()` above, but there will definitely be expressions to have nil mixed into normal non-nil results (e.g. `.mrv` of an event sink), so the wild capture pattern is your best friend at all times.

        # %% # Here is an alternative, correct solution, but less elegant:
        result = evil'amp(n) or nan
        'Amplified result is: ' ++ result
        # %# Also you'll need larger change (as well with tendency of probably unexpected double-evaluation without enough care taken), when later the nil case needs to be handled
      }


      {## Any-Of Pattern
       # - Namely equal to any of the listed value
       #} {;
        {## Any-Of Pattern #}
        export edh'any'of'pattern = bookmark()

        # %% #
        c = 'b'
        # %% #
        c = 'f'

        # %% #
        case c of {
          {[ 'a', 'b', 'c', ]} -> 'Early coming.'
          _ -> 'Late coming.'
        }
        # %#
      }


      {## Tuple Pattern
       # - Expect a fixed number of positional arguments
       #} {;
        {## Tuple Pattern #}
        export edh'tuple'pattern = bookmark()

        # %% #
        p = ( 3, 2, 5, )
        # %% #
        p = ( 3, 7, )

        # %% #
        case p of {
          {( x,y,z, )} -> "3D coordiante: x= " ++ x ++ " y= " ++ y ++ " z= " ++ z
          {( x,y, )} -> "2D coordinate: x= " ++ x ++ " y= " ++ y
        }
        # %#
      }


      {## Data Object Pattern
       # - Extract fields from data objects
       #} {;
        {## Data Object Pattern #}
        export edh'data'obj'pattern = bookmark()

        # %% #
        data Point(x, y) pass
        data Circle( r, c= Point(0,0), ) pass
        data Rectangle(w, h, o= Point(0,0), ) pass
        # %% #
        shape = Circle(5)
        # %% #
        shape = Rectangle( 7, 2, Point(3, 1), )
        # %#

        # %% #
        case shape of {
          { Circle( r, c = center, ) }
          -> "Circle at " ++ center ++ " w/ radius " ++ r

          { Rectangle( w= width, h= height, ) = rect }
          -> "Rectangle covering area " ++ width*height ++ " - " ++ rect
        }
        # %#
      }


      {## String Cut Pattern
       # - Extract prefix and/or suffix from string with matched counter part
       #} {;
        {## String Cut Pattern #}
        export edh'str'cut'pattern = bookmark()

        # %% #
        url = "https://www.haskell.org/platform/mac.html"
        # %% #
        case url of { scheme @< '://' >@ host'and'path }
        -> "The page is over " ++ scheme
        # %% #
        case host'and'path of { authority @< '/' >@ path }
        -> "The host is " ++ authority ++ ", the path is " ++ path
        # %% #
        case path of { 'platform/' >@ page'name }
        -> case page'name of { platform @< '.html' }
        -> "The platform is " ++ platform
        # %#

        # Actually, there is a URI class comes with the default batteries
        # %%#
        case url of { URI(scheme, authority, path,) }
        -> "Over " ++ scheme ++ ", the site " ++ authority ++ " provides " ++ path
        # %#

        URI.__match__ # <- goto its definition for a comprehensive example
      }

    }


    {## Value Matching
     # - With a vanilla expression at lhs of a branch

Other forms of expression at lhs of a branch are all considered a value expression, the result value evaluated from such a LHS expression is compared to the contextual matching target value with namewise equality semantics.

     #} {;
      {## Value Matching #}
      export edh'value'matching = bookmark()

      # %% #
      case 3*7 of 15+6 -> "Coincidence? No."
      # %#

      # %% #
      PhoneNo := 35925
      AccountNo := 35925

      # %% #
      the'no = AccountNo
      # %% #
      the'no = PhoneNo
      # %#

      # %% #
      case the'no of {
        35925 -> "No, this is unnamed."
        PhoneNo -> "Dial phone " ++ the'no
        AccountNo -> "Ban account " ++ the'no
      }
      # %#
    }


    {## Guards
     # - Guarding condition as part/all of a matching spec

The infix pipe (|) operator appearing in a matching spec is interpreted so with its rhs being the conditional test expression, if its lhs expression (pattern or value) matches the contextual target. The very branch is considered a match only if both the lhs and the rhs say yes. The side effect of a matched pattern (e.g. local attributes captured) will persist regardless of whether the guard denies the match.

The prefix pipe (|) operator can create a guard-only matching spec at lhs of the branch (->) operator. In this case, it is idiomatic to always place a semiclone before the (|), to disambiguate it from an infix (|) operator - even it has no preceeding expressions, it may be moved or copied to after some expression/statement in the future.

     #} {;
      {## Guards #}
      export edh'guards = bookmark()

      # %% #
      n = 6
      # %% #
      n = 7
      # %% #
      n = 8
      # %% #
      n = 9.5

      # %% #
      case n / 2 of {
        4 -> "It's the right number!"
        { m } | m.trunc is m -> "Got a wrong even number!"
        ; | n.trunc is n -> "Got a wrong odd number!"
        _ -> "Got a wrong non-integral number!"
      }
      # %#
    }


    {## Falling Through
     # - Cancel the conclusion of match

Put a `fallthrough` as the last statement of a branch, this branch will be assumed un-matched, though its rhs expression has been executed.

     #} {;
      {## Falling Through #}
      export edh'fallthrough = bookmark()

      # %% %
      case 3*7 of {
        21 -> {
          console.print$ 'We know that it is, but more can be done with it.'
          fallthrough
        }
        _ -> {
          "This can match."
        }
      }
      # %#
    }


    {## Scoped Blocks
     # - Creating nested block scopes

A usual block doesn't create a new scope, that means, statements inside it will put artifacts into the "current scope" shared with statements outside of the block, as side-effects they'd produce. This behavior is not desirable at times, when some intermediate result need to be stored as attributes during some computation, but better discarded afterwards, or they'd be felt as polution to the shared scope.

A scoped block can help in such situations, it is just a drop-in replacement for a usual block, except with a dedicated scope created, to be used as the "current scope" for the statements inside it to be executed.

     #} {;
      {## Scoped Blocks #}
      export edh'scoped'blocks = bookmark()

      # %% # A scoped block is statements enclosed in a pair of `@` augmented curly braces, i.e. `{@` and `@}`
      x = 'outer-value'
      {@
        # Within a scoped block, attributes are defined locally, since the "current scope" becomes a separate one (backed by a separate entity) than the outer scope. And an attribute present in an inner scope shadows all ones with the same name from outer scopes.
        x = 'inner-value'
        console.print$ 'Inside, x is: ' ++ x
      @}
      console.print$ 'Outside, x is: ' ++ x
      # %# Out of a scoped block, all artifacts ever defined inside are discarded

      # Note it is an anti-pattern to shadow attributes living in outer scopes, the code above is for demonstration purpose only and not idiomatic. Scoped blocks should be just used to discard its scope attributes upon leaving, it's discouraged to override attributes available from outer scopes like that.
    }

  }


  {## for-from-do Loop
   # - Looping against some nondeterministic source

The general syntax is:

  for <loop-arguments> from <loop-source> do <loop-body>

   #} {;
    {## for-from-do Loop #}
    export edh'for'loop = bookmark()

    {## Calling a Generator
     # - For loop is the only way to call a generator procedure

The loop-source is a generator procedure call in this case

     #} {;
      {## Calling a Generator #}
      export edh'call'generator = bookmark()

      # Generator procedure is further described later in this chapter
      ; () => edh'generator'procs # <- follow this bookmark to that section


      # The simplest example is to iterate through a range of numbers:
      # %% # Note that `range()` below is a generator procedure, you can go to its definition to see how it's implemented
      for i from range( 3:9 )
      do console.print( 'Square of ' ++ i ++ ' is ' ++ i*i )
      # %#


      # Here is a slightly more complex example, you're supposed to observe:
      #  * The generator procedure can take arbitrary arguments
      #  * `yield` is used from within the generator procedure to give out one item at a time, the item can go as a freeform ArgsPack. Note that the apk is packed with arguments packing semantics, which is described at:
      ; () => edh'args'un'packing # <- follow this bookmark to that section
      #  * Loop arguments go as attributes of the current scope of the loop expression, and get overwritten on every loop iteration. Note that they are updated with arguments receiving semantics, which is described at:
      ; () => edh'args'receiving # <- follow this bookmark to that section
      #  * The return value of the generator procedure will become the result value of the for-loop expression, as the loop is evaluated
      #  * The do-block of the loop, a.k.a. the loop body, can reference the loop arguments. Note that they are simply read as lexical attributes in scope. Lexical scoping rules are described at:
      ; () => edh'lexi'scoping # <- follow this bookmark to that section

      # %% # Define a generator procedure
      generator g( base, hint7= None, ) {
        yield ( 1, 3 * base, memo= '3 as the factor', )
        yield ( 2, 7 * base, memo= hint7 or nil, )
        return 5 * base
      }
      # %% # Call the generator procedure with a for-loop
      "Loop result= " ++
      for ( i, n, memo= 'no comments', ) from g( 11, )
      do console.print( 'Item #' ++ i ++ ': ' ++ n ++ ' with ' ++ memo )
      # %#

      # Also note that:
      #  * `continue` can be used in the do-block (loop body) to skip subsequent statements in the block, thus jump to next iteration
      #  * `break` can be used in the do-block (loop body) to early stop the for-loop, making it evaluates to `nil`
      #  * `return xxx` can be used in the do-block (loop body) to early stop the for-loop, and further early return from the outer procedure. That's done technically by having the `yield` expression in the generator evaluates to a double-return structure like `return { return xxx }`, the generator in turn propagates the inner `return xxx` as its return value, thus becomes the result value of the for-loop expression, which gets interpreted as early returning `xxx` from the outer procedure body


      # Synchronous Narration is an advanced topic described at:
      ; () => {; import * './advanced/modunarr'
        edh'sync'narration # <- follow this bookmark to that section
      }

    }


    {## Observing an Event Stream
     # - Iterate over the event stream through an event sink

The loop-source evaluates to a event sink value in this case

     #} {;
      {## Observing an Event Stream #}
      export edh'iter'events = bookmark()

      # The event sink value is described earlier in this chapter
      edh'event'sink'values # <- follow this bookmark to that section

      # Here is a simple example, you're supposed to observe:
      #  * The (<-) operator is used to publish arbitrary event values into an event sink
      #  * Loop arguments go as attributes of the current scope of the loop expression, and get overwritten on every event arrival. Note that they are updated with arguments receiving semantics, which is described at:
      ; () => edh'args'receiving # <- follow this bookmark to that section
      #  * The do-block of the loop, a.k.a. the loop body, can reference the loop arguments. Note that they are simply read as lexical attributes in scope. Lexical scoping rules are described at:
      ; () => edh'lexi'scoping # <- follow this bookmark to that section


      # %% # Construct an event sink value
      es = sink
      # %% # Work with the event sink on a separate thread
      go {
        for (***evt) from es do console.info<| 'Got event= ' ++ evt
        console.info <| 'Reached end of event stream.'
      }
      # %% # Publish a single value
      es <- 3
      # %% # Publish an apk
      es <- ( 3, 2, c= 5, a= 2, )
      # %% # Mark end-of-stream for the event stream
      es <- nil
      # %#

      # Also note that:
      #  * `continue` can be used in the do-block (loop body) to skip subsequent statements in the block, thus jump to wait for next event
      #  * `break` can be used in the do-block (loop body) to early stop the for-loop, making it evaluates to `nil`, subsequent events will not be observed after then
      #  * `return xxx` can be used in the do-block (loop body) to early stop the for-loop, and further early return from the outer procedure. That's done technically by having the result value of the for-loop expression evaluates to `return xxx`, manifesting early return from the outer procedure body


      # The event sink value can come from evaluation of a producer procedure call
      # Producer procedure is described later in this chapter
      ; () => edh'producer'procs # <- follow this bookmark to that section

      # Asynchronous Narration is an advanced topic described at:
      ; () => {; import * './advanced/modunarr'
        edh'async'narration # <- follow this bookmark to that section
      }

    }


    {## Scanning Items in Containers
     # - Iterate over all items of a container

The loop-source evaluates to some container in this case, it may be:
 * An apk
 * A list
 * A dict

     #} {;
      {## Scanning Items in Containers #}
      export edh'iter'items = bookmark()

      # %% # Iterate through a single level of positional arguments
      for i from ( 3, 2, 5, ) do console.print( 'Item: ' ++ i )
      # %% # Iterate through a sequence of 2-at-a-time positional arguments
      for ( i, n, ) from ( ( 1, 'x', ), ( 2, 'y', ), )
      do console.print( 'Item #' ++ i ++ ': ' ++ n )
      # %% # The top level container can be a list as well
      for ( i, n, ) from [ ( 1, 'x', ), ( 2, 'y', ), ]
      do console.print( 'Item #' ++ i ++ ': ' ++ n )
      # %% # Iterate through entries of a dict
      for (k, v) from { 'b': 5, 'a': 3, 'c': 9, }
      do console.print( 'Key ' ++ k ++ '= ' ++ v )
      # %#

    }


    {## Apk/List/Dict Comprehension
     # - Comprehend items into containers

The comprehension (=<) operator can be used to pump iterated result values from a for-loop into a result container.

     #} {;
      {## Apk/List/Dict Comprehension #}
      export edh'loop'comprehension = bookmark()

      # %% # Positional args comprehension
      ; () =< for i from range(3:9) do i*i

      # %% # Keyword args comphrehension
      ; () =< for i from range(3:9) do ( @( "square'of'" ++ i )= i*i, )

      # %% # List comprehension
      ; [] =< for i from range(3:9) do i*i

      # %% # Dict comprehension
      {} =< for i from range(3:9) do ( "square-of-" ++ i ): i*i
      # %#
    }

  }


  {## while Loop
   # - Checked iterations

The `while` loop can be used to repeat execution of its loop body again and again, so long as its condition hold, i.e. null test being false for the result as the condition expression evaluated each time.

   #} {;
    {## while Loop #}
    export edh'while'loop = bookmark()

    # %% #
    i = 3
    while i < 9 {
      console.print( 'Square of ' ++ i ++ ' is ' ++ i*i )
      i += 1
    }
    # %#

  }


  {## go Routines with defer'ed Cleanups
   # - Toward structured concurrency
   #} {;
    {## go Routines with defer'ed Cleanups #}
    export edh'go'routines = bookmark()

    {## Spawn Threads to Run Concurrently
     # - Go routines a.k.a. lightweight threads

`go` routines are lightweight threads run concurrently, the GHC Haskell RTS (runtime system) can control how many heavyweight (os) threads are used to run all ƒê threads in parallel.

All the lexical scopes are shared among forker and forkee threads, when race conditions present in updating the attributes of those scopes, `ai` (Atomically Isolatedly) blocks should be used to preserve data consistency. Under the hood, an `ai` block is executed within an atomic STM (Software Transactional Memory) transaction, which will be forever automatically retried, upon inconsistent conditions detected, before it can commit successfuly.

     #} {;
      {## Spawn Threads to Run Concurrently #}
      export edh'spawn'threads = bookmark()

      # %% #
      c = 0
      for _ from range(100) do go {
        ai c += 1 # With the `ai` keyword, it is race free
      }
      # %% # Observe after a second, see its always 100 as expected
      console.print$ "Count is now " ++ c
      # %#

      # %% #
      c = 0
      for _ from range(100) do go {
        c += 1 # Without the `ai` keyword here, some increments can be overwritten by others
      }
      # %% # Observe after a second, it'll probably be less than 100 if you have multiple CPU cores
      console.print$ "Count is now " ++ c
      # %#
    }


    {## Cleanup on Thread Termination
     # - `defer`ed actions are executed on thread termination

Whenever a procedure call or a for-loop is directly involved in a go/defer action, the call-arguments or loop-source are prepared immediately upon the action is scheduled, not until it is actually executed. The execution can be rather later after it is scheduled, especially in case of `defer`.

The cases for direct involvement can be:
  * The action is a direct procedure call
  * The action is a for-loop against a generator procedure call

You can postpone the arguments preparation to execution time, by putting the whole action into a pair of curly braces, i.e. technically making the action a block expression instead, so as to not prepared at schedule time.


     #} {;
      {## Cleanup on Thread Termination #}
      export edh'defer'actions = bookmark()

      # %% #
      go {
        cycle = 'tic'

        # As it's the direct action to `defer`, the arguments preparation happens at schedule time
        defer console.log(
          'A deferred procedure call saw the cycle being: ' ++ cycle,
          level= console.warn,
        )

        # As the direct action is a block expression, the arguments preparation happens at execution time
        defer { console.log(
            'A deferred block saw the cycle being: ' ++ cycle,
            level= console.warn,
        ) }

        # As the direct action is a freeform expression (application of an infix operator) here, nothing is prepared at schedule time, it's just evaluated until execution time
        defer console.warn
        <| "A deferred freeform expression saw the cycle being: " ++ cycle

        # Change cycle state every second
        for _ from console.everySeconds(1) do {
          console.info<| cycle
          case cycle of {
            'tic' -> cycle = 'tac'
            'tac' -> cycle = 'toe'
            'toe' -> cycle = 'fin'
            'fin' -> { break }
          }
        }
      }
      # %# Wait a few seconds and see the difference?

      # `defer` is designed to do resource cleanup with structured concurrency in mind, though in many cases the cleanup action can also be performed by catching the `ThreadTermination` exception, it can be unpleasant at times to organize exception handlers with manual type checks as well as complex nestings.
    }

    {## perceive Events
     # - Preemptive event handling

A single thread can handle multiple event streams at the same time, it can achieve so by installing an event perceivers per each event sink. It can keep the thread running by sleeping (i.e. looping against `console.everySeconds()` or friends), or choose to loop against one of the event sinks instead of perceiving it.

     #} {;
      {## perceive Events #}
      export edh'perceive'events = bookmark()

      # %% # Create some event sinks to convey the streams
      book'to'read = sink
      paper'to'review = sink
      fight'to'pick = sink

      # %% # Handle them
      go {

        perceive book'to'read { book } -> {
          console.info<| 'I read the book [' ++ book ++ '] now.'
        }

        perceive paper'to'review { paper } -> {
          console.info<| 'I review the paper [' ++ paper ++ '] now.'
        }

        defer console.info<| "No fight anymore, I'm done."

        perceive fight'to'pick {
          nil -> {
            break # Terminate the thread when no more fights
          }
          { rival } -> console.warn<| 'I fight ' ++ rival ++ ' now.'
        }
        for _ from console.everySeconds( 10, wait1st= false, )
        do console.info<| "I'm still living, need works to do!"

        console.fatal<| 'This is sth you never supposed to see, is god dead?!'

      }

      #  Run the follow cells in arbitrary order, and repeatedly

      # %% # Send a book to read
      book'to'read <- 'An Actor Prepares (–†–∞–±–æÃÅ—Ç–∞ –∞–∫—Ç—ë—Ä–∞ –Ω–∞–¥ —Å–æ–±–æÃÅ–π)'

      # %% # Send a paper to review
      paper'to'review
      <- 'Monad Transformers and Modular Algebraic Effects:'
      ++ ' What Binds Them Together'

      # %% # Send a rival to fight
      fight'to'pick <- 'the aliens'
      # %# Note This can fail after it's marked eos

      # %% # Send another rival to fight
      fight'to'pick <- 'the zombies'
      # %# Note This can fail after it's marked eos

      # Run the following cell to terminate the thread spawned above

      # %% # This cell will mark the eos of `fight'to'pick`
      fight'to'pick <- nil
      # %# Try send more books or papers after run this cell, to verify the thread is really dead.

    }


    {## Structured Concurrency
     # - Taming the concurrent "goto"
     #} {; () => {
        # There is an advanced topic describing why & how to implement structured concurrency with the mechanisms described above
        import * './advanced/concur'
        edh'structured'concurrency # <- follow this bookmark to the section there
      }
    }

  }


  {## Exception Handling
   # - Using the catch ($=>) and finally (@=>) operator

Implemented as infix operators, the action to try with possibly exceptions thrown, the action to be taken upon exceptions, and the action to be taken anyway regardless of failure or success, all have to be some expression, and that usually would be a block expression for easy reading. Especially when the action consists of one or more statements, it has to be enclosed in a pair of curly braces to become a block expression.

   #} {;
    {## Exception Handling #}
    export edh'exception'handling = bookmark()

    {## The "catch" ($=>) Operator
     # - Catch & handle exceptions

The lhs expression of catch ($=>) operator is the action to try, and the rhs expression is the exception handler.

 If no exception occurred during execution of the lhs action, the rhs handler expression will not be evaluated/executed at all, result value of the lhs evaluation will be the result of the whole catching expression.

In case an exception is thrown and not caught by any nested handler inner the call hierarchy, the rhs handler expression will be evaluated, with the exception value as its current matching target.

If evaluation of the rhs expression is a no-match, the exception is considered not caught thus rethrown, i.e. to continue propagating outwards. Otherwise the result value of the rhs expression as evaluated, will be the result of the whole catching expression.

The rhs handler expression can explicitly issue a `rethrow` statement to continue the exception propagation process outwards, after matched the exception and some other statements executed.

     #} {;
      {## The "catch" ($=>) Operator #}
      export edh'exc'catch = bookmark()

      # %% # It is left-associative, and with precedence -2
      show$ ($=>)

      # %% # Any value can be thrown
      {
        throw 3*7
      } $=> { caught } -> {
        console.info<| 'Caught: ' ++ show(caught)
      }

      # %% # It's idiomatic to only throw object values, of class derived from one of the `Exception` classes, as they'll capture the contextual stack frames for backtraces to be printed, which is crucial in tracking down bugs of the software.
      {
        throw UsageError( "You'v got it wrong!" )
      } $=> { caught } -> {
        console.info<| 'Caught: ' ++ show(caught)
      }
      # %#

      # For meta doc of common exception classes,
      import * 'batteries/meta/exc' into Nothing # <- goto definition of this module

      # It's very common for exceptions to be thrown from deeply nested call hierarchies, some inner procedure could handle some kind of exceptions while leaving the rest propagated outwards, and possibly caught by outer handlers.

      # %% #
      method f1(v) case v |type of {
        DecimalType -> v*5
        StringType -> {
          throw IOError( "Can't open file " ++ v)
        }
        { bad'type } -> {
          throw UsageError( 'Type not supported: ' ++ bad'type )
        }
      }

      method f2(n, v) {
        console.print$ "You got " ++ n ++ ' to be ' ++ f1(v)
      } $=> { UsageError() = exc } -> {
        console.error<| "You got it wrong: " ++ desc(exc)
      }

      # %% #
      f2( 'x', 3, )

      # %% #
      f2( 'y', (), )
      # %# Note that the backtrace printed in the ƒê session of a terminal window within an IDE (like VSCode), can be Ctrl+Clicked (on Linux) or Cmd+Clicked (on macOS), to bring you directly to each call frame's source location.

      # %% # You can wild-capture any exception occurred
      {
        f2( 'z', 'disk.txt', )
      } $=> { exc } -> {
        console.fatal<| "Unexpected failure: " ++ show(exc)
      }

      # %% # Due to the operator's left-associativity, multiple exception handlers can be chained like this:
      method f2'(n, v) {
        console.print$ "You got " ++ n ++ ' to be ' ++ f1(v)
      } $=> { UsageError() = exc } -> {
        console.error<| "You got it wrong: " ++ desc(exc)
      } $=> { IOError() = ioe } -> {
        console.fatal<| "The os failed: " ++ show(ioe)
      }

      # %% # The semantics is equivalent to this:
      method f2'(n, v) {
        console.print$ "You got " ++ n ++ ' to be ' ++ f1(v)
      } $=> {
        { UsageError() = exc } -> {
          console.error<| "You got it wrong: " ++ desc(exc)
        }
        { IOError() = ioe } -> {
          console.fatal<| "The os failed: " ++ show(ioe)
        }
      }

      # %% # It's only stylish difference for the 2 cells above, either one should work the same way.
      f2'( 'z', 'disk.txt', )

      # %#

    }


    {## The "finally" (@=>) Operator
     # - Success or failure, something has to be done

The lhs expression of finally (@=>) operator is the action to try, regardless of whether it's evaluated successfully, or some exception occurred meanwhile, the rhs expression will always be evaluated/executed, before giving out result of the lhs evaluation as the result of the whole expression, or further propagating the exception outwards.

     #} {;
      {## The "finally" (@=>) Operator #}
      export edh'exc'finally = bookmark()

      # %%s #
      method f3( ***apk ) {
        f2( ***apk )
      } @=> {
        console.info<| "I called f2() anyway!"
      }

      # %% #
      f3( 'x', 3, )

      # %% #
      f3( 'y', (), )
      # %#

      # %% #
      {
        f3( 'z', 'disk.txt', )
      } $=> {
        pass # ignore any error
      }

      # %#
    }

    {## Chained Together
     # - catch and finally expressions can be chained together
     #} {;
      {## Chained Together #}
      export edh'catch'chained'finally = bookmark()

      # %% #
      {
        ; # Try sth.
      } $=> { EvalError() } -> {
        ; # Handle evaluation errors
      } $=> { UsageError() } -> {
        ; # Handle usage errors
      } @=> {
        ; # Do this anyway
      }
      # %# Note that it is technically valid for multiple finally constructs chained together, just makes no sense in practice

    }


    {## Handling Exceptions for Forkee Threads
     # - Toward structured concurrency

Call frames induced by a forked thread will stack up its forker thread's call frames, this also enables the forker thread to handle exceptions occurred in the forkee thread's execution.

But especially note that the _handling_ code (i.e. statement(s) at rhs of the ($=>) operator) will run on the forkee thread, not the forker thread. And multi-shotting of the _handling_ code is a norm when multiple forkee threads will be spawned and they don't catch possible exceptions on their own. If the exception value is to be captured as some attribute, a dedicated scope should be created to receive that attribute, or there'll be race conditions for capturing & subsequent using of the exception value via that attribute concurrently.

Also note that _finalization_ code (i.e. statement(s) at rhs of the (@=>) operator) will never run on any forked thread, as multi-shotting of such blocks is semantically wrong.

     #} {;
      {## Handling Exceptions for Forkee Threads #}
      export edh'forkee'exc'handling = bookmark()

      # %% #
      method async'some(async'id) {
        throw Exception( 'I just failed #' ++ async'id ++ ' asynchronously!' )
      }

      {
        for forkee'id from range(3) do go async'some(forkee'id)
      } @=> {
        console.info<| "The cleanup should only happen on the original thread."
      } $=> {@ # Use a scoped block for the catch, as this catch block can multi-shot on multiple descendant threads, it's a race condation to capture the thrown exception as a named attribute into a shared scope then use it along.
        { exc } -> {
          console.warn<| "Caught a forkee's failure: " + show(exc)
        }
      @}
      # %#
    }
  }

}


export edh'pragmatics = bookmark()


{## Procedures
 # - "Function"s having access to the whole world

A *function* in mathematics has well defined input and output, it can refer to nothing outside of its input. Functional programming langauges e.g. Haskell, reflects such constraint well. But unfortunately many procedural / imperative programming langauges, tracing back to C and other ancestors, defined their "function"s with ability to access global / closure "variable"s (The "variable" there is albeit another misconception agsinst mathematical variables), so side-effects can be there out of trivial reasonability by programmers in the day, leading to more bugs in software developed comercially.

It's not a big deal for ƒê the language has stopped refering to impure computations (with side-effects) as "function"s, but more conforming conception is a good start to put effect tracking as a focus for the programming tools, looking forward for greater quality in the software developed as the result.

A procedure in ƒê is a 1st class value, holding some computation with formally declared input arguments, and when called with concrete values for those arguments, it will evaluate to some result value (though possibly `nil`), with or without side-effects produced.

There are several types of procedure, each provides some distinct convenience under different circumstances.

Procedure is a special form of lambda-expression (as in mathematics) per se, while note that there is also 1st class **expression** values in ƒê, which are effectful computations without formal arguments declaration, and without closure capturing (but with value interpolation instead) per se.

 #} {;
  {## Procedures #}
  export edh'procs = bookmark()


  {## Vanilla Procedures
   # - The most common type of procedure

The general syntax to define a vanilla procedure is:

  method <procedure-name> <arg-spec> <procedure-body>

The definition is an expression evaluates to a value of `MethodType`, this value will be bound to current scope, with <procedure-name> being the attribute key, unless it is evaluated in a pure context.

Note that many other procedures share mostly the same syntax with the vanilla procedure definition, they just use different keywords and imply different semantics when called.

   #} {;
    {## Vanilla Procedures #}
    export edh'vanilla'procs = bookmark()

    # %% # A simple number increamental procedure is usually written like this:
    method f(x) {
      return x+1
    }

    # %% # See type of the procedure value
    type$ f

    # %% # And called like this:
    f(5)


    # %% # The parenthese around the argument list can be omitted since it is unary, and the procedure body can be simply the expression it should evaluate, so the minimal form can be:
    method f x x+1
    # %% # Also it can be called with the ($) operator
    f$ 5
    # %% # Or the (|) operator
    5 |f

    # %% # Recursion is intuitive:
    method factorial(n) if n <= 1 then 1 else n * factorial(n - 1)
    # %% # Or using tenary:
    method factorial(n) n <= 1 and 1 or n * factorial(n - 1)

    # %% #
    factorial(5)

    # %#
  }


  {## Interpreter Procedures
   # - To receive arguments as expressions for controlled evaluation

The general syntax to define an intetpreter procedure is:

  interpreter <procedure-name> ( callerScope, ***<rest-arg-spec> ) <procedure-body>

The definition is an expression evaluates to a value of `InterpreterType`, this value will be bound to current scope, with <procedure-name> being the attribute key, unless it is evaluated in a pure context.

The first positional `callerScope` argument will be a scope wrapper object wrapping the scope from where this procedure is called, and rest arguments will receive what the caller passes for the call, but they will be expression values without evaluated.

   #} {;
    {## Interpreter Procedures #}
    export edh'interpreter'procs = bookmark()

    # Expression Values and Scope Wrapprs are further described later in this chapter.
    ; () => edh'exprs'in'scopes # <- follow this bookmark to that section

    # %% #
    {## Create a lazy evaluator of the specified expression #}
    interpreter compute( callerScope, x, name= None, ) {
      # note the following method definition won't bind the result procedure value into local scope as an attribute named after `@name`, because it is evaluated in the pure context created by the `return` statement, this is important for the attributes `callerScope` and `x` not to be overwritten due to the `name` argument happens to be given a value of their respective name.
      {##
       # A lazy evaluator
This is an unary procedure (niladic computation) that evaluates the original expression per called
       #}
      return method @( name and callerScope.eval(name) or 'lazyEval' ) () {
        callerScope.eval(x)
      }
    }

    # %% #
    a = 5; b = 3
    sum = compute( a + b, name= 'The sum of a and b', )

    # %% #
    "  Once upon a time, the sum was " ++ sum() ++ '.'

    # %% #
    a = 7
    "  Then after a change, it becomes " ++ sum() ++ '.'

    # %#
  }


  {## Generator Procedures
   # - Procedures facilitating reusable synchronous iterations

Certain large dataset is not suitable to be stored in its entirety in runtime memory, or the successor item in the collection can be efficiently computed from its predecessor item, or both be the case sometimes. Generator procedures work well for such scenarios.

The general syntax to define a generator procedure is:

  generator <procedure-name> <arg-spec> <procedure-body>

The definition is an expression evaluates to a value of `GeneratorType`, this value will be bound to current scope, with <procedure-name> being the attribute key, unless it is evaluated in a pure context.

A generator procedure can not be called like other procedures, the only place it can be called is by a for-loop, as the call expression between the `from` keyword and `do` keyword of the for-loop.

The most important feature is that, `yield` expressions can be put in the procedure body of a generator procedure, while it's invalid for a `yield` expression to appear in the body of other type of procedures.

The `yield` expression can be intuited as calling the for-loop's do block (the loop body), after overwritting the loop arguments of the for-loop, at scope of the for-loop.

   #} {;
    {## Generator Procedures #}
    export edh'generator'procs = bookmark()

    # %% #
    {## Iterating the factorial of numbers since 1 up to `n` as specified #}
    generator withFactorialUpTo( n ) {
      v = 1
      for i from range( 1 : n+1 ) do {
        old'v = v
        v = i * v
        yield (i, v)
      }
    }
    # %# Note `range()` used above is a generator procedure by itself
    range # <- go to its definition to see the implementation as a sophisticated example

    # %% # It is used like this:
    for (i, fv) from withFactorialUpTo(7)
    do console.print$ i ++ '! = ' ++ fv


    # The for-loop and the generator can exchange values via the `yield` expression, that final result of the loop body is passed back to the generator as the evaluation result of the `yield` expression

    # %% # Let's demonstrate the mechanism with this example

    generator g (n) while true {
      case yield n*n of {

        # The generator shoud honor special flow control values as the result of `yield`, and cooperate accordingly, like this:
        { break } -> { return nil } # loop body issued { break }
        { return rtn } -> { return rtn } # loop body issued { return xxx }

        nil -> { # loop body issued { continue }
          # but we can't continue without a number passed back,
          return nil # so just return stop the iteration
        }

        # Otherwise the loop body has evaluated to a usual value and passed back here,
        # we simply captured it with attribute name `n` to update our local scope,
        # the new value will be used in next iteration as in the `n*n` expression above.
        { n } -> { pass }

      }
    }

    for n from g( 3 ) do {
      console.print(n) # Show what we've been given

      if n > 1000 then {
        break # Special statements like break/return will pass special control values there
      } else {
        n - 1 # A usual value will be passed back to generator just straight forward
      }
    }

    # %# Above example may be a little harder to comphrend, don't worry, you can postpone the understanding of it until absolutely necessary.


    # Named arguments (keyword args) can also be passed as loop arguments from the generator, the following example will strenghen your intuition that `yield` feels like calling-back the loop body for indeterminate effects, i.e. the loop body can be executed 0, 1 or more times, that can never be determined by the looper. While the generator is to decide it, by `yield`ing 0, 1 or more times.

    # %% # Let's demonstrate it with another example

    generator g( base, hint7= None, ) {
      yield ( 1, 3 * base, memo= '3 as the factor', )
      yield ( 2, 7 * base, memo= hint7 or nil, )
      return 5 * base
    }

    "Loop result= " ++
    for ( i, n, memo= 'no comments', ) from g( 11, )
    do console.print( 'Item #' ++ i ++ ': ' ++ n ++ ' with ' ++ memo )

    # %# You may have noticed but it's worth mentioning that in above, the result value of the whole for-loop expression reflects what the generator has `return`ed, given the loop body didn't do an early { break } or { return xxx }.


    # Synchronous Narration is an advanced topic described at:
    ; () => {; import * './advanced/modunarr'
      edh'sync'narration # <- follow this bookmark to that section
    }

  }


  {## Producer Procedures
   # - To avoid race condition between asynchronous event producer and consumer

Event streams through event sinks are asynchronous in nature, as event sinks will drop events when not subscribed, there will be race condition in starting a new thread to run an event producing computation, while subscribing the event sink to consume the produced event stream at the same time. Producer procedures can be used to eliminate such race conditions.

The general syntax to define a producer procedure is:

  producer <procedure-name> <arg-spec> <procedure-body>

The definition is an expression evaluates to a value of `ProducerType`, this value will be bound to current scope, with <procedure-name> being the attribute key, unless it is evaluated in a pure context.

   #} {;
    {## Producer Procedures #}
    export edh'producer'procs = bookmark()

    {## Racing Problem in Lieu of Producer Procedures
     # - Producer procedures solve race conditions

Let's see a racy solution first.

     #} {;
      {## Racing Problem in Lieu of Producer Procedures #}
      export edh'producing'problem = bookmark()

      # %% # The artificial delay in milliseconds between the start of producing and start of consuming. Setting it to zero can by NO means eliminate the delay, due to how the multi-threaded runtime is scheduled. A zero delay just minimizes the chance the unwanted consequences happen to be observed.
      lag'ms = 0

      # %% # Set some possitive delay, you'll see the result being randomly unpredictable, i.e. perfect race condition demonstrated
      lag'ms = 5

      # %% # Run this cell to start the race with whatever `lag'ms` set, repeat it to see different results

      evs = sink
      go {@ # Use a scoped block to not share the `i` attribute of outer scope
        i = 0; for _ from console.everyMillis(1) do {
          evs <- i+=1
          if i>=5 then { break }
        }
        evs <- nil # mark eos
      @}

      for _ from console.everyMillis(lag'ms) do break

      for i from evs do console.print$ "Got " ++ i

      # %# Maybe you'll need to tune the value of `lag'ms` in your runtime to make the racy result more obvious
    }


    {## Using Producer Procedures
     # - The race-free solution
     #} {;
      {## Using Producer Procedures #}
      export edh'race'free'producing = bookmark()

      # %% # Here is the race-free solution

      producer p(outlet= sink) {
        i = 0; for _ from console.everyMillis(1) do {
          outlet <- i+=1
          if i>=5 then { break }
        }
        outlet <- nil # mark eos
      }

      for i from p() do console.print$ "Got " ++ i

      # %# See there is even no place to insert an artificial delay, and under the hood, even race conditions due to thread scheduling are eliminated by the ƒê runtime, so long as you stick to looping against a producer procedure call.
    }


    {## Internal Working of Producer Procedure Call
     # - How a producer procedure works with for-loop

A new thread will be implicitly started to run the producer procedure body, but the actual execution will be held until the agreed event sink has been subscribed by some consumer, which will be the for-loop in the pattern demonstrated above.

The agreed event sink will be value passed as an argument named `outlet` in the producer procedure call, or such an argument can be omitted as you've see in the solution above, in which case a fresh new event sink value is created and used as the agreed sink.

A producer procedure usually declares an input argument named `outlet`, to receive the agreed event sink value. It can be renamed or omitted at all, but that's quite advanced usage, will require sophisticated concurrency reasoning to get it right.

Finally the agreed event sink - there will always be one, even neither explicitly passed nor received - will be the synchronous result value as for the call of the producer procedure, the for-loop then get this event sink as its iteration source value, thus subscribes to the event sink and loops agsinst the event stream through it.

     #} {;
      {## Internal Working of Producer Procedure Call #}
      export edh'producer'works = bookmark()
    }


    # Asynchronous Narration is an advanced topic described at:
    ; () => {; import * './advanced/modunarr'
      edh'async'narration # <- follow this bookmark to that section
    }

  }


  {## Arrow Procedures
   # - Lambda procedures bound to contextual objects

Lambdas is essential to functional programming paradigm, where higher order functions (procedures will be used in ƒê) can take other functions as arguments and operate on them with more abstract semantics.

Arrow procedures are anonymous (unnamed) procedures defined with lambda syntax, they will be bound to the contextual objects (those can be refered to by `this` and `that` reference), w.r.t. where they are defined, in addition to have their lexical scopes enclosed, as all procedures do.

The general syntax to define an arrow procedure is:

  <arg-spec> => <procedure-body>

or

  <arg-spec> =>* <procedure-body>

Technically, it is the application of the arrow definition (=>) or (=>*) operators, thus an infix operation expression.

With the (=>) operator, the expression evaluates to a value of `GeneratorType` (which is a bound generator arrow), if the body contains at least 1 `yield` expression; otherwise the result will be of `MethodType` (thus a vanilla arrow). The semantics when the result procedure is called, is identical to a generator procedure or a vanilla procedure accordingly.

With the (=>*) operator, the expression evaluates to a value of `ProducerType` (which is a bound producer arrow). The semantics when the result procedure is called, is identical to a producer procedure.

   #} {;
    {## Arrow Procedures #}
    export edh'arrow'procs = bookmark()

    # %% # A simple vanilla arrow
    type$ x => x+1

    # %% # A simple generator arrow
    type$ x => {
      yield x+1
      yield x+2
      return x+3
    }

    # %% # A simple producer arrow
    type$ (x, outlet= sink,) =>* {
      defer outlet <- nil
      outlet <- x+1
      outlet <- x+2
      outlet <- x+3
    }
    # %#


    # %% #A sophisticated ad-hoc generator arrow, demonstrating a freeform list builder

    # With some contextual state
    let ( foo, bar ) = ( 77, 88 )
    let lll = [ 3, 2, 5 ]

    # Comprehend items into a list, those generated with arbitrary control flows
    ; [] =< for i from (() => {
        yield "a"
        yield ( if foo < bar
          then "b"
          else "c" )
        yield "d"
        for item from lll do {
          yield item
          yield item * 2
        }
    }) () do i

    # %# Loop based comprehension is described in another section
    ; () => edh'loop'comprehension # <- follow this bookmark to there


    # Note that anonymous procedures can be defined with keyword based syntax as well, as described in previous sections. The trick is to specify the procedure name to be `_`.

    # %% # e.g. the following implementation has identical semantics as the last cell:
    ; [] =< for i from ( generator _() {
        yield "a"
        yield ( if foo < bar
          then "b"
          else "c" )
        yield "d"
        for item from lll do {
          yield item
          yield item * 2
        }
    }) () do i
    # %# So long as neither `this` nor `that` object is referred in the procedure bodies


    {#

There will be semantical differences when `this` and/or `that` references appear in the procedure body:

  * Those objects will surely be what's in current scope for an arrow procedure, as arrow procedures are immediately bound to the objects in context upon it is defined.

  * What `this` and `that` will refer to, will need more reasoning (to see where and when they'll be bound), for procedures defined with the keywords (method/interpreter/generator/producer), regardless of them being anonymous or named.

     #}

    # `this` and `that` references w.r.t. how methods are bound, is described later in this chapter
    ; () => edh'mth'binding # <- follow this bookmark to that section

  }


  {## Operator Procedures
   # - The implementation of infix operators
   #} {;
    {## Operator Procedures #}
    export edh'op'procs = bookmark()

    {## Strict (2-arg) Operator Procedures
     # - Operator procedures with strict evaluation

The general syntax to define a 2-arg operator procedure is:

  operator|infix|infixl|infixr [ <op-precedence> ] (<op-symbol>) ( <lhs-value>, <rhs-value> ) <procedure-body>

The definition is an expression evaluates to a value of `OperatorType`, this value will be bound to current scope, with <op-symbol> being the attribute key, unless it is evaluated in a pure context.

     #} {;
      {## Strict (2-arg) Operator Procedures #}
      export edh'2'arg'op'procs = bookmark()

      # %% # For a simple example, we define the "function" composition operator using the mid-dot symbol
      # See: https://middot.net for how to input a mid-dot

      {## The function composition operator #}
      infixr 9 ( ¬∑ ) ( f, g ) {
        method @( f.name ++ ' ¬∑ ' ++ g.name ) (x) {
          f ( g ( x ) )
        }
      }

      show$ ( ¬∑ )

      # %% # Given 2 "function"s:
      method plus5 x x+5
      method mult3 x x*3

      # %% # They can be composed into a new "function"
      p = plus5 ¬∑ mult3

      p|desc

      # %% # Then the composite "function" can be used like any other procedures
      2 |p
      # %%
      p$ 2
      # %%
      p( 2 )
      # %#
    }


    {## Non-Strict (3-arg) Operator Procedures
     # - For controlled evaluation

The general syntax to define a 3-arg operator procedure is:

  operator|infix|infixl|infixr [ <op-precedence> ] (<op-symbol>) ( callerScope, <lhs-expr>, <rhs-expr> ) <procedure-body>

The definition is an expression evaluates to a value of `OperatorType`, this value will be bound to current scope, with <op-symbol> being the attribute key, unless it is evaluated in a pure context.

     #} {;
      {## Non-Strict (3-arg) Operator Procedures #}
      export edh'3'arg'op'procs = bookmark()

      # The first positional `callerScope` argument will be a scope wrapper object wrapping the scope from where this operator is applied, and the rest 2 arguments will be expression values instead of evaluated result values, for the lhs and rhs operands of the operator application.

      # Expression Values and Scope Wrapprs are further described later in this chapter.
      ; () => edh'exprs'in'scopes # <- follow this bookmark to that section

      # %% #
      {##
       # For lazily evaluated substituation
This operator is strict on its lhs argument, but won't evaluate its rhs argument unless the result from the lhs argument is falsy.
       #}
      operator 0 (||>) ( callerScope, lhx, rhx ) {
        case callerScope.eval(lhx) of {

          # Evaluate to result of the lhs expression so long as it is truthful
          { lhv } | not null(lhv) -> lhv

          # Or evaluate to whatever the result is from the rhs expression
          _ -> callerScope.eval(rhx)

        }
      }

      # %% # See type of the procedure value
      type$ (||>)

      # %% # With some contextual attribute set
      n = 21
      # %% # Or set to another value
      n = 38

      # %% # Call the operator procedure:
      n-3*7 ||> {
        console.warn<| 'zero there is'
        999
      }
      # %# Try switch the value of `n`, and run above cell again to see a different result

      # %% # Technically, we have just re-implemented the intrinsic (or) operator
      n-3*7 or {
        console.warn<| 'zero there is'
        999
      }
      # %# See they have exactly the same semantics
    }


    {## Operator Precedence & Fixity/Associativity
     # - How expressions work

Contributions needed here to explain it well.

     #} {;
      {## Operator Precedence & Fixity/Associativity #}
      export edh'op'precedence'fixity = bookmark()

      # TODO contributions needed here

      # %%
      infixr 5 ( üì¢ ) ( lhv, rhv ) {
        console.print$ rhv ++ ' is telling ' ++ lhv
        return rhv
      }

      show$( üì¢ )

      # %%
      'a lie' üì¢ 'a tale' üì¢ 'the goat'

      # %%
      operator 1 ( üÜö ) ( lhv, rhv ) {
        console.info <| "üåÄ What's the difference?\n     "
        ++ lhv ++ '\n  üÜö\n     ' ++ rhv
      }

      show$ ( üÜö )

      # %%
      let ( a, b ) = ( 'Orange', 'Apple', )
      a üÜö b

      # %# Destined to fail as no fixity
      #   a üÜö b üÜö c
      # Note above line is commented out or the whole file won't parse
      # You can copy & paste the text into REPL and see how it fails at runtime


      # %% # Overide the (++) operator within a dedicated namespace, avoid polluting the module global scope
      case {@
        before = 'You' ++ ' and ' ++ 'me'

        # for an operator already declared beforehand, the fixity follows existing
        # declaration when you use `operator` or `infix` as the keyword to override it
        operator (++) ( lhv, rhv ) {
          # inside the overriding operator definition, the overridden,
          # original operator is available as was before the overide
          lhv ++ ' ‚≠ï ' ++ rhv
        }

        after = 'You' ++ ' and ' ++ 'me'

        scope() # Save a scope wrapper object, so we can still eval expressions in this scope later
      @} of { dynamic'workspace } -> {

        # Note the assign (=) operation can not be used, or it'll create a pure context where operator procedure definition will not bind the result procedure value to its current scope.
        pass
      }

      dir$ dynamic'workspace
      # %#

      # %% # Check the result there
      dynamic'workspace.eval( expr
        before üÜö after
      )

      # %% # A vanilla method or interpreter procedure can be re-declared as some operator, if it takes exactly 2 positional arguments (not counting the `callerScope` argument)

      method concat1( lhv, rhv ) {
        lhv ++ ' plus ' ++ rhv
      }
      infixl 3 (>+<) () concat1

      interpreter concat2( callerScope, lhe, rhe ) {
        callerScope.eval( lhe ) ++ ' and ' ++ callerScope.eval( rhe )
      }
      infixl 3 (>&<) () concat2

      # %% # All operators can combine together, according to their respective fixity and precedence
      3*7 >+< 9*9
      üÜö
      3*7 >&< 9*9

      # %#
    }

  }


  {## Definition Procedures
   # - To initialize a module, a namespace, or a class

Whole content of a `.edh` file as source of an ƒê module is executed in the module scope.

The body of a namespace definition is executed in the namespace's object scope.

The body of a class (either usual class or data class) definition is executed in the class's object scope.

Conceptually we say they all are of a special type of procedures - definition procedures.

   #} {;
    {## Definition Procedures #}
    export edh'defi'procs = bookmark()
  }

}


{## Objects & Inheritance
 # - For data structures & behaviors to be reused

Object is a special kind of values, it serves the basis of user defined data structures in ƒê.

Two traditional Object Oriented infrastructure for inheritance are unified, i.e. prototype based and class based Object Orientation. Multiple-inheritance is natively supported as well.

Inheritance in traditional Object Orientation is considered inferior to composition, see:
  https://en.wikipedia.org/wiki/Composition_over_inheritance

But ƒê made it for composition to have the look & feel of inheritance, with boilerplate code in typical composition paradigm avoided. Multiple super (prototype) objects can be obtained with the `supers()` utility procedure, there is also an idiomatic match pattern for class-targeted super object instance extraction.

 #} {;
  {## Objects & Inheritance #}
  export edh'objs'inheritance = bookmark()

  # The ƒê Object System is an advanced topic a dedicated chapter
  import * './advanced/objs' # <- follow this import source to that chapter


  {## Data Classes
   # - Shorthand class syntax for simple data records

Simple data structures can be defined as data classes. A data class is still a general class at its core, having all class capabilities including but not limited to, inheritance.

Technically, the data class syntax is a syntactic sugar to define a general class (as described in next section), but with some boilerplate code generated automatically under the hood, for some commonplace features. (TODO expand about those features)

   #} {;
    {## Data Classes #}
    export edh'data'classes = bookmark()

    # %{

    # %% # A simple class with 2 fields, x and y for a 2D point
    data Point(x, y) pass

    # %% # Data fields can store object values of course, and a default value can be supplied for a field in the constructor arguments receiver
    data Circle( r, c= Point(0,0), ) pass
    data Rectangle(w, h, o= Point(0,0), ) pass

    # %}

    # %% # The class name binds to the object constructor procedure, it can be called with arguments for data fields to construct new objects of the class
    c1 = Circle(5)
    c2 = Circle(5)
    # %% # Two data objects are considered equal when all of their fields are equal respectively
    c1 == c2
    # %% # But they are distinct objects per se (having different identity)
    c1 is not c2
    # %% # And each object can be modified individually
    c2.r = 6
    c1 == c2
    # %# See they are not equal now?

    # %% # The representation magic method ( `__repr__()`` ) is automatically generated, keyword arguments will be shown when there are more than 2 fields
    r1 = Rectangle( 7, 2, Point(3, 1), )
    # %#

  }


  {## General Classes
   # - Class is a special kind of object

An ƒê object can only be constructed from some class. When an attribute being requested against an object is not found from the object instance itself, its class will be consulted to provide such an attribute for the object instance. A class can be thought of as a backing store for default values of object attributes, which is shared by all object instances belong to it. An attribute value provided by its class, is treated the same as if provided by the object instance directly.

The `class` keyword is used to define a general class, the syntax is:

  class <class-name> <class-body>

<class-name> can be whatever an attribute name, and <class-body> is a statement (usually multiple statements quoted within a pair of curly braces as a block expression statement) to be executed immediately to intialize the class artifacts.

   #} {;
    {## General Classes #}
    export edh'class = bookmark()

    {## Class Artifacts
     # - What a standalone class can have
     #} {;
      {## Class Artifacts #}
      export edh'cls'arts = bookmark()

      # Note that methods are further described in a later section, but the code in this section includes them for demonstration purpose.
      ; () => edh'mths'and'magic # <- follow this bookmark to that secion

      # %%

      {##
       # A standalone class
       #}
      class C {

        {##
         # A static class attribute

Class attributes serve as the default value for object instances of this class

         #}
        static'attr'a = 3

        {##
         # A static class method

Class methods are intended to be called without any particular object instance, `this` here should refer to the class object itself.

         #}
        method static'mth'b() {
          console.print$ 'Hello from class ' ++ this ++ ' !'
        }

        {##
         # The magic `__init__()` method

This will be called every time a new object instance is constructed, by calling the class object, which semantically being its object constructor.

It can receive arguments as usual procedures, from whatever passed for the object construction.

         #}
        method __init__( b as this.b, c as this._c = 5, *** ) {
          # The procedure body can contain arbitrary statements to initialize the object instance.
          # `this` refers to the object instance just created, assigning attributes to it here is part of the object instance initialization procedure.
          this._d = this.b * this._c
        }

        {##
         # An instance method

Any number of method procedures can be defined for a class.

         #}
        method instance'method'd() void {
          console.print$ 'My d = ' ++ this._d
        }

        {##
         # The readonly `d` property

Properties are syntatic sugar for private data of an object to be accessed like attributes.

Without a setter method, a property looks & feels like a readonly attribute.

This is the getter method of property `d`.

         #}
        property$
        method d() this._d

        {##
         # The `c` property getter

This is the getter method of property `c`.

         #}
        property$
        method c() this._c

        {##
         # The writable `c` property

With a setter method, a property look & feels like a usual attribute, i.e. can be assigned as well as read.

This is the setter method of property `c`.

         #}
        setter$
        method c(new'c) {
          this._c = new'c
          this._d = this.b * this._c
          return this._c # for the result of the assignment
        }

      }

      # %% # Static class attributes are accessable via the class object directly
      C.static'attr'a
      # %% # Static class methods should be called via the class object directly
      C.static'mth'b()
      # %# Technically all attributes defined for a class can be accessed this way, but instance methods are not intended to be so, for in their procedure bodies, `this` reference is assumed to refer to object instance of the class, instead of the class object itself.

      # %% # Construct an instance of class `C`
      o = C(2)

      # %% # Static class attributes not overridden by the instance can be read as instance attribute too
      o.static'attr'a

      # %% # See its fields
      o.b

      # %% # Call its methods
      o.instance'method'd()

      # %% # Read its properties
      ; ( o.d, o.c, )

      # %% # Change its properties
      o.c = 111

      # %% # Assign to a readonly property, gonna to fail
      o.d = 99

      # %#
    }

  }


  {## Class based Inheritance
   # - A class with super classes will construct composite objects

   #} {;
    {## Class based Inheritance #}
    export edh'cls'inheritance = bookmark()

    {## Super Classes, Their Role in Object Construction
     # - Extending other classes

If a class `extends` one or more super classes, either directly or indirectly, an object this class constructs will have a list of super objects each constructed from a respective super class accordingly.

     #} {;
      {## Super Classes, Their Role in Object Construction #}
      export edh'super'cls'role = bookmark()

      # %% #

      {##
       # A derived class from another one
       #}
      class D { extends C

        {##
         # All classes can have its own `__init__()` magic method

Especially note that construction arguments are passed to all classes' `__init__()` method, so they'd better to ignore args in the pack for the `__init__()` method by other (either super or descendant) classes. In this case, it's a good idea to only receive named arguments (keyword args), as positional arguments are pretty easy to be supplied under wrong assumptions or mis-interpreted.

         #}
        method __init__( *, x as this.x, *** ) {
          this.y = super.b * this.x
        }

      }

      {##
       # A further extended class
       #}
      class E extends D

      # %#

      # %% # Here we construct an end object of class `E`
      # Note `9` as a positional argument is meant to be passed to `C`'s constructor, while `x= 23` is meant for that of `D`'s keyword args so named
      e = E( 9, x= 23, )

      # %% # See it has instances of class `D` and `C` respectively
      supers(e)
      # %#

      # An object attribute when requested against an end object, will be resolved by consulting itself first, then its super objects in order as listed, an attribute value provided by any instance (or its class) will be used and the resolution is done. It'll be runtime error if none of the instances provides the interesting attribute.

      # Unless overridden by a descendant class, artifacts of a super class should just work via the end object instance

      # %% # Static class attributes inherited
      e.static'attr'a

      # %% # Inherited fields
      e.b

      # %% # Inherited methods
      e.instance'method'd()

      # %% # Read inherited properties
      ; ( e.d, e.c, )

      # %% # Change inherited properties
      e.c = 111

      # %% # This is gonna to fail
      e.d = 99

      # %#
    }


    {## Super Object Instance Extraction
     # - Obtaining super class instance

An end object always holds the "HAS-A" relationship with each of its super object instances, the instance resolution match pattern can be used to extract super object instance of a specific super class, from an end object.

     #} {;
      {## Super Object Instance Extraction #}
      export edh'super'inst'extraction = bookmark()

      # %% # For an object `o` with 2 levels of class inheritance
      class A pass
      class B extends A
      class C extends B
      o = C()

      # %% # The `B` instance can be extracted from `o` as `b` like this:
      case o of {{ B: b }} -> b

      # %% # They are distinct instances
      b is not o

      # %% # And `b` is actually listed as one of `o`'s super object instances
      b ?<= supers(o)
      # %# Note the super instance of class `A` can be obtained similarly

    }


    {## Multiple Inheritance and Method Resolution Order
     # - C3 linearization

A class can extend multiple super classes, then there are chances for a same super class to be indirectly extended multiple times, via different paths.

Such situations are handled with an algorithm named C3 linearization, see:
  https://en.wikipedia.org/wiki/C3_linearization

Note that it's more proper to say "Attribute Resolution Order" instead of "Method Resolution Order" in ƒê context, but we use MRO as it's a well established concept in context of C3 linearization.

     #} {;
      {## Multiple Inheritance and Method Resolution Order #}
      export edh'mro = bookmark()

      # %% #
      class O pass
      class A extends O
      class B extends O
      class C extends O
      class D extends O
      class E extends O
      class K1 extends ( A, B, C )
      class K2 extends ( D, B, E )
      class K3 extends ( D, A )
      class Z extends ( K1, K2, K3 )

      # %% # The lineraized super class list can be obtained as the `mro` attribute of a class
      Z.mro

      # %% # The super object list of a class reflects what a class extends directly, see for a comparison
      supers(Z)

      # %% # The list of super object instances for the end object constructed, will reflect `mro` of the end class, note that's different from the super class list:
      z = Z()
      supers(z)
      # %# See class of the super instances match the super class listed in mro

      # %% # A specific super instance can be extracted via pattern matching:
      case z of {{ K2: k2 }} -> k2

      # %% # A super instance alone, can also be thought of as an end object on its own right:
      supers( k2 )
      # %% # See its own super instance list, matching it's own class' mro:
      K2.mro
      # %#

      # %% # Super instances are shared by each member instance of a final end object, see:
      ; (
        case z of {{ O: z's'o }} -> z's'o
      ) is (
        case k2 of {{ O: k2's'o }} -> k2's'o
      )
      # %#

    }

  }


  {## Prototype based Inheritance
   # - Extending other objects directly

You can avoid class inheritance at all, and let an object instance extend one or more other objects directly. Further more, since the extending relationship can be chained, multiple levels of instance inheritance is possible.

You can set a shared super object as for the prototype, then new objects can extend it directly, with arbitrary attributes overridden.

The overrides happen dynamically, which means the relationship and overriding value can change at anytime.

The super object can also change dynamically, which means all descendant objects will effectively change accordingly, w.r.t. attributes they don't override.

   #} {;
    {## Prototype based Inheritance #}
    export edh'proto'inheritance = bookmark()

    # %% #
    data Point(x, y) pass

    center'of'everything = Point(0,0)

    class Origin {
      method __init__(***) extends center'of'everything
    }

    data Circle(radius, center= Origin(),) pass

    # %% # These 2 circles have their respective origin point extend from a shared point
    c1 = Circle(5)
    c2 = Circle(6)
    c1 ++ ' vs ' ++ c2

    # %% # Their origin points are distinct objects, can change individually
    c2.center.x = 3
    c1 ++ ' vs ' ++ c2

    # %% # The shared super object can also change, possibly causing a blast of changes
    center'of'everything.y = 7
    c1 ++ ' vs ' ++ c2
    # %#

    # You are not limited to `extends` only one super object, multiple super objects can be extended at a time:
    extends (super1, super2, *more'supers,)
    # And you can issue `extends` at anywhere for as many times as you'd like, that's to say, it's also dynamic.

    # Prototype based inheritance is powerful but can easily go wrong, and harder to reason about for complex systems. It may be too dangerous for software intergration scenarios, while can be convenient if managed well in component local scenarios.

    # As you may have realized, some interesting facts:

    #   * Prototype based inheritance of class objects, actually serves as the corner stone for the implementation of class based inhertance for normal objects.

    #   * After constructed, a composite object with class inheritance will, technically act just like a prototype based one. The difference lies only in the construction process, where new instances of super classes are constructed to be the super object instances, instead of some shared existing super instances.
  }


  {## Methods and Magic Ones
   # - Procedures called in particular execution context

Procedures are always called with responsibility for some objects, in this sense they are said to be "methods" of those objects, or we can say those objects "own" those methods.

   #} {;
    {## Methods and Magic Ones #}
    export edh'mths'and'magic = bookmark()

    {## Method Binding, `this` and `that` Reference
     # - How contextual objects are decided and refered to

A procedure can be bound to one `this` object and one `that` object at the same time, so as to be a method of them.

ƒê solves the [Object Schizophrenia](https://en.wikipedia.org/wiki/Schizophrenia_(object-oriented_programming)) problem by providing separate `this` and `that` references, in additional to that `supers()` works with `that` practically.

     #} {;
      {## Method Binding, `this` and `that` Reference #}
      export edh'mth'binding = bookmark()

      {## Rule of Thumb
       # - Bindings are never changed, `that` can only derive from `this` if not `this`

An already bound method procedure will not be changed anymore, i.e. the binding is always kept intact, regardless of rules for how unbound procedures to be bound.

As a result of the binding rules (to be described in following sections), `this` can only be the same object as `that`, or one of the super objects of `that` object; to put it another way, `that` will either be just `this`, or a descendant object of `this`.

       #} {;
        {## Rule of Thumb #}
        export edh'binding'rot = bookmark()
      }


      {## Binding Rules for Dot-Notation
       # - Methods via object attribute resolution

Dot-notation is the most typical scenario for a procedure provide by an object (or its class) to be bound, when lhs of the dot-notation being evaluated is an object, it triggers object-attribute-resolution, and if it resolves to an unbound procedure value -

  * That object will be `that` object bound with the procedure, before it assumed the final result of the whole dot-notation.

The very procedure might not have been provided directly by `that` object -

  * It could be inherited from one of `that`'s super objects, in such cases, the super object (or its class) actually provided the procedure will be `this` object to be bound with the procedure, before it assumed the final result of the whole dot-notation.

  * Or `that` object has just provided the procedure by itself, then `this` object will be `that` object as well.

Finally the procedure is bound to `this` object and `that` object, so as to be a bound method of them, and the bound method assumes the final result value of the dot-notation.

       #} {;
        {## Binding Rules for Dot-Notation #}
        export edh'dot'mth'binding = bookmark()
      }


      {## Binding Rules for Import
       # - Methods via import

Procedures imported from some object (but other than a module object, usually be a namespace object e.g.) are, bound with the source object as both `this` and `that`, before put as attributes, into local scope or the import target object's object scope.

       #} {;
        {## Binding Rules for Import #}
        export edh'imp'mth'binding = bookmark()
      }


      {## Ad-Hoc Binding Rules
       # - Methods per current scope

Every scope has one `this` and one `that` as contextual objects, when calling an unbound procedure, the contextual `this` and `that` object are taken from current scope of the call site. The procedure is called as if it has been bound to such `this` and `that` object. So the binding happens only conceptually in this case, no physical binding would actually happen.

       #} {;
        {## Ad-Hoc Binding Rules #}
        export edh'adhoc'mth'binding = bookmark()
      }


      {## `this` and `that` Demonstrated
       # - This simple example should help you intuit it
       #} {;
        {## `this` and `that` Demonstrated #}
        export edh'mth'binding'example = bookmark()

        # %% #
        class C {

          method hello() {
            'Hello, this is ' ++ this ++ ", I know that " ++ that ++ ' is called.'
          }

          method what's'this() return this
          method what's'that() return that

        }

        class D extends C
        # %#

        # %% # Let's call an inherited method
        o = D()
        o.hello()
        # %# Both `this` and `that` refer to an contextual object per the method get called

        # %% # `this` refers to the object instance actually defined the method procedure (the callee)
        o.what's'this()
        # Note a method is usually defined by the class of an object, but an object instance is also allowed to define methods on its own right.

        # %% # `that` refers to the end object via which the method procedure is obtained (usually via at-notation)
        o.what's'that()

        # So in the case as demonstrated above:

        # %% # `that` refers to the end object `o`
        o.what's'that() is o

        # %% # `this` refers to `o`'s super object, whose class is `C`, which has provided the called method procedure:
        case o of {{ C: c }}
        -> c is o.what's'this()

        # %# There can be intermediate super objects involved, but no special syntax to obtain them.


        {## Rule of Thumb
         # - You know `this` better, and `that` is out of your reach

The rule of thumb to intuit `this` and `that` reference when you are writing code of a method:

  The enclosing class will provide the method you are writing, so the instance of it is "closer" to you, i.e. you can see exactly how other methods as well as other artifacts are implemented near the method procedure you are writting.

  `that` object must be of some descendant class derived from current enclosing class, you are not sure what new behaviors have been added to `that`, as well as how `that` has overrided the behaviors as implemented here in the enclosing class. So `that` is "farther" from you.

         #} {;
          {## Rule of Thumb #}
          export edh'this'that'rot = bookmark()
        }
      }

    }


    {## `super` Reference
     # - To obtain overridden attributes from super objects, by a descendant object

In a method overriding the super one from a descendant class/object, sometimes you still want to call the super implementation as part of the overriding implementation, you can refer to the super method with `super` at the lhs of a dot-notation to retrieve an attribute from the first super object providing it.

     #} {;
      {## `super` Reference #}
      export edh'super'ref = bookmark()

      # %% # Define a base implementation of a counter like this:
      data C(cnt) {

        method inc() {
          # Increase our cnt field atomically
          ai this.cnt += 1
          # And return the new value
          return this.cnt
        }

      }

      c = C(97)

      # %% # Run this cell multiple times to see it goes up well.
      c.inc()

      # %% # Now let's derive an implementation that can never go greater than 100
      class D { extends C
        method inc() {
          if super.cnt >= 100
          then console.error<| "No, it's enough, no further increament!"
          else super.inc()
        }
      }

      d = D(97)

      # %% #
      d.inc()

      # %# See how super is used in `D.inc()`?

      # Note that since there can be multiple super objects, you can not use `super` alone to obtain a single object value. While you can iterate all super objects obtained by `supers()`.
    }


    {## Magic Methods
     # - Customize object behaviors in responding to infix operators and some common procedures

In some cases, a method is not called as usual with an explicit surface syntax, but due to deeper reasons according to some hidden rules, so we say they are "magic method"s.

     #} {;
      {## Magic Methods #}
      export edh'magic'mths = bookmark()

      {## Special Magics
       # - Some construts will call specially named methods and honor their results
       #} {;
        {## Special Magics #}
        export edh'special'magics = bookmark()

        {## Null Test
         # - The `__null__()` magic

The `null()` utility will consult `__null__()` of an object value.

         #} {;
          {## Null Test #}
          export edh'null'magic = bookmark()

          # %% # An object is always considered non-null / truthy by default
          class C pass
          null( C() ) is false

          # %% # Unless it tells by itself, e.g. always falsy
          class C {
            method __null__() true
          }
          null( C() )

          # %#
        }


        {## Converting to String Forms
         # - For pretty show of objects
         #} {;
          {## Converting to String Forms #}
          export edh'str'magics = bookmark()

          {## String Representation
           # - The `__repr__()` magic

The `repr()` utility will consult `__repr__()` of an object value.

Especially note that all implementers should try the best to give the "repr" string in form of valid ƒê source code, and make it evaluates to a value equal to the original value, best to be identical, or instantly equal, or at least closely related. Though being invalid ƒê source is not technically prohibited, and sometimes unavoidable.

Note that the REPLs, `console.print()` and many other utilities use `repr()` to convert non-string values for the show, so a good `__repr__()` implementation is really beneficial.

           #} {;
            {## String Representation #}
            export edh'repr'magic = bookmark()

            # %% # Use a hard-coded value for simplest example
            class R {
              method __repr__() 'R()'
            }
            o = R()

            # %% #
            repr(o) is 'R()'


            # %% # It doesn't have to be a method procedure, a plain value will do too
            class R {
              method __init__() {
                this.__repr__ = 'R()'
              }
            }
            o = R()
            repr(o) is 'R()'

            # %#
          }
        }


        {## Converting to String Value
         # - The `__str__()` magic

The `str()` utility will consult `__str__()` of an object value.

         #} {;
          {## Converting to String Value #}
          export edh'str'magic = bookmark()

          # %% # Use a hard-coded value for simplest example
          class S {
            method __str__() 'SSS'
          }
          o = S()
          str(o)


          # %% # It doesn't have to be a method procedure, a plain value will do too
          class S {
            method __init__() {
              this.__str__ = 'SSS'
            }
          }
          o = S()
          str(o)

          # %#
        }


        {## Verbose String for the Show
         # - The `__show__()` magic

The `show()` utility will consult `__show__()` of an object value.

         #} {;
          {## Verbose String for the Show #}
          export edh'show'magic = bookmark()

          # %% # Use a hard-coded value for simplest example
          class W {
            method __show__() 'SSS'
          }
          o = W()
          show(o)


          # %% # It doesn't have to be a method procedure, a plain value will do too
          class W {
            method __init__() {
              this.__show__ = 'SSS'
            }
          }
          o = W()
          show(o)

          # %#
        }


        {## Verbose String for Description
         # - The `__desc__()` magic

The `desc()` utility will consult `__desc__()` of an object value.

         #} {;
          {## Verbose String for Description #}
          export edh'desc'magic = bookmark()

          # %% # Use a hard-coded value for simplest example
          class D {
            method __desc__() 'DDD'
          }
          o = D()
          desc(o)


          # %% # It doesn't have to be a method procedure, a plain value will do too
          class D {
            method __init__() {
              this.__desc__ = 'DDD'
            }
          }
          o = D()
          desc(o)

          # %#
        }


        {## Stringify to JSON
         # - The `__json__()` magic

The `json()` utility will consult `__json__()` of an object value.

If a string value is returned, make sure to follow the JSON format specification:
  https://www.json.org

Instead of a string, you can return other values convertible to JSON strings, e.g. lists or dicts, they'll be further stringified automatically. This is more idiomatic since the result data structures will be syntax highlighted and validated as ƒê source, while gotchas like trailing commas are took care of automatically.

         #} {;
          {## Stringify to JSON #}
          export edh'json'magic = bookmark()

          # %% # Use a hard-coded value for simplest example
          class J {
            method __json__() {
              "k": "V",
            }
          }
          o = J()
          json(o)


          # %% # It doesn't have to be a method procedure, a plain value will do too
          class J {
            method __init__() {
              this.__json__ = {
                "k": "V",
              }
            }
          }
          o = J()
          json(o)

          # %#
        }


        {## Instant Equality Test
         # - The `__eq__()` magic

The (==) and (!=) operator will consult `__eq__()` of its lhs object operand, then its rhs object operand if no conclusion from lhs.

But note that for possible vectorized comparison between some objects, the class should instead implement the infix operator magic, in the way described in the next section.

         #} {;
          {## Instant Equality Test #}
          export edh'eq'magic = bookmark()

          # %% #

          {##
           # Convert any value to string
           #}
          class Str {

            # Match any value
            method __match__(v) {
              return Str(v)
            }

            # Do the conversion
            method __init__( x ) {
              this.__str__ = str(x)
            }

            # Implement the string representation
            method __repr__() {
              return "Str(" ++ repr(this.__str__) ++ ")"
            }

            # Check only the string form
            method __eq__(other) {
              return str(other) == this.__str__
            }

          }

          # %% #
          s = Str(3*7)
          # %%
          s == '21'
          # %%
          '21' == s
          # %% #
          s != '22'

          # %#
        }


      }

      {## General Infix Operator Magics
       # - Responding to infix operators

All infix operators (even ones merely declared but not implemented) can be customized by object magic methods. The mechanism and syntax are described in this section.

       #} {;
        {## General Infix Operator Magics #}
        export edh'infix'magics = bookmark()

        # For an infix operator to be overridable by object magic methods, the operator procedure should return defaulting values.
        # Defaulting semantics is an advanced topic explained in another chapter:
        ; () => import (
          edh'defaulting, # <- follow this bookmark to the relevant section there
          **
        ) './advanced/appl'


        # %% # Let's demonstrate it with a simple new operator (*-*)
        {##
         # Concatenate values for demo purpose
         #}
        operator 0 (*-*) (lhv, rhv) {
          {#
The defaulting will be triggered when:

  * No magic methods present, i.e. for both lhs and rhs value, it is either not an object value, or being an object without the expected magic method
  * All magic methods report `NA` (effectively `default nil`) back

In case for the default, we just concatenate the operands as strings, with ' *** ' in between
           #}
          return default lhv ++ ' *** ' ++ rhv
        }

        # %% # See the default implementation works well
        'We the people' *-* 'are proud humans'

        # %% # Then let's define a class overriding the object behavior when involved in that operator
        class M {

          {##
           # For ease of identification
           #}
          method __init__( repr as this.__repr__ ) pass

          {##
           # LHS operand object behavior

This is the responding magic method when an object of this class is the lhs operand of the operator.

The method name needs to be verbatimly the operator symbol, quoted in a pair of parenthese.

           #}
          method (*-*) (other) {
            return this ++ ' <-- ' ++ other
          }

          {##
           # RHS operand object behavior

This is the responding magic method when an object of this class is the rhs operand of the operator.

The method name needs to be verbatimly the operator symbol, followed by an immediate dot (.), and quoted in a pair of parenthese.

           #}
          method (*-*.) (other) {
            return other ++ ' --> ' ++ this
          }

        }
        # %% # Construct an instance of the class
        m = M( 'MMM' )

        # %% # Check the lhs magic method works
        m *-* 'it is not KKK'

        # %% # Check the rhs magic method works
        "What's really matters?" *-* m
        # %#

        # %# Applicability & defaulting semantics are advanced topics described in another chapter
        ; () => {; import * './advanced/appl' # <- navigate to there for elaboration
          edh'na'semantics # <- follow this bookmark to the specific section there
        }

      }

    }

  }


  {## Host Objects
   # - Data structures & behaviors implemented in the host language

ƒê objects and classes are defined by scripting code as shown above, while the host programming language can be used to define native data structures and methods, then wrapped as ƒê classes and objects, for the scripting code to integrate various components together. The host programming langauge can usualy generate high performance machine code, that runs more energy-efficient for computation intensive tasks.

   #} {;
    {## Host Objects #}
    export edh'host'obj = bookmark()

    {#
`Vector` is a simple example of a host class that constructs & manipulates host objects, and implements magic methods to support fancy user interactions. See its implementation in Haskell (the host language):

  https://github.com/e-wrks/edh/blob/latest/host.hs/src/Language/Edh/Batteries/Vector.hs

Especially note though this class implements vectorized computation, it is not designed for performance but convenience. For high performance w.r.t. vectorized number crunching, as well as IEEE floating point number support, checkout HasDim at:

  http://github.com/e-wrks/hasdim

     #}

    # %% # A simple vector of ƒê values
    v = Vector( 3, 2, 5, )

    # %% # The (+) operator triggering its (+) magic method, which broadcasts the operation to all the elements
    v + 100

    # %% # The (+) operator triggering its (+.) magic method, doing the same when at rhs
    100 + v

    # %% # The (++) operator triggering its (++) magic method, doing the same broadcasting, while with string-wise concatenation as the (++) operator is applied element-wise
    v ++ 5

    # %% # The (++) operator triggering its (++.) magic method, doing the same when at rhs
    5 ++ v

    # %% # Vectorized comparison would return a result Vector of same length, with scalar result value per element
    v >= 3

    # %% # The comparison result Vector can be used as a filter to mask out unsatisfying elements as NA
    v[ v >= 3 ]

    # %% # The comparison result Vector can also be used as a mask to update only satisfying elements
    v[ v >= 3 ] += 100
    v

    # %% #
    v[ v > 10 ] ++= ", which is too large"
    v

    # %% # TODO impl. and demo. `.map()` `.update()` etc.

    # %% # All of its methods are host procedures defined into the host class
    dir$ Vector
    # %#
  }

}


{## Modules
 # - A unit of sharing for artifacts in a world

Usual module objects are loaded from `.edh` files from os filesystems, as one getting imported.

Except for the entry module, in a particular ƒê world, one particular `.edh` file, can have only one module object created and initialized from the file content, later imports resolved to the same file will just reuse the initialized module object as the source, effectively making such modules globally shared world-wide.

Note for security reasons, sandboxed code is prohibited from performing os file oriented importing, though it is allowed to import from existing objects (including module objects), i.e. the import can only succeed if the source expression evaluates to some object but not strings or other type of values.

Note that technically, a distinct module object can be created by calling the `module` class as an object constructor, but that's rarely done.

 #} {;
  {## Modules #}
  export edh'modules = bookmark()

  {## Reflective Attributes in a Module
   # - Every module object contains some meta attribute to reflect its source information
   #} {;
    {## Reflective Attributes in a Module #}
    export edh'modu'meta'arts = bookmark()

    # %% # It should at lease contain the `__name__` attribute
    __name__

    # %% # File modules should contain `__file__` for absolute file path of the source file as well
    __file__
    # %% # Also `__path__` to be used as basis for relative import from within the very module
    __path__

    # %#
  }


  {## Import & Export
   # - Sharing & reusing

All defining expressions can be prefixed with the `export` keyword for the result artifact to be listed as exported from contextual `this` object, unless evaluated in a _pure_ context. And it's possible for a block expression to be prefixed with the `export` keyword, so all artifacts defined within that block are exported. All objects can export artifacts for others to import.

The general syntax for importing is:

  import <args-receive-spec> <import-source> [into <receiver-object-reference>]

The <import-source> are usually literal strings to specify global modules loaded from os filesystems. Dynamic strings are supported, but discouraged. Loaded modules are uniquely identified by the canonical full absolute path of its source file, thus globally shared.

The <import-source> can also evaluates to an existing object value, the os filesystem will not be consulted in this case.

Then exported artifacts from the source object (directly specified or loaded from os file) are received as specified by the receive specification, usually into current scope, or into an object as specified after the `into` keyword.

   #} {;
    {## Import & Export #}
    export edh'imp'exp = bookmark()

    {## Relative Import
     # - From a file module loaded from an os file relative to the importer

When the <import-source> evaluates to a string started with a dot character (`.`), it is interpeted as relative import, and with the value of `__path__` in scope as base path, the os filesystem will be consulted, to check existence of the following files in turn:

  <__path__>/<import-spec-string>.edh
  <__path__>/<import-spec-string>/__init__.edh

The first matched existing file will be used as the source file for the import; or the import fails.

     #} {;
      {## Relative Import #}
      export edh'rel'import = bookmark()

      # TODO examples in code cells
    }


    {## Absolute Import
     # - From a file module loaded from the file relative to `edh_modules` directory

When the <import-source> evaluats to a string not started with a dot character (`.`), it is interpeted as absolute import from a specific file module. The os filesystem will be consulted, regarding the process working directory (pwd) of the ƒê runtime. In production deployment of ƒê packages and projects, for specific dependencies to be localized while common dependencies shared, the search algorithm for an ƒê runtime to resolve absolute import is like this:

  * Starting from pwd (process working directory), with such a target directory, perform the following match. When succeeded use the matched os file as source file of the import; when the match failed, resort to use parent directory as the new target directory then repeat the match, until reaching the root directory (/), then the import fails.

  * Check whether there is a subdirectory named `edh_modules` directly in the target directory, if not, the match fails; or check existence of the following files in turn:

    edh_modules/<import-spec-string>.edh
    edh_modules/<import-spec-string>/__init__.edh

The first matched existing file will be used as the source file for the import; or the match fails.

     #} {;
      {## Absolute Import #}
      export edh'abs'import = bookmark()

      # TODO examples in code cells
    }


    {## Module Loading, Cyclic Imports
     # - How modules are loaded, with possible cyclic references

After a module has been successfully loaded, it is the easist case to import from it, just have all its exported artifacts as if sent to a keyword-only ArgsPack, and let the args receiver specified by the import expression to receive from that apk.

The first importer of a module is responsible to load that module, by executing the module's top level statements sequentially; there are chances for other modules happen need to import the same module before the first importer finished loading the module, such a later importer behave differently regarding whether it is running synchronously with the first importer:

 * If a later importer is running on the same thread as the first importer, it's aparently a cyclic importing case, i.e. the module pending loaded is being imported again by some other module being imported by the former module, and the first importer of the later module turns out to be on the same thread too. We can not wait the former module to finish loading in this case, or it's deadlock, so those artifacts as many as already exported will be packed and received as for the later import procedure. ƒê is strict in module loading, and without the loading procedure separated into more phases (such as definition + resolution), this will be surprising someone at times, but the advantage is `import` expressions can be arbitrarily mixed with other types of statements.

 * If a later importer is running on a thread other than the first importer, it's a simple concurrent importing case. The later importer will be registered into a wating list of the first importer, whether the first importer has succeeded loading the module or failed at it, the result will be propagated to all waiters in the list, they'll see the failure or success as if they have done the loading by themselves, and proceed accordingly.

     #} {;
      {## Module Loading, Cyclic Imports #}
      export edh'modu'load'cyc = bookmark()

      # TODO examples in code cells
    }
  }


  {## Entry Modules
   # - The starting point of an ƒê program

An ƒê program is always started to run either an ƒê file or an ƒê module, in either case, the file content will be parsed then executed, contextual scope of the execution will be the (module) object scope of a newly created module object, the created module object will be both `this` and `that` object of the execution scope.

   #} {;
    {## Entry Modules #}
    export edh'entry'modus = bookmark()
  }

}


{## Hierarchical Scopes, Static & Dynamic
 # - The static hierarchy of lexical scopes and the dyamic hierarchy of call frames

Each scope is backed by an entity with various attribute values identified by distinct identifiers, the set of attributes can be ever changing at runtime.

 #} {;
  {## Hierarchical Scopes, Static & Dynamic #}
  export edh'scope'hierarchies = bookmark()

  {## Static / Lexical Scoping
   # - Scope hierarchy per source code organization

"Lexical" here refers to text, you can intuit the static outer scope as the one within which, the piece of code that would create the (lexical inner) scope of interest, is written.

Per each ƒê world, there is a root scope (being an object scope as of the root namespace per se), then all loaded modules live inside the root scope, i.e. each module scope is a direct inner scope of the root scope lexically. Note the root scope is exceptional w.r.t. the lexical semantics, its source code lives as part of the startup code of the ƒê runtime, so does not really hold the "lexical" relationship to souce code of modules, but you'd better assume an imaginary such lexical relationship, for coherence of intuition. Many runtimes of other programming languages just inject builtin artifacts into each module's toplevel scope, the ƒê runtime is just a little different in here.

Per each module as it being loaded, the evaluation/execution of nested namespaces and scoped blocks will create inner scopes right away, each namespace scope and block scope can have further inner namespaces and scoped blocks with arbitrary levels of nesting.

Procedures can be defined inside a module scope, a namespace socpe, or a block scope, which already be at some where inside the hierarchy of lexical scopes. A procedure upon each time being called, will create a new procedure scope, to receive arguments passed to it, and further foster execution of the procedure body.

Though procedure scopes are created dynamically after the module has finished loading, they are considered statically related to their respective outer scope in lexical semantics, for the lexical intuition to hold up.

   #} {;
    {## Static / Lexical Scoping #}
    export edh'lexi'scoping = bookmark()

    {## Lexical Attribute Resolution
     # - Seeing & shadowing attributes from lexical outer scopes

If not at rhs of a dot-notation, an attribute reference will always direct into the current scope when used as an assignment target;

While used for attribute value reading, such an attribute has to present in the current scope, or some lexical outer scope, for the read to succeed.

So the world root scope serves the ultimate default provider, for attributes that globally shared.

And shadowing is a natural consequence when an attribute identified by some key presents in an inner scope, so as for the attribute value by the same key, living in any of the lexical outer scopes, to be shadowed. Until an attribute is deleted from the inner scope, the shadowed attribute(s) from outer scopes can never be seen from within the inner scope and its further nested inner scopes.

     #} {;
      {## Lexical Attribute Resolution #}
      export edh'lexi'attr'resolv = bookmark()

      # %% # We demonatrate it with a scoped block here
      x = 'outer-value'
      {@
        console.print$ 'Inside, before local attr definition, x is: ' ++ x
        # Upon entering a scoped block, a new lexical inner scope (backed by a separate entity) is created right away, then attributes can be defined locally. And an attribute present in an inner scope shadows all ones with the same name from outer scopes.
        x = 'inner-value'
        console.print$ 'Inside, after local attr definition, x is: ' ++ x
        # Dynamic deletion of an attribute works and matters here
        x = nil
        console.print$ 'Inside, after local attr deleted, x is: ' ++ x
        # All attributes left in a scope will be discarded, after control leaves the scope (unless some procedures defined in the scope are sent out and kept live elsewhere, as those procedures _enclose_ their lexical contextual scopes)
        x = 'inner-again'
      @}
      console.print$ 'Outside, x is: ' ++ x
      # %# No access to artifacts in an inner scope from outer

      # Note it is an anti-pattern to shadow attributes living in outer scopes, the code above is for demonstration purpose only and not idiomatic. Scoped blocks should be just used to discard its scope attributes upon leaving, it's discouraged to override attributes available from outer scopes like that.
    }

  }


  {## Coarse Grained Closure
   # - A procedure always captures the full lexical context where it is defined

As a consequence of the way attributes are resolved lexically, a procedure remembers the full hierarchy of its lexical outer scopes as in where it is defined. We say a procedure captures its enclosing context as a closure.

Note that ƒê closure is rather coarse grained compared to many other programming languages, closures there usually capture individual "variables" accessible to them when defined, while in ƒê it is actually the entities behind the lexical scopes get captured.

   #} {;
    {## Coarse Grained Closure #}
    export edh'closure = bookmark()

    # Such closure semantics is designed to allow dynamic evaluation/execution of ƒê snippets anywhere anytime, honoring entities being integral units of information, without individual attributes teared apart.

    # But it may lead to unintentional resource leaks, especially if you've been used to closures in other mainstream programming languages.

    # TODO demonstrate gotchas of resource leaking due to the coarse grained closure.

  }


  {## Dynamic / Call-Stack Scoping
   # - Scope hierarchy per nested procedure calls

Each procedure during its execution can call other procedures, such a call would stack the callee's procedure scope (together with other information, forming a call-frame) upon the caller's call-frame, which in turn is upon the caller-of-caller's call-frame, all the call-frames form the call stack of current execution thread's context.

In the call-stack hierarchy of call-frames, each call-frame corresponds to a procedure and its procedure scope per the undergoing call. At the bottom of the call-stack would usually be a special call-frame that corresponding to the module initialization procedure and the module scope.

We say the caller's procedure scope is the dynamic outer scope to the callee's procedure scope. As a procedure can be called from anywhere by any procedure, "dynamic" here means unknowing of the calling procedure and what's in scope of the callier.

   #} {;
    {## Dynamic / Call-Stack Scoping #}
    export edh'dyn'scoping = bookmark()

    {## Dynamic Effect Naming & Resolving
     # - Define and use effects dynamically

Effectful artifacts live in a separate namespace side by side with each scope.

Current ƒê interpreter implements it by putting an attribute named `__effects__` of dict value into each scope when the first effectful artifact is defined into it, that `__effects__` dict will receive subsequent effectful artifacts since then on, and serving the source for effect resolution against its owning scope. It is so made easy to observe what effects present in a scope from REPL and other interactive mechanisms, but such technical implementation details may change in the future.

Effectful artifacts can be procedure values, or immutable numerical values, string values etc. as for configuration purpose, actually they can be arbitrary values, e.g. it is not uncommon for event sinks to be effectful artifacts.

     #} {;
      {## Dynamic Effect Naming & Resolving #}
      export edh'eff'naming'resolving = bookmark()

      {#

The syntax to define effectful artifact(s) into current scope is:

  effect <attr-defining-expr>

The <attr-defining-expr> can be any expression, including block expression, such an expression or all nested expressions within a block there will be directed to effect namespace for all attribute definition behaviors. Typical examples include:
  * direct attribute assignment i.e. application of the infix (=) operator with a direct attribute addressor at lhs
  * term definitions i.e. application of the infix (:=) operator
  * procedure definitions
  * imports

       #}
      # %% #
      effect x = 5

      effect y := 3

      effect method f(n) n+1

      # %# Note this can not succeed
      effect import * 'some/exported/effects'

      # %% # See the `__effects__` dict now in current scope
      dir

      # %#


      {#

The general syntax to call out an effectful artifact is:

  perform <effect-attr-name>
  behave <effect-attr-name>

The two keywords have different semantics when the call-out expression is evaluated in a procedure which is called as an effectful procedure:

  * `perform` will only search outer scopes relative to where the called procedure is effectfully resolved
  * `behave` will search the full call stack, so reentrant to the same procedure is possible

They are semantically the same when evaluated for a procedure otherwise called normally.

Rule of thumb is to use `perform` whenever possible, think about and try avoid infinite recursive effect calls when you have to use `behave`.

The target attribute will be searched against all outer scopes in their respective effect namespace, until one is found, or upon bottom of the call stack is reached, a runtime error ensues.

       #}

      # %% #
      perform x

      # %% #
      perform y

      # %% #
      perform f(7)

      # %#

      # Idiomatic usages of effectful artifacts are further described in a later section
      ; () => edh'eff'tracking # <- following this bookmark to that section
    }

  }


  {## `this` and `that` Reference in Scope
   # - Contextual objects bound to scopes
   #} {;
    {## `this` and `that` Reference in Scope #}
    export edh'this'that'in'scope = bookmark()

    # Every scope has one `this` object and one `that` object designated, they can be the same object or have `that` being a descendant object of `this`, as a result of [Method Binding] described in an earlier section
    edh'mth'binding # <- follow this bookmark to that section

    # When a bound procedure is called, `this` and `that` to be in the new procedure scope will, exactly reflect what have been bound to the procedure. Otherwise `this` and `that` in scope of the call site will be inherited by the new procedure socpe.

    # For object initialization procedures, both `this` and `that` will refer to the very object being initialized, that can be a module, a namespace, or a class object.

  }

}


{## Expression Values and Scope Wrapprs
 # - Dynamic evaluation of any expression, anytime, anywhere

A procedure is always called against some object, it also has a formal declaration of all its input arguments, what if we strip off these properties? The result is: we get expressions.

Expression is a 1st class type of values in ƒê.

A scope can be wrapped as an object, for reflective evaluation of ƒê expressions, or direct attribute manipulation to be done as in that scope.

 #} {;
  {## Expression Values and Scope Wrappers #}
  export edh'exprs'in'scopes = bookmark()

  {## The `expr` Expression
   # - Literal expressions

An arbitrary expression following the `expr` keyword will create a literal value of `ExprType`.

At the time an `expr` is defined, immediate values can be interpolated into the defined literal expression value, each immediate expression quoted within a pair of curly braces augmented with '$' will be evaluated at the `expr` definition time, and interpolated as literal values embedded in the result expression.

   #} {;
    {## The `expr` Expression #}
    export edh'expr'expr = bookmark()

    # %% # It can be assigned as an attribute of current scope like any other values
    x = expr a + b * c

    type$ x
    # %# See its type

    # %% # Its textual representation is its original source text
    repr$ x

    # %# An expression created this way will have its original source reserved, to serve as its `repr`.


    # %% # To demonstrate the interpolation
    let ( a, b, c, ) = ( 3, 7, 5, )
    x' = expr a + {$ b*c $} * c

    repr$ x'
    # %# See how the expression between `{$` and `$}` is eagerly evaluated and interpolated

    # A literal value interpolated will give its `repr` in place of the original `{$ $}` segment, for `repr` of the whole literal expression value.

    # %% # Check it evaluated in the reflective way
    scope().eval( x' )

    # %# Note that `scope().eval()` is described in the next section below

  }


  {## Scope Wrappers
   # - Scopes wrapped as objects

`scope` is a class, thus an object constructor, comes with the ƒê runtime.

   #} {;
    {## Scope Wrappers #}
    export edh'scope'wrappers = bookmark()


    # Without argument, everytime you call `scope()`, it creates an object wrapping the scope of the calling site.

    # %% # Let's use a hierarchy of nested procedure scopes for the demonstration
    method f() {
      # Put these into the outer procedure scope
      let ( c, d, ) = ( 2, 8, )

      # Call an ad-hoc arrow procedure to get its procedure scope wrapped, for later observation of lexical structure of scopes with that as the tip
      return ()|() => {
        # Put these into the inner procedure scope
        let ( a, b, ) = ( 7, 3, )

        # Wrap and return current scope
        return scope()
      }
    }
    s = f()
    'inner has ' ++ s.attrs() ++ ', outer has ' ++ s.outer.attrs()
    # %#

    # %% # Evaluate some expression in the outer scope and see how it's changed
    s.outer.eval(expr
      e = c / d
    )
    dir$ s.outer

    # %% # Evaluate some expression in the inner scope and see how it's changed
    s.eval(expr
      e = 3*a - 5*b + c - 7*d
    )
    dir$ s
    # %#


    # %% # If an object is passed as ctor argument, it creates a wrapper object for the object scope of that object
    class C pass
    o = C()
    s = scope(o)
    s.attrs()
    # %# It's empty as no attribute is defined by a bare object

    # %% # We can put some attributes into it
    s.put( a= 3, c= 7, b= 5, )
    dir$ s

    # %% # Expression evaluation works with an object scope as well
    s.eval(expr
      d = a + b / c
    )
    dir$ s
    # %#

  }


  {## Expression Arguments to Procedures
   # - Arguments are passed in expr form, to interpreter procedures and 3-arg operator procedures

For an interpreter procedure or an infix operator procedure with 3 positional arguments, the first argument will be wrapped scope object of its caller, and rest arguments are all expression values.

   #} {;
    {## Expression Arguments to Procedures #}
    export edh'expr'args = bookmark()

    # %%
    x' = makeExpr( a + b * c )

    repr$ x'
    # %# See its textual representation is in AST form, with rather verbose source location information, no original source text is reserved for expressions created this way

    # %% # While it can be reflectively evaluated as well
    s.eval( x' )

    # %#

  }


  {## Code as Data
   # - A runnable piece of ƒê code is just data from the perspective of the host language/runtime

ƒê host procedures (written in Haskell) see ƒê AST directly.

TODO expand this section.

   #} {;
    {## Code as Data #}
    export edh'host'proc'exprs = bookmark()
  }

}


{## Pure Context
 # - For attribute defining side-effect to be suppressed

There are cases it's desirable to cease the side-effect of attribute creation into current scope, for some artifact-defining statements/expressions. E.g. an ad-hoc named value as an argument passed to some API. Some contexts are considered "pure" in ƒê code, for this to happen automatically.

 #} {;
  {## Pure Context #}
  export edh'pure'ctx = bookmark()

  # %% # First make sure `x` is not in scope, by deleting the attribute
  x = nil

  # %% # Come back later to run this cell, it should evaluates to `true` when `x` is not defined as expected
  this?x is nil
  # %#

  # %% # A parenthese quoted expression (no matter how complex it is), is evaluated in a pure context
  ; ( x := 5 )

  # %% # A standalone arguments packer expression is evaluated in a pure context
  ; ( x := 5, )

  # %% # Expressions for arguments within a call expression are evaluated in a pure context, you can intuit that there is just an arguments packer expression there
  show( x := 5, )

  # %% # The ($) and (|) operator, they all make calls, would pack the arguments likely, i.e. in a pure context
  show$ x := 5

  # %#

  # %% # Likely method definition expressions work the same way
  f = nil
  ; ( method f(x) x+1 )
  ; ( method f(x) x+1, )
  show( method f(x) x+1 )
  show$ method f(x) x+1
  this?f is nil
  # %#

}


{## Dynamic Effect Tracking
 # - Tracking effects dynamically, the procedural way

Dynamic effecting tracking is not sound, bears pretty all the shortcomings of a dynamic typing language / runtime. It is not a replacement of, but a bridge to, more formal effect systems with static typing and analysis tools. The monadic effect system is widely recognized and practiced with industrial strength, but with less ideal ergonomics to scale to wider commercial adoptions; algebraic effects & handlers seems more promising, but yet to be practically implemented and battle-tested, before widely adopted.

 #} {;
  {## Dynamic Effect Tracking #}
  export edh'eff'tracking = bookmark()

  {## Technical Basics
   # - How it works in simple cases

It would seem redundant & unwieldy for this simple scenario, but the key is the ability for effect-callouts to penetrate call frames across the stack, or all intermediate procedures would have to explictly list relevant arguments and merely pass them on to inner callees, which is unrealistic or at best a nightmare for realworld integration scenarios.

A Monad can encapsulate all possible effects, and allow inner computations nested arbitrarily deep to callout these effects, so long as it is a monadic computation in the said Monad. Algebraic Effects & Handlers solve this problem as well, with more open constraints.

*Dynamic Scoped Effects* as you've seen, solves it as well.

   #} {;
    # Effect System is an advanced topic in another chapter
    import * './advanced/effs'
    edh'effs # <- follow this bookmark to the section there

    {## Technical Basics #}
    export edh'eff'tech'basics = bookmark()

    # %{ #

    # %% #

    method effectfulHello() void {

      # Customize the word used in the greeting phrase
      effect greetingWord = 'Hello'

      # Ask the running environment for a pharase to use
      greetMsg = behave greetingPhrase()

      # The phrase goes to stdout as so implemented here
      console.print$ greetMsg

    }

    method effectfulApp( ) void {

      # Customize the greeting phrase a greeter would like to use
      effect method greetingPhrase() {
        # Ask the running environment about what greeting word to use,
        # then given we are facing the curious world, let's speak of it.
        return behave greetingWord ++ ', world!'
      }

      # We start with a greeting
      perform greeter()

      # Then do things ...

    }


    # %% # It can be called like this

    effect greeter = effectfulHello

    effectfulApp( )

    # %}

    # %#
  }


  {## Symbolic Names are Idiomatic
   # - To avoid name clashing for effects across frameworks / libraries

In an integrated system, there are times you need to compose effects from independently developed components (by different vendors e.g.), no mechanism can effectively coordinate a clashing-free naming convention, if only alphanumeric names are legitimate.

   #} {;
    {## Symbolic Names are Idiomatic #}
    export edh'sym'eff'names = bookmark()

    # For example, these 2 pieces both want to demand an effectful passphrase via the alphanumeric name `passphrase`

    # %% #
    namespace private'force () {

      method launch'missiles() {
        if 'for~good~profit' != perform passphrase
        then error( "We don't serve voluntarily!")
        console.info<| "Destroying enemies!!!"
      }

    }

    # %% #
    namespace un'peacekeepers () {

      method auth'attack'by( army'force ) {
        if 'for~world~peace' != perform passphrase
        then error( "We don't serve evil!")
        army'force.launch'missiles()
      }

    }

    # %% # The 1st piece can work alone like this
    {@
      effect passphrase = 'for~good~profit'

      private'force.launch'missiles()
    @}

    # %# But no simple composition of them can work together right

    # %% # Neither this
    {@
      effect passphrase = 'for~good~profit'

      un'peacekeepers.auth'attack'by( private'force )
    @}

    # %% # Nor this
    {@
      effect passphrase = 'for~world~peace'

      un'peacekeepers.auth'attack'by( private'force )
    @}

    # %#

    # Some times you can coordinate the vendors to use distinct names, but not always; Or you can persuade the vendor whichever closer to you, to honor the other's choice that assumed unchangable; Yet that's not always possible, especially after complexity within those components scales up.


    # Well, it would not be a problem, if all parties used symbolic effect names in the first place

    # %% #
    namespace private'force () {
      symbol @passphrase

      method launch'missiles() {
        if 'for~good~profit' != perform @passphrase
        then error( "We don't serve voluntarily!")
        console.info<| "Destroying enemies!!!"
      }

    }

    # %% #
    namespace un'peacekeepers () {
      symbol @passphrase

      method auth'attack'by( army'force ) {
        if 'for~world~peace' != perform @passphrase
        then error( "We don't serve evil!")
        army'force.launch'missiles()
      }

    }


    # %% # Then they can be composed right this way:
    {@
      effect @( private'force.passphrase ) = 'for~good~profit'
      effect @( un'peacekeepers.passphrase ) = 'for~world~peace'

      un'peacekeepers.auth'attack'by( private'force )
    @}

    # %#
  }

}
