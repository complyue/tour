{## Syntax, Semantics, and Pragmatics of ƒê #}

{## ƒê Grammar Details #}
export edh'grammar'details = bookmark()


{## Overview
 # - Why and What is here with ƒê

ƒê seeks to ease development of embedded DSLs (Domain Specific Langauges) speaking / realizing business needs, i.e. a Business Integration language. How computers work and to be optimized in solving programming problems, are addressed by a large research discipline in its own right, i.e. Computer Science. But CS is too different and often too far from practical needs of realworld business, dedicated languages are of much interest, and ƒê attempts to be a comprehensive solution.

**ƒê (Edh)** stands for **Event Distributing & Hosting**, an _event_ is a consistent (but not necessarily atomic) piece of data, encapsulating the information of something just happend in one place, and sent to another place for its consequences to be realized there. _Event_ is conceptually coherent to **Algebraic Data Type** in _type theory_ as well as a functional programming language, but it's not practical to be a mechanical utility in a procedural langauge like ƒê. So _event_ stays conceptual in ƒê the language.

The _event_ abstraction should decouple much of the complexity, and degrade much part of the problem, to be solvable by _Citizen Developers_, especially with the aid of modern software engineering toolings.

You will be using ƒê to describe reactions to incoming events from other parts of the system, in forms of local entity attribute updates, and more complex logics with control flows. As well, you can post commands for event delivery, to other parts of the system. Modularized components can be developed for reuse, by your team or by 3rd parties. Realworld systems are inherently effectful, any event upon it is distributed / hosted, usually implies effects it should cause, you will also use ƒê to describe what effects are expected to be there, and how those effects should be realized. Note effects are inherently context sensitive, as a fairly sophisticated effect is usually implemented by means of other effects, those maybe simpler but nevertheless sensitive to their own context.

**Monad** is state of the art way for effect tracking, while **Algebraic Effects & Handlers** being actively researched in academic for similiar purpose today, but they both work with functional programming langauges. Then inspired by **Algebraic Effects & Handlers**, ƒê implements **Dynamic Scoped Effects** for effect tracking in the imperative / procedural paradigm. It is **Dynamic Scoping** per se. Historically, **Dynamic Scoping** designs are proved failures, but with ƒê's dedicated syntax / namespacing to have dynamic artifacts isolated from lexical artifacts, the confusing semantics / behaviors can be avoided, and then finally done right.

 #} {;
  {## Overview #}
  export edh'lang'overview = bookmark()
}


export edh'syntax = bookmark()


{## Syntax & Style
 # - ƒê code style is officially opinionated
 #} {;
  {## Syntax & Style #}
  export edh'syntax'style = bookmark()

  {## The Official ƒê Code Formatter
   # - Any style you like, so long as it is formatted such

ƒê encourages (turns-on-by-default) format-on-save, by the official no-config, uncompromised formatter:

  https://github.com/e-wrks/edh-vscode-formatter
  https://marketplace.visualstudio.com/items?itemName=ComplYue.edh-vscode-formatter

The motivation of such a formatter is quite inspired by Black:

  https://black.readthedocs.io

That's to save you time and mental energy for more important matters.

FYI, the original idea comes from Henry Ford's famous quotes about the Model T:

> Any customer can have a car painted any colour that he wants,
> so long as it is black.

Also opinionated formatters with similar goals:
  https://prettier.io  - Prettier for JavaScript (and HTML, CSS etc.)
  https://github.com/tweag/ormolu  - Ormolu for Haskell

   #} {;
    {## The Official ƒê Code Formatter #}
    export edh'code'formatter = bookmark()

    # Home page of the formatter should have described the rules and your rights (freedom) well. After modification, save it, or right-click anywhere, then select [Format Document], the formatter will adjust the file content according to the rules, you'll see what it thinks.

    # %% # try play with this cell:
    # indent or outdent the line, add/remove extranous spaces, break it into multiple lines, add extranous blank lines, ...
    1+ ( 2 - 3 ) *5 /9
    # %#

    # TODO any gotcha to be showcased here?
  }

  {## Indentation and Brackets
   # - ƒê interpreter is whitespace insensitive, indentation is enforced by ƒê formatter

The programmer is responsible for the brackets (scoping), while the formatter is in charge of proper indentation, it infers indentation level of each line from the nesting of brackets.

   #} {;

    {## Whitespace Sensitivity is Outdated
     # - Indentation can be inferred, no reason to DIY today

> Why Python‚Äôs whitespace rule is right
  https://unspecified.wordpress.com/2011/10/18/why-pythons-whitespace-rule-is-right

> There is not a single situation in any country, in any programming language, or at any skill level, in which is it acceptable to not indent your code the way Python requires it.

This is much agreeable even at today.

> When you really analyse it, Python‚Äôs whitespace sensitivity is actually the only logical choice for a programming language, ...

Well, this conclusion holds right in its time, when auto code formatters are still some luxury to have. But today, besides the compiler(s), we are affording way more expensive analyzing tools like linters, test runners, coverage, profilers, and usually comprehensive langauge servers, amongst what code formatters become rather commonplace.

Scopes (either lexical or conceptual) have to be decided and expressed by the programmer (or document writer), but even excluding extreme cases, a code block can consist of up to hundreds of lines, it's ridiculous to manually maintain proper indentation for every line, when the formatter can do it for you straight forward.

Whitespace sensitivity has become outdated today, brackets (curly, square or round) come handy-dandy to express various scopes in your mind, just leave indentation for the formatters to care about.

     #
     #} {;
      {## ƒê is Whitespace Insensitive #}
      export edh'sps'insensitivity = bookmark()

      {## Comments are Indented as well
       # - Both line comment and block comment

As you may have noticed, block comments (started with `{#`) are indented, also a line of comments are indented when it starts with #, whether it is a standalone line comment, or part of a block comment.

       #} {;
        {## Comments are Indented as well #}
        export edh'cmt'indent = bookmark()

        # This is a standalone comment line, will always be indented by the formatter. Try adjust the indentation level of any line in this section, then save or do [Format Document] to see how the formatter corrects your mistakes.

        {# This is a short block comment #}

        {# This is multi-line block comment

         # This line is part of the outer comment block, but will be indented by the formatter, as it starts with #.

Try remove the leading # of the line above, then adjust its indentation level, you'll see the formatter stops working against you.

         #}

        {## This is a doc comment
         # A doc comment makes sense when placed:
         #  * At the very beginning of an ƒê module file
         #    - Serving as the documentation for that whole module
         #  * Immediately before a block
         #    - Serving as the documentation for that nested block
         #  * Immediately before a statement
         #    - Serving as the documentation for whatever defined by that statement, possible being:
         #      * A procedure
         #      * A class
         #      * An attribute
         #}
        edh'documented'attr'example'œÄ = 3.14
      }

    }

  }


  {## Semicolons and Commas
   # - They are optional everywhere in ƒê, unless for disambiguation
   #} {;
    {## Semicolons and Commas #}
    export edh'semicolons'and'commas = bookmark()

    {## Technically Optional
     # - That is, can be omitted

Semicolons can be really technically omitted in ƒê, not the case like in JavaScript that the language does:
  > Automatic Semicolon Insertion
  https://tc39.es/ecma262/#sec-automatic-semicolon-insertion

Which means, leading ones, trailing ones, as well as middle ones, all can be omitted.

     #} {;
      {## Technically Optional #}
      export edh'omit'semicolon'and'commas = bookmark()

      # Let's see some examples with the idiomatic form pointed out.

      # The following 5 cells have identical semantics and equally evaluates a block, gives out the value of last assignment statement in it
      # %%
      { a=5; b=3; c=9; }
      # %%
      {; a=5 b=3 c=9 } # <- idiomatic one
      # %%
      { a=5 b=3; c=9 }
      # %%
      { a=5 b=3 c=9; }
      # %%
      { a=5 b=3 c=9 }
      # %#

      # The following 5 cells too, have identical semantics and equal result value of a dict
      # %%
      { 'a': 5, 'b': 3, 'c': 9, } # <- idiomatic one
      # %%
      {, 'a': 5 'b': 3 'c': 9 }
      # %%
      { 'a': 5 'b': 3, 'c': 9 }
      # %%
      { 'a': 5 'b': 3 'c': 9, }
      # %%
      { 'a': 5 'b': 3 'c': 9 }
      # %#

      # The following 5 cells too, have identical semantics and equal result value of a list
      # %%
      ; [ 5, 3, 9, ] # <- idiomatic one
      # %%
      ; [, 5 3 9 ]
      # %%
      ; [ 5 3, 9 ]
      # %%
      ; [ 5 3 9, ]
      # %%
      ; [ 5 3 9 ]
      # %#

      # The following 5 cells too, have identical semantics and result value of a positional-only ArgsPack
      # %%
      ; ( 5, 3, 9, ) # <- idiomatic one
      # %%
      ; (, 5 3 9 )
      # %%
      ; ( 5 3, 9 )
      # %%
      ; ( 5 3 9, )
      # %%
      ; ( 5 3 9 )
      # %#
    }

    {## Disambiguation Needs
     # - At times, a semicolon / comma is needed for disambiguation
     #} {;
      {## Disambiguation Needs #}
      export edh'disambiguation'needs = bookmark()

      {## Disambiguate Unintended Indexing / Calling #}
      export edh'disambig'idx'call = bookmark()

      # Noticed the semicolons before each pair of square/round brackets? Why are they there?

      # The answer is: There usually need a semicolon before a pair of square/round brackets, when you don't mean to do indexing or calling against artifact before it.


      {## Disambiguate Block from Dict #}
      export edh'disambig'blk'dict = bookmark()

      # You may have noticed the semicolons everywhere, each following an opening curly brace too. Why are they there?

      # %% # Well, check out this:
      type( {; } )
      # %% # Then this:
      type( {} )
      # %#

      # The answer is: The semicolon inside `{;}` disambiguates it being a block (though empty) instead of an empty dict expressed as `{}`

      # FYI, in ƒê, block is a type of expression (instead of statement as in C family languages). A block encloses arbitrary number of statements, and evaluates to the value of the last statement when executed (with the exceptin of branches' early break, though, about that later)
      # %% # And an empty block evals to `nil`, check this to be true
      {; } is nil
      # %#

      # Though you don't need a semicolon when there is at least 1 statement in a block, e.g.
      # %% # This is a block with a single assignment expression statement
      { a=1 }
      # %% # But this is the idiomatic form, which is preferable for foolproof modifications in later code maintenance:
      {; a=1 }
      # %#

      # Finally, a comma to disambiguate ArgsPack (a super type of Python tuple), from parenthese-quoted single expression
      # %% # A single argument pack
      ; ( 3*7, )
      # %% # A parenthese-quoted expression
      ; ( 3*7 )
      # %%
      ; type( ( 3*7, ) )
      # %%
      ; type( ( 3*7 ) )
      # %#
    }

    {## Idioms
     # - Idiomatic Semicolon / Comma Placements

In ƒê code it's considered idiomatic to:

* Avoid semicolons without good reasons
* Place trailing commas where possible

     #} {;
      {## Idioms #}
      export edh'semicolon'comma'idioms = bookmark()

      # The idiomatic style is to put a semicolon right after the opening curly brace/bracket, when a block instead of dict literal intended:
      {;
        # It can still parse as dict literal with comments inside, if without the semicolon
      }

    }

  }


  {## Recommended Line Length
   # - It is under your control, well some advice here

For the record, ƒê langauge support extension for VSCode sets the following config options per the language:

* Show rulers at column positions: 80, 100, 120
* Soft-wrap lines at 100, while adapting to narrower window width

You are recommended to hard-wrap source lines around column 80, and that's not for good old line printers set for Fortran punch cards, but to enable a human reader have 2~3 editor columns layed out on wide screens, to cross check code segments from multiple sites, without necessarity of tab switching, which is good for productivity.

For long paragraphs in comments, of mere documentation purpose, it's considered more idiomatic to keep them as long lines per each paragraph, so you don't need to manually maintain hard-wrap points when update documentation, just leave it soft-wrapped at 100 columns by default.

Nevertheless you can change per user settings of your IDE, for a different soft wrap strategy.

   #} {;
    {## Recommended Line Length #}
    export edh'line'len'adivce = bookmark()

    # %%
    '''
                                                                    80 columns ‚ñΩ
12345678901234567890123456789012345678901234567890123456789012345678901234567890
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                                                                                       100 columns ‚ñ≥
'''
    # %#
  }

}


export edh'semantics = bookmark()


{## Entities, Attributes and Identifiers
 # - Each entity consists of a dynamic set of attribute values identified by distinct identifiers

Entity is the logical unit of information that organized in an ƒê world. Entities only exist conceptually, some entities are used to each back a scope (module scope or procedure scope), other entities are used to each back an object (excepting host objects). While some objects (e.g. module objects, namespace objects, class objects) each encapsulate a scope of its own, such an object and the scope it encapsolutes are both backed by a same entity.

ƒê is rather dynamic in nature - at runtime, not only each individual attribute value can change arbitrarily, new attributes can be added to an entity, as well as existing attributes can be deleted from it. That is to say, the structure as well as the attribute values of each entity can vary on its own at runtime.

 #} {;
  {## Entities, Attributes and Identifiers #}
  export edh'ent'attr'naming = bookmark()


  {## Attribute Identifiers
   # - About naming attributes

Each attribute of an entity has to be uniquely identified. In ƒê, the usual alphanumeric "variable" identifiers (like in other programming languages) can be used.

In addition, symbolic identifiers are also supported and recommended for cross-component scenarios.

And technically, any string (even the empty string) can serve as an attribute identifier in ƒê, with at-notation.

   #} {;
    {## Attribute Identifiers #}
    export edh'attr'ids = bookmark()


    {## A Typical Entity Example
     # - Let's take a namespace object for example
     #} {;
      {## A Typical Entity Example #}
      export edh'entity'example = bookmark()

      # Namespaces are described later in this chapter
      ; () => edh'namespaces # <- follow this bookmark to that section

      # %% # An empty namespace object can be created like this
      namespace ns() pass
      dir$ ns
      # %#

    }


    {## Alphanumeric Names
     # - The usual "variable" identifiers in a programming language

An alphanumeric name must start with a letter (i.e. alphabetic Unicode characters (lower-case, upper-case and title-case letters, plus letters of caseless scripts and modifiers letters) or the underscore character (_); more characters can follow, and they must be alphabetic or numeric Unicode characters, or the underscore character (_) or the single-quote character (').

Note the single-quote character is allowed to mean the prime symbol as in mathematics, following Haskell convention.

     #} {;
      {## Alphanumeric Names #}
      export edh'alphanum'names = bookmark()


      # %% # Some examples:
      namespace alphanum'named'arts (
        a= 3, _b3= 2, a'= 5,
        x= 9, y_5= 1, x''= 6,
        name= 'Compl', city= 'Chongqing', year= 2021,
        œÄ= 3.141592653589793238462643383279502884197169399375105820974944592307,
        Œ©= 0.567143290409783872999968662210,
        √ê= 'A language with great tooling',
      ) {

        method factorial(n) n <= 1 and 1 or n * factorial(n - 1)

        method ùõ¥(*items) case items of {
          () -> 0
          { item1 :> rest } -> {
            s = item1
            for i from rest do s += i
            return s
          }
        }

      }
      dir$ alphanum'named'arts

      # %% # Method procedures in a namespace can be called via dot-notation
      alphanum'named'arts.factorial(5)
      # %%
      alphanum'named'arts.ùõ¥( 3, 7, 9, )
      # %# Procedures and dot-notation are described later in this chapter
      ; () => edh'procs # <- follow this bookmark to that section
      ; () => edh'dot'notation # <- follow this bookmark to that section


      # Special note about the single character identifier with a mere underscore, it is a valid identifier but acts as a blackhole wrt scope attribute assignment. It is idiomatic to explicitly discard the direct result value this way, when only side-effects are desired from some expression with a meaningful return value.
      # %% % Assigning to `_` will not create an attribute named `_` in current scope, though all side-effects by evaluating the right-hand-side expression will apply.
      _ = 3 * 7 # TODO a better example with desirable side-effects
      dir
      # %# See there is no attribute named `_` appeared.

    }


    {## Symbolic Names and At-Notation
     # - To avoid name clashing across software components

Symbol is a special type of values solely for identification purpose, they are defined and used via at-notations.

     #} {;
      {## Symbolic Names and At-Notation #}
      export edh'symbolic'names = bookmark()
      export edh'at'notations = bookmark()

      # A symbol is a value of special type, can only be created with a special syntax, where an alphanumeric name for the attribute in current scope to receive the symbol value is specified.
      # %% # Define a symbol named `secret`
      symbol @secret
      dir
      # %% # Its alphanumeric name can be used against current scope to obtain the value
      type(secret) is SymbolType
      # %# See above is true.

      # %% # Create a new attribute named after it, in the namespace, by assignment
      ns.@secret = 55632
      ns.@secret
      # %# Note neither `.` nor `@` as in above is an operator, also not that they combined. Instead, "dot" (.) followed by "at" (@) and an alphanumeric name, is intrinsic to the language syntax in this form. Remind that `@` can be part (or whole) of an operator symbol, while `.` can never be.
      # And you can have spaces above around both the "dot" and the "at", up to your style.

      # %% # There is another form of at-notation works as well, through `@` as an infix operator
      show$ (@)
      # %% # Assignments and references work straight forward
      ns @ secret = 33526
      ns @ secret
      # %# Note the spaces around `@` above is optional, ƒê formatter honors your stylish to have them or not, but more whitespaces will be collapsed into one.

      # %% # Now create a new attribute named after this symbol, in current scope, by assignment
      ; @secret = 33526
      dir
      # %% # Note the semicolons needed above and below to disambiguate from infix at-notation.
      ; @secret
      # %#

      # The name for the attribute storing a symbol value, and the attribute named after the symbol value, are two different things. A symbol value can be stored under any other name, and used via that alias as well:
      # %% # Create an alias of the `secret` symbol value
      confidential = secret
      ns.@confidential
      # %% # It is ultimately the symbol value that matters for a symbolic attribute, not how that symbol value is named, so:
      console.print$ 'Before changed, @secret is: ' ++ ns.@secret
      ns.@confidential = 12345
      console.print$ 'After changed, @secret is: ' ++ ns.@secret
      # %% # Figured out why `@secret` is changed by assigning to `@confidential` ? Hint:
      confidential is secret
      # %# That's it, the symbol value for the symbolic names are the same, regardless of how these key values are stored and obtained. This mechanism allows you to import symbols from alien modules, but renamed locally to avoid alphanumeric name clashing, while still be able to exchange symbolic attributes seamlessly.

      # %% # Nothing prevents you from creating a new symbol value under an existing name, the old, alphanumericly named attribute for the symbol value, will simply be overwritten:
      symbol @secret
      confidential is secret
      # %% # Now they are different keys, so the symbolic names via them are different attributes, thus can be created/changed independently:
      console.print$ 'Before changed, @confidential is: ' ++ ns.@confidential
      ns.@secret = 54321
      console.print$ 'After changed, @confidential is: ' ++ ns.@confidential
      # %#

      # %% # It can surprise you now:
      dir$ ns
      # %# Confused seeing two "@secret" attributes coexisting?
      # %% # As well as:
      dir
      # %# See "confidential= @secret" in the result? That's because a symbol value has its `repr` reflecting how it is initially defined, and will never change, though the value can be assigned to different names as we have demonstrated here.
    }


    {## Quaint Names
     # - Arbitrary string as identifiers

Another interesting usage of at-notation is, that string values can be used in place of symbols, this enables arbitrary strings as attribute identifiers.

     #} {;
      {## Quaint Names #}
      export edh'quaint'names = bookmark()

      # %% # Using string literals is idiomatic for identifiers otherwise not valid alphanumeric names
      ns.@'we-the-people' = 'proud humans'
      dir$ ns
      # %# Note the minus inside the key, they'll be interpreted as subtraction operators if not be in a string key of the at-notation.

      # A string valued attribute can be used in at-notation for the key value, thus manifesting dynamicly named attributes, but you are advised against this style unless absolutely necessary.
      # %% %
      bad'symbolic'looking'key = 'No, No, No!'
      ns.@bad'symbolic'looking'key = 'Confusing :-/'
      dir$ ns
      # %# Note there are cases it is useful, but rare.
    }

  }

}


{## Expressions and Statements
 # - A piece of ƒê code is just a sequence of statements

Expression is a special (yet very important) type of statement, an expression yields a meaningful result when evaluated. Note that an expression may or may not have side-effects when evaluated.

Expressions can be combined together (e.g. by an infix, binary operator, among other forms), to form a new expression, so a complex expression can consist of many sub-expressions organized in a deeply nested hierarchy.

For a statement of some type other than _expression_, when evaluated, it doesn't yield a meaningful result, instead it produces desriable side-effects.

ƒê is _strict_ in evaluation of statements, an ƒê interpreter program evaluates a statement immediately upon one is encountered. The contrary is _lazy_ evaluation, in which sense the actually evaluation can be postponed until absolutely necessary.

 #} {; import * '../refs'
  {## Expressions and Statements #}
  export edh'exprs'stmts = bookmark()

  {## Typical Examples
   # - Commonplace expressions and statements
   #} {;
    {## Typical Examples #}
    export edh'expr'stmt'examples = bookmark()

    # %% # `let` is a typical statement, its side-effects are assignments to various attributes of the current scope
    let (a, b, c,) = (3, 2, 7,)
    # %# See that there's NO result by running this cell?

    # %% # Arithmetic expressions are very typical, usually having literal expressions and attribute expressions joined with binary operators, e.g.:
    a + b * c - 5
    # %# See the result?
    # Note `*` is the multiplication operator (while in everywhere else other than a programming language, it is `√ó`)
  }


  {## Operators
   # - Fully customizable infix operators with a few intrinsic prefix and postfix operators

There are a few prefix and postfix operators intrinsic to the ƒê language, while all infix operators are customizable operator procedures. A set of infix operator procedures come with the default batteries bundled with the bare interpreter package, more ƒê packages would possibly add their own operator implementations and/or overrides, along with other artifacts such as classes, methods, symbols etc.

   #} {;
    {## Operators #}
    export edh'operators = bookmark()


    {## Intrinsic Prefix Operators
     # - All unary

All prefix operators are intrinsic to the language, they can only be right-associative, but their precedences decide how nested operators parse, thus the semantics.

Especially note that a semicolon (or comma according to the context) may be usually needed immediately before a prefix operator which can also be an infix operator (namely `+`, `-`, and `|`), for disambiguation purpose.

     #} {;
      {## Intrinsic Prefix Operators #}
      export edh'prefix'ops = bookmark()


      {## The prefix plus (+) operator
       # - With precedence 9

It is technically no-op, but is idiomatic to be written out explicitly in certain cases, e.g. as in `+inf` when contrasted with negative infinity `-inf`.

       #} {; export edh'prefix'plus'op = bookmark()
        # %% # It's technically no difference with or without a prefix +
        ; +inf is inf
        # %# See above is true.
      }


      {## The prefix minus (-) operator
       # - With precedence 9

It is used to negate a decimal value, and will err out for other type of values at runtime.

       #} {; export edh'prefix'minus'op = bookmark()
        # %%
        ; -3.5
        # %%
        ; - ( 5 / -11 )
        # %%
        ; -inf
        # %#
      }


      {## The prefix (not) operator
       # - With precedence 4

It is used to negate a boolean value, and will err out for other type of values at runtime.

       #} {; export edh'prefix'not'op = bookmark()
        # %%
        not true
        # %%
        not 3 > 2
        # %%
        not 3*7 == 22
        # %#
      }


      {## The prefix guard (|) operator
       # - With precedence 1

It is used to explicitly mandate a conditional match for a branch, regardless of the contextual matching target value.

       #} {; export edh'prefix'guard'op = bookmark()
        # %% #
        ; | 3*7 is 21 -> "That's so true."
        # %% #
        ; | 3 < 2 -> "No way this get shown!"
        # %# Note that branches are described later in this chapter
        ; () => edh'branching # <- follow this bookmark to that section
      }


      {## The prefix (void) operator
       # - With precedence -10

It is used to technically cease the result (to be always replaced with `nil`) of its operand expression, as well as to formally declare the no-result semantics as an expression.

       #} {; export edh'prefix'void'op = bookmark()
        # %% # It is idiomatic for a procedure to have a `void` body, when no meaningful result is meant to be returned. Compare this (deprecated) implementation:
        method do'sth() {
          that.some'method'with'meaningful'result()
          return nil
        }
        # %% # to the idiomatic implementation:
        method do'sth() void {
          that.some'method'with'meaningful'result()
        }
        # %# See the later is both more concise and more pragmatic.
      }


      {## The prefix (ai) operator
       # - With precedence -10

It is used to perform its operand expression (usually consists of multiple steps) to be evaluated in a single STM transaction.

Note an STM transaction will retry automatically, and prone to no-progressing under heavy concurrent contention. And IO actions are not permitted during an STM transaction. Carefully reasoning is reqired to use this operator properly.

       #} {; export edh'prefix'ai'op = bookmark()
        # %% # A correct (but not performant) implementation of simple concurrent counter can be:
        data ConcCounter(cnt= 0) {
          method inc() ai this.cnt += 1
          method dec() ai this.cnt -= 1
        }
        # %# Note that data classes are described later in this chapter
        ; () => edh'data'classes # <- follow this bookmark to that section
      }


      {## The prefix (default) operator
       # - With precedence -10

It is used to create a default expression with its operand expression.

       #} {; export edh'prefix'default'op = bookmark()
        # Defaulting semantics is an advanced topic explained in another chapter:
        ; () => import (
          edh'defaulting, # <- follow this bookmark to the relevant section there
          **_
        ) '../advanced/dflt'
      }


      {## The prefix (new) operator
       # - With precedence -10

It is technically no-op, and used for source-level compatibility with other scripting languages like JavaScript, where scripting based RPC (Remote Procedure Call) would take place.

       #} {; export edh'prefix'new'op = bookmark()
        # ƒê can be used to validate / syntax-highlight foreign code snippets those compliant to a common subset of scripting syntax, among JavaScript / Python etc.
        false and that.jsRPC(js!expr{
            console.log( 'The time now is ' + new Date());
        })
        # %# Note that expression values are described later in this chapter
        ; () => edh'expr'expr # <- follow this bookmark to that section
      }

    }


    {## Intrinsic Postfix Operators
     # - Currently just indexing and calling

All postfix operators are intrinsic to the language, they can only be left-associative.

There are currently only two postfix operators, namely indexing `[]` and calling `()`. They both have the highest possible precedence.

     #} {;
      {## Intrinsic Postfix Operators #}
      export edh'postfix'ops = bookmark


      {## Indexing
       # - For element extraction & assignment

       #} {;
        {## Indexing #}
        export edh'indexing = bookmark()

        # %% # You can obtain positional arguments from an ArgsPack with positive integer index
        apk = (3, 2, 5,)
        apk[ 1 ] # ƒê index is zero based (i.e. offset semantics as in C family languages)
        # %% # You can obtain values from a dict with the key as index
        d = {
          'name': 'Compl',
          'year': 2021,
        }
        d[ 'name']
        # %% # A dict can be modified via indexed assignment
        d[ 'year' ] = 2030
        d
        # %#
      }


      {## Calling
       # - Making procedure calls

       #} {;
        {## Calling #}
        export edh'calling = bookmark()

        # %% # You've just seen plenty usage of it
        console.print(
          'Calling a procedure is actually the application of the postfix () operator.'
        )
        # %#
      }

    }


    {## Customizable Infix Operators
     # - In spirit of Haskell / C++

All infix operators are defined as operator procedures, many of them are intrinsic (host) procedures, while others being ƒê procedures. They all have a custom precedence & associativity/fixity respectively, and can be overridden by attribute shadowing at particular scopes.

Custom operators must be named with one or more valid operator characters, which is one of "=~!@#$%^&|:<>?*+-/" plus various Unicode characters in the following general categories:

  * MathSymbol
  * CurrencySymbol
  * ModifierSymbol
  * OtherSymbol
  * DashPunctuation
  * OtherPunctuation

Especially note that dot (.) and square brackets ([]) are not valid operator characters, they work with magic methods instead.

However, there are a few hard-coded exceptions, namely the following operators:

  * is
  * is not
  * and
  * or

     #} {;
      {## Customizable Infix Operators #}
      export edh'infix'ops = bookmark()


      # %%
      namespace custom'infix'ops () {

        # You must specify the precedence as well as the desired fixity (use one of the keywords: `infixl` / `infixr` / `infix`) when defining fresh new operators

        infixl 7 (√ó) (lhv, rhv) lhv * rhv
        infixl 7 (√∑) (lhv, rhv) lhv / rhv

        # You can use just the `operator` keyword to override an existing operator

        operator (and) (lhv, rhv) lhv ++ ' & ' ++ rhv

      }
      dir$ custom'infix'ops
      # %#

      # %% # Expressions can be evaluated in scope of a namespace via a scope wrapper
      scope(custom'infix'ops).eval(expr
        3 √ó 7 √∑ -56
      )
      # %%
      scope(custom'infix'ops).eval(expr
        'You' and 'me'
      )
      # %# Expression values and scope wrappers are described later in this chapter
      ; () => edh'exprs'in'scopes # <- follow this bookmark to that section


      # %% # Operator procedures can be referenced with its symbol quoted in a pair of parenthese
      show$ (*)
      # %%
      show$ (is not)
      # %%
      show$ (or)
      # %% #
      scope(custom'infix'ops).eval(expr
        show$ (√ó)
      )
      # But dot-notation won't work for operators, it is designed to work with magic methods instead. The crucial fact to know is: the parenthese is part of the name used to identify a magic method, but never so for names identifying operators.
      # %% # This is error:
      show$ custom'infix'ops.(√ó)
      # %# Magic methods are described later in this chapter
      ; () => edh'magic'mths # <- follow this bookmark to that section

      # Checkout the meta definition for operators come with default batteries
      import * 'batteries/meta/ops' into Nothing
    }

  }


  {## Dot Notation
   # - The Object-Oriented way of namespacing

   #} {;
    {## Dot Notation #}
    export edh'dot'notation = bookmark()


  }


  {## More Expressions and Statements
   # - There are more types of expressions and statements in ƒê

For example:
 * Dict Expresssion
 * List Expression
 * Namespace Expression
 * Class Expression
 * Block Expression
 * Yield Expression
 * Index Expression
 * Call Expression
 * Default Expression
 * Go Statement
 * Defer Statement
 * Perceive Statement
 * Break Statement
 * Continue Statement
 * Fallthrough Statement
 * Throw Statement
 * Rethrow Statement
 * Return Statement

   #} {;
    {## More Expressions and Statements #}
    export more'exprs'stmts = bookmark()

    edh'lang'refs # <- follow this to ƒê langauge reference for a detailed list of statements (including expressions) ƒê code can have
  }

}


{## Values, Naming, Equality
 # - Everything is a value in ƒê

 #} {; import * '../advanced/vals' # <- details of ƒê Value System

  {## Values, Naming, Equality #}
  export edh'val'equality = bookmark()

  everything'is'a'value # <- follow this to see how & why everything is a value


  {## Named Values / Term Definitions
   # - The named is the mother of ten thousand things

   #} {;

    # %% # make sure to run this cell before the ones following it
    œÄ := 3.14

    # %% # this prints its name, not value
    repr( œÄ )

    # %% # after arithmetics, it is no more a term,
    repr( œÄ * 1 ) # just an immutable numeric value

    # %% # while type of a term comes from its value
    type( œÄ )

    # %% # and ƒê knows it being a term, and can show that accordingly
    show( œÄ )

    # %% # otherwise it's can be used just like an attribute
    r = 1.58
    C = 2 * œÄ * r

    # %#
  }


  {## Null Test
   # - Nullability


   #} {;
    {## Null Test #}
    export edh'null'test = bookmark()


  }


  {## Identity Equal
   # - Being identical

   #} {;
    {## Identity Equal #}
    export edh'id'eq = bookmark()


  }


  {## Value Equal
   # - The usual _equality_

   #} {;
    {## Value Equal #}
    export edh'value'eq = bookmark()


  }


  {## Namely Equal
   # - Equal values can be differently named

   #} {;
    {## Namely Equal #}
    export edh'namely'eq = bookmark()


  }

}


{## Control Flows
 # - Handling varity of input

A computer makes no sense if every distinct input has to be processed by a unique program. To be actually useful, a computer (at times, even a single program on a computer), needs to accept input data of sufficient varity. So some level of abstraction has to be there, this leads to polymorphism.


 #} {;
  {## Control Flows #}
  export edh'ctrl'flows = bookmark()


  {## `if-then-else` - Boolean Branching
   # - Conditionally branching


   #} {;
    {## `if-then-else` - Boolean Branching #}
    export edh'if'then'else = bookmark()


  }


  {## Blocks, Matching Branches, Fallthrough
   # - Forming a hierarchy of control elements


   #} {;
    {## Blocks, Matching Branches, Fallthrough #}
    export edh'branching = bookmark()


    {## `case-of` - Nested Matching Context
     # - With a local matching target

Dynamically compute a value, with it being the matching target, evaluate a block of expressions (or rarely a single expression)

     #} {;
      {## `case-of` - Nested Matching Context #}
      export edh'case'of = bookmark()


    }

  }


  {## `for-from-do` Loop
   # - Looping against some undeterminisic source


   #} {;
    {## `for-from-do` Loop #}
    export edh'for'loop = bookmark()


  }


  {## `while` Loop
   # - Checked iterations

   #} {;
    {## `while` Loop #}
    export edh'while'loop = bookmark()


  }

}


export edh'pragmatics = bookmark()


{## Classes & Objects
 # - Compositional Multiple-Inheritance with Multiple-Prototype Chains
 #} {; import * '../advanced/objs'
  {## Classes & Objects #}
  export edh'classes'objs = bookmark()


  {## Data Classes
   # - Python PEP-557 (Data Classes) got dedicated syntax in ƒê

Beyond PEP-557 features in a dedicated syntax, ƒê data classes especially shines in pattern matching use cases, closely mimics ADT, predating PEP-634 (which is upcoming in Python 3.10).

   #} {;
    {## Data Classes #}
    export edh'data'classes = bookmark()


  }


  {## Usual Classes
   # - A data class is still a usual class under the hood

The `class` keyword defines a usual class.

   #} {;
    {## Usual Classes #}
    export edh'usual'classes = bookmark()


    # %%
    class B pass
    class C extends B
    class D extends C
    class E extends (D,B)
    # %%
    E.mro
    # %%
    o = C()
    o.a = 5
    # %%
    dir$ o

    # %#
  }


  {## Magic Methods
   # - Customize object behaviors in cooperation with infix operators


   #} {;
    {## Magic Methods #}
    export edh'magic'mths = bookmark()


  }

}


{## Modules
 # - Each module object is loaded from a particular `.edh` file


 #} {;
  {## Modules #}
  export edh'modules = bookmark()


}


{## Namespaces
 # - A namespace is a special object


 #} {;
  {## Namespaces #}
  export edh'namespaces = bookmark()


}


{## Procedures
 # - ƒê is functional to such an extent

Several type of procedures, the lambda forms (arrow procedures), and expression being 1st class as well


 #} {;
  {## Procedures #}
  export edh'procs = bookmark()


  {## Methods, Bound and Unbound
   # - Procedures owned by some object

All procedures are methods of some object, but a particular method doesn't have to be bound

   #} {;
    {## Methods, Bound and Unbound #}
    export edh'mths'bound'unbound = bookmark()


  }


  {## This/That/Super Reference
   # - A class of multiple inheritance creates composite objects

ƒê follows JavaScript/Java/C++ to use `this` keyword, instead of Python's `self`, however this is not a simple choice end here.


`that` reference solves a problem akin to the slicing problem of C++
  https://en.wikipedia.org/wiki/Object_slicing


   #} {;
    {## This/That/Super Reference #}
    export edh'this'that'super'ref = bookmark()


  }

}


{## Lexical Scoping
 # - Static scoping is used for usual artifact resolution (i.e. other than effect resolution)

 #} {;
  {## Lexical Scoping #}
  export edh'lexi'scoping = bookmark()


  {## Closure
   # - A procedure always captures the full lexical context it is defined in

ƒê closure is rather coarse grained.

   #} {;
    {## Closure #}
    export edh'closure = bookmark()


  }

}


{## Expression Values and Scope Wrapprs
 # - Here is why ƒê is even More dynamic than Python
 #} {;
  {## Expression Values and Scope Wrappers #}
  export edh'exprs'in'scopes = bookmark()

  {## Scope Wrappers
   # - A scope can be wrapped as an object to do reflection in ƒê

`scope` is a builtin class.

   #} {;
    {## Scope Wrappers #}
    export edh'scope'wrappers = bookmark()


    # %% # without argument, it creates an object wrapping the scope where it's called from
    method f() {
      method g() {
        let ( a, b, ) = ( 7, 3, )
        scope()
      }
      let ( c, d, ) = ( 2, 8, )
      return g() @=> g = nil # dispose g after one-time used
    }
    s = f()
    'inner has ' ++ s.attrs() ++ ', outer has ' ++ s.outer.attrs()
    # %#


    # %% # if an object is passed as ctor argument, it creates an object wrapping that object's scope
    class C pass
    o = C()
    s = scope(o)
    s.put( a= 3, c= 2, b= 5, )
    s.attrs()
    # %#

  }


  {## The `expr` Expression
   # - Original source preserved

A procedure is always called against some object, it also has a formal declaration of its arguments, what if we strip off these properties? The result is: we get expressions.

Expression is 1st class in ƒê, you can create expression values with literal form

   #} {;
    {## The `expr` Expression #}
    export edh'expr'expr = bookmark()

    # %%
    x = expr a + b * c

    # %#

  }


  {## Expression Arguments to Procedures
   # - Arguments are passed in expr form, to interpreter procedures and 3af operator procedures

For an interpreter procedure or an infix operator procedure with 3 positional arguments, the first argument will be wrapped scope object of its caller, and rest arguments are all expression values.

   #} {;
    {## Expression Arguments to Procedures #}
    export edh'expr'args = bookmark()

    # %%
    x' = makeExpr( a + b * c )
    # %%
    s.eval( x' )
    # %#

  }


  {## Code as Data
   # - A runnable piece of ƒê code is just data from the perspective of the host language/runtime

ƒê host procedures (written in Haskell) see ƒê AST directly.

   #} {;
    {## Code as Data #}
    export edh'host'proc'exprs = bookmark()


  }

}


{## Effect Tracking
 # - Vending & consuming effects with dynamic scoping

 #} {;
  {## Effect Tracking #}
  export edh'eff'tracking = bookmark()


}
